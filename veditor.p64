picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDA5OjQ3OjM0Iixtb2RpZmllZD0iMjAyNC0x
Mi0xMSAxNTo1NjoyNCIscmV2aXNpb249MTEzOTRdXWx6NAC5CAAAP00AAPEZe1swXT17Ym1wPXB4
dQBDIBAQBPDwLGZsYWdzPTAscGFuX3g9MC4yNQsAMXk9LQwAh3pvb209OH0sOAD8QgoIBKB-IAAO
DyEPFAQPHw8PCA8YAh4PFQUPFgYHDxcPDg8eHgEPEA8RDA8cDx0PDQ8SHg8TAw8bCw8aCgkPGR4H
Dw8GDxYPDQUPFQ8hDgB_AIQAA4EAEjB9AC8xM34AAiEHBgIAIQgeCADxAggPGAceBwYHDQgGBwYe
BggNHQAxHggGCAAfBmYAJrJ-FR4MLxwMLR4NDAIAnx4dDC0MDR5-FVMAKUAtDxwtSgABUwCfHg0M
LQwdHgxtUgAe0gkJBAAGEAcQBgA2BzYKABIQEABZJwYHBicSAAUiAA9jAAwcN2IA8QggMSARDxAB
FwEQAR5RHhEXIR4BFwEOEQYA7wEAAQ4BFxEQERchMCEgWQAc8B7QDxsPEw8bEA4ADgEPGA8TDxgB
Xh8TAQcQBw8YDxYPFQ8TATACLxUPEwcgBwIsAq8TDi8YPg8TAC4dawAa-wgHBgQQJhAmDxY2TgYA
Bi4GIAYOBkAGIGoBGgArA-8NE2GAATABAAFwATABEAFgATABIAFQATBBUAFwAQQAAj_R8BNlAAsc
OSAC8QEgPyBQDh8bDjAuHS4QDl0OBACfLh0uMA4dDlA_swANHzVvAgKwHxUfHAwNHxUeCwxxAhUL
dwKOLSwdHisfECt3Ag9aABRgfxUeDV8cwAIQPcYCT1wNHn1MAB4AwwLxBQ8VEA8WEA8VAD4PFj4A
DhANEA4QBgBpAC0ODQ4tEgAjPg0iAB8AbgIc8QkgPxUgHgUOHxYOEA4VXhUeHS4VDh0OBR4GAO8O
AA4FDh0eEB4dLjAuIMgCIxRAxQLwAwAPGwAOPxMBXg0RByAHDxUNEbgCXw0ALh2wtwIeUCAGIAYA
wwMQFskDfwAGIAYgJhBGABkHrAESfQIADqMBD5cCDoHwBX8gEA5YDgQAP37wBT8AHAGBAPAKLxUf
HC8VHi0cDxwdHi0LDxELHR4tDAsPEA4ALwotlgAd8woJCQQBMA8dIAEgLhABEB4BHgABAB4BBwEe
DQAAFwBvMA4gAXCBVgALLDE2VwDxAQ8dMAEgDiAhEA4QQQAOAGEHAAAPAADwA09wBwFuUQAd04AX
TScNRw0HDQdABx0EAJ8NBw1HDSdNF4BNAB3xBiAhMBEsERABDBEcAQBRHGEcYRwBAA4AThARLBGF
BQ9RAAu-BwYE0AZAJiAWAEZYAhwBiwDQQAEvDwEgIQ4hAAEOQRMG-wIOAR4RDkEOAQAhDiEgAS4B
QJAADh0yVgDzCAEPGgFAAS4BIGEAAQ4RDhEOAR4BLgEeDAAhAGFYAD8BDgFaAB-CITARLgEQAQ4x
DgEACQCiIDEOARABLgABDgkALxEwsQAfJAABAgBBDxwBDgIAYgABAEEAAREBgAAxDhEAAS4hvQAA
CgAyAAEuJAAQIQwAHwDFAB6gAQABQAEHAQcRIAYAgAEGARABBw8WCQDwAgARBwYHDgYRBw4GFxYB
AAEHBwCPEAEXFgEwMRBoAB3jgB8VRS4FTgUOBQ5ADhUEAJ8FDgVOBS5FHoBOAB3wBzAKQAoAHxkA
DgoQHioOMAopCg4ACg4HACAKAAcA7zAOKh4QCg4AHgAKQAowXgAawAcGBDAGQBYPFiAWDgMAbwYF
DjAeQFcDHf8NoCFAEQ8WETABDgcOATARDhFAIQdwDhdgDhdgHhcDHBEASwAgMRBLAHAHDgEQEQ4x
qwEQUPQBTwcwIQBWACSRQSARDxYBDhEQPgIBWAAMDgBPBwEgMV4AI-ALUCEwIQ8WASARDgcRACEH
IQARBw4RIAEOIQf5BA9TAB8OWgwPhAEADzIALP8CCQkE8AYPFnAOUE5QDnAO8AZ4CB3wADAhQAEP
EAwOASABDgwODAEE0AwPHAEeAQARDQwRDhElCVAcEQABPWsDLg0RzAQPYgAOYBAiQAIPHhAN8QwC
IAIODw4ODQ4CEAIeAg8XDQIQAg4SDQwSABKPCc8CABI8AiASDAcCQCJnABswCgoEfw0xDxVQBgDw
CVEAAg4BRxEOAWcBABEsBw8OBwEAAScMJxAEUQ0HLBEAGQBfVwEQYQBnACMiAUAHACBQAsQE-xYg
DgEAEQgREAEAEQkHDw8RIAEKJw8OASARCwcPDREwEQwRUCHAaQAdQCAfFmBwBEEuFQ4goglQIA5F
DjAEAFAuJQ5QDgQAXwUOcA4QWAAdoBBfFiAeNR4QDlUECv8FHhUOED4lDjAOJR4wDhUeQD5QDhVl
Cx4OtwIPbQMPb-AWTxbwFjUADA5mAA8xAP9AAIwBH0FiADwfMTEA-yH-HQgIBA8YUA8QHxgwHxAA
HxgQHxAQLxgAHxAgLxgPEBAOAD8YAB4QHRAuAB0AhwYe8AAoEYBBFxFgASchFwFgEQcvCVABUCEH
AZQHYUABByEAIQgAABAAMSFQASAA-AARYAEXIScBYBEXQYAR8BdyADUuODMBAAN_AGQtMi42MTYB
AB84sQwBAIwA8xYYAdABBwGwAScBoEGAEQABBwEAEVABByEHIQcBMAEXAUcBFwEwEAATUCAA74BB
oAEnAbABBwHQAfAHjAA3UkUBQAFw_ABQAVABB2GCAEEHEUcRCAARYRQAARwAb3ABQAHwNAQBPwC9
ChCQ7ABQAZARBxEQABPABABDsBEHERoAASYAD-wAPzcoAdBwAPcAkCEgIVABJyAnAVAhICGQGgAv
0AH_ATkgJyH6AVGwIZABYF4BH0AEAABTUAFgAZAoAC-wFnwANx-wSwD--9gAdwshAWBLA-ECFwFA
AScBMAE3ASABRwEQASc0DxEXxRUsBwE-ClwzMy42M3EARjQ1LjOHABIycQAeM7wAD0wA--------
-------------------------------------------------------------wBQbT0zfX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI0IDA5OjQ3OjM0Iixtb2RpZmllZD0iMjAyNC0x
Mi0xMSAxNTo1Njo1MyIsc3RvcmVkPSIyMDI0LTAzLTI0IDA5OjQ3OjM0Il1d
:: help/
:: help/colors.txt
--[[pod_format="raw",created="2024-04-13 09:44:45",modified="2024-04-16 17:56:34",revision=205]]
--[[pod_type="gfx"]]unpod("b64:bHo0AJcAAAAgAwAA-hNweHUAQyCKJgT-IIz-FAH0Af8fAf8PAfgB-xgB8gEvIOcOFgA-LgfuFQBoLv4DFAD-DB7-FQAO9QH-FgH2AfcB-xcB-w4B-x4BHu8VBxcAdD8PFecXAAAv-gMrAAD-BvEB-xAB-xEB-AH-HAH-HQH-DQH-EhcAp-8E-xMB8wH-GwH7Af8aAfoB_QH-GRUAk1D-GQH_ew==")
--[[pod_type="gfx"]]unpod("b64:bHo0AFkAAABXAAAA8EhweHUAQyAKCASgfyAADg8hDxQEDx8PDwgPGAIeDxUFDxYGBw8XDw4PHh4BDxAPEQwPHA8dDw0PEh4PEwMPGwsPGgoJDxkeBw8PBg8WDw0FDxUPIQ4AfgA=")
The color palette allows you to select colors for a variety of
elements, primarily the layer stylings of:
 - Color A
 - Color B
 - Outline Color
 
Set colors A and B together with left click.
Set them individually with shift or ctrl click.
Set the Outline color with right click.

Additionally, press shortcuts with the mouse-over the palette:
 - key[Set Canvas Color]: Set Canvas Color
 - key[Toggle Grid]: Set Grid Color
 - key[Set Axis Color]: Set Axis Color
 
:: help/files.txt
--[[pod_format="raw",created="2024-05-01 09:31:52",modified="2024-05-01 09:42:27",revision=27]]
To associate .vgfx files with Veditor in Picotron,
enter this command into the terminal:

`default_app vgfx /path/to/veditor.p64

This will cause .vgfx files to be treated similarly to
.gfx or .map files with their own native editors.
:: help/fills.txt
--[[pod_format="raw",created="2024-04-13 09:44:45",modified="2024-04-14 12:54:07",revision=139]]
--[[pod_type="gfx"]]unpod("b64:bHo0ADgBAACRCQAA8glweHUAQyCJJQT-IFb4Av4C9wAO9wAOJwUCADoOBQcCAAcaAAIIAEonCAcFAgAyCBUXAgASHkwABQMAEhcxAFoFBwgFBwIACTMAAyYASicOBwUCAA6NABIHKgAvBReOAAgDWgAfFY4AGAIxAAUzAA8NAf-OIP5X_QIqBwUCABMOHgA6Fw71_QASBxcAGRVlAAITAF8XBR4HBUcABQLrAAXEAAMXAB4VEgAfHosACi-1AHgAAQ_fAAAPiwALF-V2AQYZAA4TAB8eGAH-1yL_exIAD7MABDEVByUCABcFRQAFlAAHYgALigM6HgUHAgAHSQAI3wATBRYAFxWaAA3EAx8eygAKBqUBBh0AHvWyBA_bAAgDhAAvJQ4aAAkEqAAFEwACXwAIgQASHggAD0oB--8fUAcFB-56")
--[[pod_type="gfx"]]unpod("b64:bHo0ACQAAAA_AAAA8gFweHUAQyAKCASgfyAADgcFAgATHggALwceEgAGUAUOAH4A")
vgfx supports fill patterns with alternating colors.
Select fill patterns per-layer for more distinct details.

`If you don't see a difference, the layer may have only
`one color set.
:: help/general.txt
--[[pod_format="raw",created="2024-04-13 09:44:45",modified="2024-04-14 13:02:49",revision=157]]
Vector images are made up of connected points in 2D space.
This allows them to be simply scaled and rotated in ways that
pixel images cannot.

In Veditor, instead of pixels on a grid you will be working with
points and the edge-lines between them.

As you are learning, take the time to mouse-over UI buttons to
see their descriptions in the info display at the bottom-left of
the canvas view.

The basic layout of Veditor is:
--[[pod_type="gfx"]]unpod("b64:bHo0AAIGAABMCgAA8S9weHUAQyDyiQT-IOP3AvwKF28Q96sfIBc-EDcuR1wHjAecfvcHWPdWDhcONw4HHjc_Zw43PrcMFww3HyAXPiQA0EwXHCd8Pgcu9wZ491UoAEA_Nx6HBgAADAAzLEcdJwAybAcMJwDBBZj3VA4XDkcuNy5HUwAAKQD1eEcsNx33AtwHvH73BEgXSPdHWPcmHAcMNx0VVvUwSAcYB0j1RXj1LR0VViUBDxcBRR8bNUE1HxYBdQEFHw2lEyUBDxYRJTgHOAc4hQsFCxUL9RQPFSsKJTs1AQ4BNQEOBgFVmPUsHRUWERYVHxcFESUPGxEJJREMETUbB3UBDw0RBHUTHiUBC0QA8gsVKxUL9RELJQslCxULJSEOASUOAQoBRbj1K0UA8A8RBR8XJQkRCSUBDCElCgcLB3UBBRSlDwIBNQtFOFdBAFobFQv1EkEA9QYGDjU4R0g-FI8Efx_PD3iPGH8CDRXTAPkDGTUBDCE1CgcBdUF1Ew5lCwoV0AAWCs8AMQYRNRsADkoAIfUwGQAv9UIgAAFu-Tu4-UIFggBv-TyY-UMFMgACQj14-UQaAPgHNYt2h38Xjw5-Hg0V-T5Y-UUVKEc4RRUAWpkVCphVEQA6GnhlEQDRIVh_jxF8jxx-HYR-EhIAH4ERADDvjxNziX8Ljxp-Co8JfxkTACty-TUV-Zn1OQQA9QklER8CARUBCgsKASUBCg8TCgH1FAEPC7UaADALCgsaANwMCgH1EwEvCyUvGAE1NwAQDh0A1hEPCwElMTX9mfUrEbVhAPMJFf0wBBYEJf2ZFQ0HAX0BJiEG8RwPAgQmEgBwSC0RBhEGAQIANRbxFxgAImgdFwBEERbxGBUAJYgNKwAVBhYAYTgnOPIkDQwAggU4BygHOP0kDQDFKAeIFvEBBmEG8QcNEgAhBiE_AABGACBBFgYAEiFSACcWwSQAoEEGERYhBjEGEQYGADghBuFfACEWMTIAcBEGMSYxBgEEADUGwQ2LADTxJA2tACP9JgoAcQFoEwEW8SEZAKcFWP1_FQ0RSCMBigAh8RUcAJMEeP19FQ0RcwGBACHxFBcAQQOY-XwXAAV6AAMZAKECKEc4-XsVDfEuDwBgATgHiP16bgEGDQBhDRF5ARZRLwEDJAAjJ2gXABEGTAERNncBKxINNABCBhEWAZ8APybxEx0AAoMRFhEmERbxDx0ARUdI-XqKAEMCuP17iAADvQASeIYASGEG8RDrABh4hgBIEQbxDyQBGHiGABQROgAWmRoACYMAFZl_AAhxAjcRfwl6ABI0FAAdcHYABxkABXIAHiEZAAFxAAZJACLxLgkAM-0wNG0AFQttAQMSABt8ZwEHFwAG2wAAwwAKGQAhERZ4AQ9nAAQTfNMACzgAD2gADQjRAB980QASHaE7AS9uEWgAAi9uEWgABC9uEWgAEbURcgEWcRaBBvENDREAAWgAEBGjA1gWERbxDhkABWoAATwDBxsAIBYBbABGJgEmITIADWwAEXeMAwUNAAJoADEG8RkTAAUVBfETCQL1Jis1C1X9mSUCKgH1IgtVCwULRf2ZJQEWEfUiGzULFQ4AsBFY9SALBQslGwULFAVwAXj1HwtlGwsAs5j1LP2ZFSg3SPUrOgRCSP0jNEYE9Qc4BzitDxIOSQ0ZHQhtCy0LXR8TbQQmHAD3CU0IPQEeCSstCR0YDQkBLQsNHxILTT8TXSMA-QUJDQEJLScPHg4KGSsJDQkdGQEpHSgA8AYoB0gNCz1bAQkKGx0ZDQEJAQkcAR1vAAVuAPIHN1gNAV0uHSkLHRkdAQkMAT0LLQs9Q0EA9QAVuH0PEh49GX0RTQsdDwk2ANIVDZj9EQsdDxILPVNNEgCCHXj9Ekstcz0OAEItWP0nCgAk-TAIACYkBggAU4sGXRZNHADUggYtBi0WLQYNBh0GPRQASRYdBj0kACf9BksAAAgAlYAGrQYNBy0HXRAAAEEAOX0HnRAAex0GTQcdB208AAhEADJNBl0ZAoSAJm0GDQY9Fg8AIAYNhQBhFk0GXfU5gQCA9Tn9mfU5-eM=")
`A) The Tool Bar
Here you will find tools and view controls

`B) Layer Styling
Each layer has color, fill, and type settings

`C) Layer List
All layers for the current VSprite are listed here

`D) VSprite List
Each .vgfx file is permitted an unlimited number of VSprites

`E) Canvas
Here is where you view and modify your artwork


To navigate the canvas, move the view using the Pan tool or hold
key[Pan] while dragging the mouse.

Zoom with the mouse wheel or -/= keys (holding shift for fine zoom)

:: help/layers.txt
--[[pod_format="raw",created="2024-04-13 09:44:45",modified="2024-04-14 13:02:15",revision=167]]
A Vector Sprite is made up of multiple layers which can be added,
moved, and removed.

--[[pod_type="gfx"]]unpod("b64:bHo0APgDAABoBgAA-gJweHUAQyCOXwT1-w--IHo1-gMA8gkEJm4W-iUGTgb_HjX_BAYeBm4G-iUG-iQNADAeFi4GAPADBh4mHhYeJv4RBj4WHiYuFv4UOQAkHgYCABcOBACGHgb_DQZOBh4PABAQTAARPgwABBYABAQAJP4QKwA2Nv4TJwBELiYeJiMACVAAE05OAFBOFi4WPi0AERYhADEQNg4wACAeJkYAZBMWLhb_UOEAqgPY-lk1-gMIvggIAKAedh4IHnZOdv4PBQAQDhMA8AoOBi8VHxwvFQYOCA4GHR8cDwwPHB0GLgZ9gwATfQkAAikAIS0fHAAAKQAyDQ8MKwCwDwwNBi4GDC8cDCsxAKYtCy0LBi4GDVsNNgBCCw8RCzYAMBsMCwIAUgYuBgsMAgAANAAwHQsNAgAANwA3Cz0LOQBCDAsPEDkAsCssGwYuBhsMKwwLMgBdDQstCx1nACEKLSwANC0aLb8AJwttwAAP-AAACx8BATUBH3oDAAL2GPX--zCdVX5lfvU6PvUJDT8LPxMNRQ4FFxUXBQ5FDi0bLQ71OQ4TDhsAQBUXFRcaAMQcCx0O9TcuEy5FfpUcAFAHFRcVBx0AARoBtQ71Nw5TDkUOXxgOIgBAFxUXFSEAPwwLCiAAAgV5ADULCi1fAAOgAACHAPAcej71--9C-nDV-nDVHvFsHtUe8QYnYQfxDhdxJ-EgHtUeMdoxB4EH8Q0HEQcAARIAMAq8ChQA3EEXEQcRBxEXEQcBF4EdAFJhBwEHEQQASxeBF5E6ABEnGQBMNwEHsTgAEDFTADAnAQcMAAZyAACEAEE3EScxGwAUkU8AgvEGJ-ECF-EMqQAAvQACyADwHA4W8mse1Q4Wqm0qJ2oH_g4Xeif6HxIO1Q4WKiZKDRkfCwkNKgeKB-oNBxoHAHEHBmomagZKIQCRGgYqBjoNBBkUIgDQShcaBxoHGhcaBwoXiisA0QYWDxY6JgAmOgYABjoxALEKBhoGGgYqDRQZBDMAUmoHCgcaBAD5AxeaB5oH_gUWAEoGQAYqBiAGKjIAMgkUGWUAEScuAMA3CgeaB6oH_gQWAGosAEcGQAYakwAiGRS1ABA6kQDwACcKBzoHige6B-oDBgUAio0ARSYAJhrjAAPAAEE3Gic6LQDCijeKB2oBqhCqBmomtwAAGwHB_gIX_gwnWgEHAfoWFQDwAfJBARcB8hYe1f5EAScB-hcIAPgFNwH_FtUe8UMX8Rce1R4hCA8YCAsCABAhLQKBDwdxJ4EH8RYiABoLAgAQIcUBFA6zAQ8fAAIISQIvcQcqAAkIVgIfkSoACgZjAh_hKAAKBnACDygACgZ9Ai8ngSYABQ_NAgFQcNX_cKU=")

Multiple layers can be selected at once (by ctrl or shift clicking)
to quickly apply style changes or to be moved/rotated/scaled.

A layer's "type" determines how it will be rendered, these fall
into two categories: "Polygon" and "Line"


`Polygon (Ear Clip)
--[[pod_type="gfx"]]unpod("b64:bHo0ADMAAAAxAAAA8CJweHUAQyAKCASgfyAADi8VHxwvFR4tHA8cHR4tCw8RCx0eLQwLDxAdHi0LCi0OAH4A")
A polygon with 'Ear Clip' triangulation. In most cases this is the
ideal type, but is slower to initially  generate than strip or fan
triangulations.


`Polygon (Fan)
--[[pod_type="gfx"]]unpod("b64:bHo0ADUAAAAzAAAA8BBweHUAQyAKCASgfyAADh8VHxwMDR8VHgsMHQwNDAseBgDwAQ0MDR4tLB0eKx8QKw4AfgA=")
A polygon with 'Fan' triangulation. With this triangulation, each
point will have an edge connected to the first point. This is a
fast triangulation to generate and is ideal for convex or largely
round shapes.


`Polygon (Strip)
--[[pod_type="gfx"]]unpod("b64:bHo0ACsAAAAsAAAA8gpweHUAQyAKCASgfyAADn8VHgwvHAwtHg0MAgDQHh0MLQwNHn8VDgB_AA==")
A polygon with 'Strip' triangulation. For this, each successive
point adds a new triangle connected to the last. This
triangulation is best for strips of triangles, but can be awkward
to edit.


`Line
--[[pod_type="gfx"]]unpod("b64:bHo0ACwAAAArAAAA8AtweHUAQyAKCASgfyAADn8VHi0PHC0MHh0MDQIA0B4NDC0MHR4MbQ4AfgA=")
A single line which will be drawn through each point from the
first one to the last.


`Line (Closed)
--[[pod_type="gfx"]]unpod("b64:bHo0ACcAAAAlAAAA8BZweHUAQyAKCASgfyAADn8VHg1fHA0eDQw9DA0eDVwNHn0OAH4A")
Like the "Line" type, but will finish by extending the line back
to the first point.

:: help/settings.txt
--[[pod_format="raw",created="2024-04-13 09:44:45",modified="2024-04-14 17:29:45",revision=153]]
`Grid Size
Sets the size of the canvas grid, used as reference and for
snapping.

`Guide Frame
A rectangular guide displayed over the canvas for reference.
By default it is picotron's highest resolution and aligned
centrally. These settings can be changed to suit your project.

`Snapping
Sets how many on-screen pixels a point is to a snapping target
before it will snap.

`Subpixels
This toggles the value of "vgfx_subpixel", effecting how triangles
are rendered.

Disabling subpixel positions adds to the render time and makes
animated transformations appear a little less smooth, but
it should prevent edge seams between polygon triangles.

:: help/shortcuts.txt
--[[pod_format="raw",created="2024-04-13 11:28:40",modified="2024-04-16 11:26:45",revision=236]]
`Navigation
Pan: key[Pan]
Zoom +: Mousewheel or key[Zoom +]
Zoom -: Mousewheel or key[Zoom -]
Fine Zoom: Shift + zoom
Reset View: key[Reset View]

`Point Tool
Add/Move Point: Left Mouse
Add sequential Point: Shift+Click
Remove Point: Right Click
Subdivide Edge: [1] to [9]

`Snapping
Snapping: key[Snap] (hold)

`View
Wireframe: key[Wireframe] (hold)
Info: key[Toggle Info]
Grid: key[Toggle Grid]
Toggle GUI: key[Toggle Panel]
Switch Panel Side: Shift+key[Toggle Panel]

`Color Selection
Colors A+B: Click
Color A: Shift+Click
Color B: Ctrl+Click
Outline: Right Click
Canvas: key[Set Canvas Color]
Grid: key[Toggle Grid]
Axis: key[Set Axis Color]

`Layers
Toggle Select: Ctrl+Click
Serial Select: Shift+Click
Select all: Ctrl+[a]
Deselect all: Ctrl+Shift+[a]
Cut: Ctrl+[x]
Copy: Ctrl+[c]
Paste: Ctrl+[v]
Duplicate: Ctrl+[d]
Delete: [delete]
New: Ctrl+[n]
:: help/snapping.txt
--[[pod_format="raw",created="2024-04-13 09:44:45",modified="2024-04-14 16:52:35",revision=146]]
Sets whether points snap when moved with the Point Tool.
The snap setting can be toggled by holding key[Snap].
--[[pod_type="gfx"]]unpod("b64:bHo0AEYAAABFAAAA8ChweHUAQyAJCQTQDxsPEw8bEA4ADgEPGA8TDxgBXh8TAQcQBw8YDxYPFQ8TATACLxUPEwcgBwIFEACgDi8YPg8TAC4dIA==")
--[[pod_type="gfx"]]unpod("b64:bHo0ADYAAAA0AAAA8CVweHUAQyAJCQTQDxsPEw8bQAEPGA8TDxgBAA8bAA4-EwFeDREHIAcPFQ0RDi8YPg0ALh2w")
There are several snapping modes:

`Grid Snap
--[[pod_type="gfx"]]unpod("b64:bHo0ADIAAAAwAAAA8CFweHUAQyAJCQQAIUARDxYxEAEOBw4HDgEQEQ4xIAEHAVABDgEABzAhAA4XYA4XYB4=")
points will snap to the intersections of grid lines.


`Point Snap
--[[pod_type="gfx"]]unpod("b64:bHo0ACcAAAAlAAAA8BZweHUAQyAJCQSgIUARDxYRMAEOBw4BMBEOEUAhB3AOF2AOF2Ae")
points will snap to other polygon points.


`Edge Snap
--[[pod_type="gfx"]]unpod("b64:bHo0AC8AAAAtAAAA8B5weHUAQyAJCQRQITAhDxYBIBEOBxEAIQchABEHDhEgAQ4hByAhEA4XYA4XYB4=")
points will snap to polygon edges.
Holding shift will also snap to the midpoints of edges.


`Pixel Snap
--[[pod_type="gfx"]]unpod("b64:bHo0ACsAAAA4AAAA8QZweHUAQyAJCQQAQSARDxYBDhEQAQ4CADwQEQ4OALAHASAxDhdgDhdgHg==")
points will snap to whole-number values in the canvas space.

:: help/tools.txt
--[[pod_format="raw",created="2024-04-13 09:44:45",modified="2024-04-16 18:12:30",revision=166]]
`Point Tool key[Point Tool]
--[[pod_type="gfx"]]unpod("b64:bHo0ADEAAAAvAAAA8CBweHUAQyAJCQQgIUABLw8BICEOIQABDkEOER4BDgEeEQ5BDgEAIQ4hIAEuAUAhIA==")
Create, Remove, and Move points - one at a time.
Moving points will always follow the current snap setting and mode.

By default, new points will subdivide the nearest edge, but holding
shift will make a point connected to the last point in the
layer's list.

You can subdivide an edge with n cuts by pressing a number
key (from 1 to 9).


`Rotate Tool key[Rotate Tool]
--[[pod_type="gfx"]]unpod("b64:bHo0AC0AAAAwAAAA8gdweHUAQyAJCQQgITARLgEQAQ4xDgEACQCBIDEOARABLgAUAHAQAS4RMCEg")
Rotate all selected layers. Hold key[Snap] while rotating to snap at
set angles.


`Grab Tool key[Grab Tool]
--[[pod_type="gfx"]]unpod("b64:bHo0ADEAAAAzAAAA8xJweHUAQyAJCQQgAQ8aAUABLgEgYQABDhEOEQ4BHgEuAR4MALAAYSABLgFAAQ4BIA==")
Move all selected layers. Hold key[Snap] to move in increments
equivalent to the grid size.

Press the arrow keys when the Grab tool is selected to nudge
the selected layers one unit/pixel in that direction.


`Scale Tool key[Scale Tool]
--[[pod_type="gfx"]]unpod("b64:bHo0ADwAAABHAAAAtHB4dQBDIAkJBAABAgBBDxwBDgIAkAABAEEAAQ4RHgwAsDEOEQABLiEOEQ4BCgAyAAEuJABgIQABAAEA")
Resize all selected layers. Hold key[Snap] while scaling to snap at
specific scales.


`Pan Tool key[Pan]
--[[pod_type="gfx"]]unpod("b64:bHo0AEEAAABBAAAA8AVweHUAQyAJCQQgAQABQAEHAQcRIAYAgAEGARABBw8WCQDwAgARBwYHDgYRBw4GFxYBAAEHBwCAEAEXFgEwMRA=")
Drag your view of the canvas


`Pivot
--[[pod_type="gfx"]]unpod("b64:bHo0AC4AAAAwAAAA8xBweHUAQyAJCQQBMA8dIAEgLhABEB4BHgABAB4BBwEeDQCgIC4QATAOIAFwgQ==")
--[[pod_type="gfx"]]unpod("b64:bHo0ACkAAAAqAAAA8QpweHUAQyAJCQQPHTABIA4gIRAOEEEADgBhBwAADwCAMAEgAXAHAW4=")
Used by the Rotate/Scale tools, these operations are performed
relative to either the current layer's centroid or the grid origin.

:: help/usage.txt
--[[pod_format="raw",created="2024-04-13 09:44:45",modified="2024-04-16 11:42:00",revision=146]]
To use .vgfx artwork in your projects, include vgfx.lua and load
the file using:

`load_vgfx("path_to_file")

You can then use the sprv() function to draw your artwork.
The parameters to pass are:

`sprv(sprite_index, x, y, rotation, scale, color)

(only the first three parameters are required).


--[[pod_type="gfx"]]unpod("b64:bHo0AEEAAABAAAAA8QFweHUAQyAKCgQIDxgCDxVQBgDwHFEAAg4BRxEOAWcBABEsBw8OBwEAAScMJwEAAQcNBywRAAFnAQARVwEQYQA=")
Alternatively, use the "Copy Sprite Lua" button to copy some lua
code that will generate a vector sprite that can be passed to
sprv() in place of a sprite index.

:: help/vsprites.txt
--[[pod_format="raw",created="2024-04-13 09:44:45",modified="2024-04-14 17:14:44",revision=127]]
--[[pod_type="gfx"]]unpod("b64:bHo0ABUDAAAIBAAA8SJweHUAQyCMOAT1-5f-IAH3Av5NfTVuKG4H-gAH-hAI-gOfFc4vGe4dNh01LgQeFw4IGgDwP84PEh8QDmgOGA5IPgjeHxUeLB4Mni8ZKSu_DVYNNR4PFBQOBwsCBRhOB34BDgcuDxgOB74BHxABDigsXjguOC4fGwFeHB5PEgyOC4kLrjQAsC4UDgsCDxQJCghOMADxDx4DAi4CLgIHDgmOEQ8QAQAOKAwOHF4oLjgeLxsRTjsA8A1_C5kLrg1fBg01LiQOGA8TKD4HAQ4DHgIeAw4DCADxEAcOCW4PEgccAQABDhgMHggeDA4ILhheDxsBNgEAAT5EAJJuCykeGR4pC55IAAC4AIAIBQEoPgcOAkUA0A4TAg4DAQ4DDgdOBwwCAPEFDx4HAAEeKAwOCB4MGC4YPjYBZi5JACFeCUoAMTkLjkoA8U4_FA8UGAUADwYICi4XAh4BHhMOBy4BDgc_MQ8eFwEHAQ4BDigMLgxOKB4BLxsAFg8LJgkACQEeHB4fEh4LDF4PCQ8ZLwkeHR4tHxmODw1aBDU_PwQPAg4ADxMIDS4-ABAHnwDwFyc_By4sDx4sBwwHHAEOGB4MHgw_KB4RABYBABYJBgkRAC4cHgsuUQDwGRntjgRaBDVeDxQPBA4PAg4PEwABLgcODwIeJw4HHgI_By4PGhEXAAECAPIDDgEOSBw_OC4RAEYhAE4cHg8eQwAh3g1EAECOHwQBPQDDHgcOBz4CAQI_B14QOAAQHjgAID4AfgBhAAEAbhxeOABCDr8UDjsAUJ4fBBEuQAIiXiBoAPILAR5ITjhOARAJAQCOHC4HLgxeDQ8UDpMOHxkwAFEPBAMAATIAM04LEDMA9AYuSO4RAAGeHD4LHQxeDQMOkw4NDxlfABMYLQADyAD0BgEOAf4HAb4cPg0bDG4PGQ0Ogw4CnloAAiwAIf4kHgBxfhIeQx4CrhwAFRYaAJJuDJ4CDU4NAr4YACMOCBkAYJyuEi0SzhUAEf4zAwEKAB9wBgAGPwo0Cg4AAQ8GAGN2FDoUNf5wdAQAUHB09f_X")
Each Vector Sprite is a different vector image with its own set of
layers.

The number of VSprites in a .vgfx file is not limited, simply
select the sprite index you want to edit and start working on it.

To delete a sprite, remove all of its layers.
:: help/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEzIDA5OjQ0OjMyIixtb2RpZmllZD0iMjAyNC0x
Mi0xMSAxNTo1Njo1MyIsc3RvcmVkPSIyMDI0LTA0LTEzIDA5OjQ0OjMyIl1d
:: vgfx/
:: vgfx/0.vgfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTAyIDExOjIyOjQ5Iixtb2RpZmllZD0iMjAyNC0w
NS0wMSAwOTo0Njo0MiIscmV2aXNpb249NzA3N11dbHo0AJpQAABr0gAAsHt7e2NvbF9hPTEsCADw
NGI9MixmaWxsPTQyNDA1LG5hbWU9IkJhY2sgV2luZyIsb3V0bGluZT0tMSxwb2ludHM9e3stMzMu
NSwtMTZ9LHstMzAMACA0MAwAIDIxDAARNQwAEDgLAPMfM30sezM5LjUsMjJ9LHs1NS41LDk1fX0s
c2hvdz10cnVlLHR5cGU9ImVhciJ9LJkAEziZAB84mQAAP29keZQABPENOC42ODYwMzQzODkzNzQs
LTEwNy4xOTA0OTM3NX4A4DEyLjM5MjAxMzg2NjAzwADyDDAxLjU2OTY4MDg4NDA5fSx7MjIuOTMx
MDM3OUQA4DgyLjU5OTQzNzQ1NDIy7wCRNDYuNCwtNjQu0ADwGjkuOSwtMjMuN30sezY1Ljc4OTcz
NjExMzA3MiwxNS4wNjIxODYxMjkxIQAQNzUBIDE2HQEgNjYLACA1OB4BgjYuOCwzMC4zogBBMiwy
MU8AETEuABEzYgEACgAQMQoAITI2eAEBFgAnMjR4AQFtASM1NhgA8A44NDU4NzEzODUxODgsLTY4
LjU0NzQwNTI4Mzk1NCQAoTQzLjgsLTg0LjkOAIE2LjIsLTk3LmQAMTMzLj4BPzUuMakBDS8yNEMC
B79OZWNrIFNoYWRvd7EBA4AyLjYsLTc3LrUAITIzDQAyMy42OgJRMSwtNjJjATAtMjAbACEzNRUB
MC0xORwAIzQ5HAABqwBDNTQuNn0CETbuAB8yuAApL0JhuAANEDT1ASE2NpEAITM4ggACDQAgNTkN
ACExNw0AETScAE82My4y7wIVLjI1jgBPSGVhZIcAA4AxMCwtODMuNWsAAK8BETALADAtMTgNABM0
DQARMmIBHzWCAClfQ2hlc3SDAANkLTE5LC0zeQASLHUAUjIxLC04EwBfMywtNTN_AA8jMTV-AB83
AAEDXyBMaWdogwAFIDMwZwEiOTK8AiExNQ4AAxECEDYiAQQVARI3MgIiOS7XAw-cAg4TN5UALjEw
lgA-RXlljwAEIDIwWQMjOTGgApMxLjMsLTg4LjTKAgB8AAGbAEYxNy42gQMgMTTWAiE4NgUEES36
A1MtODkuNhwAETlSABM4OAARNe8AHzbAAA0TMMAAD78AAF9QdXBpbMEABCExOJkAEzlvAEE5LjA1
wgAiNTVJAcAuMzY4MzU1NjY4NTgpAOM3LjMzMzk0MjkwNDAyNKMAETLNACM4NZMBETkoABQ0oQEC
UQAC_QDhNi4yNDYxODUwNDg5NjN5AMM5ODY2NTYxNzg1NTJQAADUAR8wSQIPLzIx9AAHn0JlYWtE
YXJrQvgABgcjAhE3RwQRN8QCAX8BEjegBQAcBRE5twEBbgISMtsAHzFNAg8TNpkAHzaZAAMPlAAE
ACoBIjc1sAUyLC02kAATOVcEEjWeADUsLTYKABI3lgAUOTYAJDMyAQMgNDFCAQ9AARYfNUABBx9B
rAAEAFAHAAIHBZYAEjkkASAzMrAASzU5LjO_AA8VBA0EMwEUMRYEQzM2OTCNAIZGZWF0aGVyNowA
CIsAAYQIIjM3zwciNSx8BzAwLDiQABA2NQcACQAQNegCITE3hwICVQMQM6IAETVIBx83ngAOBR4E
HzGeAAYfNSoBAxE2wQYCsAQQMg0AMjIuOTwGYjEsMzEuOaUAIjYsmwABLgAvNTZiAg8fM5EADx80
kQADETH0ACIyORUBSTUsMjMoAQ8RARMsMjYvBTszMTeAAB8zgAADArcHEjIwAiA1NZcBEjD8AAAV
CAILACExMQgBD7cFEBQx_AQfOYgABh8yiAADEDXzABI0eAAAZQkACgAB2woQMmMJETULAAFMAhEx
hQkvNDhWBx1LMzQ4NYsAHzGLAAQBEwEhMTETARE2-ABEMTUuNicCAPgIABoAAycAETgNACAyMBoA
LzQ0GgYPFDIjAR805wMAX3JhbmNolgADEDIzAwAQBQL4CEI2LDYzDAARNLQBETUNABA02QYiMTa3
AQG8CSMxNcQBAPEJIjk5DAAA2wESNeMCACQAITQ2CwAgLTfABxMxHAYRMTsEITg13wAhLTkOABI5
7QASLYcLAyIBAbQGEDJTBg-6AAwE9wkvMzH6AAVvIEhpZ2hscAgIIDEwaQUDrwAQOUULAsYAMS04
MO4IAQwAQjY2LC3pADEtMjhHA0MtMSwz9AMQNO4AAQoAMjMsOfYCZDMzLDE2NBUAIjE1igtSMTcs
MTArAGIxNSw1MC7fBSM2LPIBUy03NiwxHQERNwcLHzkVCBUfMgEBAF9UYWxvbvYAA-AANS45OTk4
NTYyMzU2MDQsAQORMDAxMjM5ODk0gADyDzEuNjAwMTc4MjQ4NzkyLDE0LjI1MDI0MDQ3MzMxNdQL
EDAiAGE5MDE0MzghAJEwMDMzODU2NDh6DeEtNS44Njc2MzY4MDkwNuQAoTAyMDM1MTgyMTjPBvEN
My4wMzI0OTcwOTM3MTUsMTkuNTc4NDMyODU3MWsI0DAuOTM0NTY0MTQ2MzjIBNIuMDEzMzUzMTM5
ODg3jwLwADQ0MDIwMjE2ODAzNCwyOTMOgjQzOTc4NDY0iQEA2gCgMjcwMDU1ODM2LMULYDk5NzAy
NBEOBCIOsDk5OTcxMTg0NTY5ZgAAHAF-NjM0MzMwMXwDBjx9LHtlBw_pBQBvQnViYmxlfgwKNDEy
MqkI8QA5NS43OTc0NjY4MTc1Myw9A5EzODg1NzQzODOqBDAtMTW1BBIwVgoxMSwy1QlROTAsNDUT
AGMwMiwxMDCJCfELNjIzNjYwMTY0NjIyLDYwLjgxMzc0MDA1NzNECDE2NiwECgFIABEzlAJfOCwt
MjVICxUP3QsAAu8ABugAFzDnABAwxggArwARMagPAq8AACULAq8AQTU0LC2GAGItMTMyLDHYAEIz
LDM4KQAiNSxnC1EyNyw0OckFAvMAEDFfAwDkBRAxUgkfMjADBw_tARA-VyBzqAEIcDMwLjE0NDIB
EEExOTQxQwqwMjQ1NjE0NDE0MDmoAGA0NC4yNjKNAiA5NjYD8gEtNDEuMzk1MTkyNjYwNzA1VBDw
ATI0NTMxMjU0ODY0MiwtNTUXAzA2MzCHCxA0ygDwADcxLjY5NzIxOTIyMjExNPoIsC4zMDUyMzE5
OTMyOQHQOTguMzc2Mjk0ODg2NUQB0TcxLjI2NDk1MDcyODc-CvIAMTQxLjc5MjIwNzkxODUx4RBQ
MjYzNjH7AgFpAfEANjkuNjA1MTU1ODc2Nzg3pQcwMTE18ANCMzc5N48GwTQ1Mjg5OTA4MTA4Mp8F
oTg3ODgwNTEzMzI9AgAuA5AzNDQwODg3NThIBJIwOTM2OTQ2NDLTAsAxMC41Nzk5NTg0NjDTAiA2
MCMBIDYwUgA-MTgzrwFHAfAQkjY5NjcyNTUwOAEBsjA0MjE3MTI0MTI54gXhNy4zNTk4MDQ3NjEy
NDJqAaIyMjcyNzE2MTE1cwtwNjguMzQ2NwUBQjA2NzITBlAyMzkxNaUBAiQAAA0LMDA2MEQNAF8A
AUgAgDEzNTA3MzA4XgEAJACAMzcuNTU3OTbtBDE4NjTdAyAwMdQBMTIyOc0EkDYuOTE5Njk1MF8B
EDIqDNE0LjMwMDYxMTY0MTkwHAPBNTQuMzY3OTQ0ODA2uQWAMS40MjU5OTKUEiM2MnIHAMoNcDU2
NTU1OTZhAyAuN_YFEDETBRE0YgLwAC05OS4zMjAwMTU5MTQ4N-MEcDI3Mjg2MzkKDhE3uAHANDQu
OTk4MDk3MTQ3dBKgNDguMTExODkwMTMAHzErCRYfNLkBAA8hBAJBMjcsLSsBUDM5LC00hQAQNbYN
ETK8CjAsLTQAASM5MQoNEDH3D0A4MTI20AQiNDieDJI0MTk4OTU4NzgiBDAyLjeGDvEIODg2MDIy
MiwwLjMxNjYzODE2MjY2MTn6EwMLCkQyMSw2XhEvNjTbAD8BjAKhNDExNDU1NDM3Oa4AEDA4BVUz
NDk3OIwC8Qw3MzgxMDM4ODAwMDcsLTQ1LjE4MzM3ODg5NDe2AYA3MC45NDg0MYsCEDDGD_E2MS4w
ODkzOTUyOTY4NMMAIDYypwFwNzQ0MTIxMEEB4zQ2LjA2NzA0NjQ3MjYzfA7RLjU1NDcyNDk4NTI2
N-EOEDQcBmI5NTg4NDJoBTEuOTA8BlEwMjEwNmERYDI5NzQxN0QBAYUEALoEsDkyNjA3MTA3NTc5
vQniLjg4MzY2NzU3Nzg5NDjRCAA4CGE0MjUzNjeAFSAzNBAEAMQCQTYwMDCxAuA5Ni41NzQ3Nzk2
NTg5NYcEETSSBGI1MTI2MzKNAtEwLjc1ODE1ODU1MzY5hAOAMTM2Mzg3MDlOAA9GBCkfT50HCgGt
ERA30AVhMTA4NjU4swwgMjCDA0EzMDIy8BVgMS43NTU5aQUyMTQ1Cw6zNzk0NTkyMDQwOTS2DqA2
NzE5MTI5MzY1TQMACQsAjAJSNDc1NDQAAsAwLjMzNTY5MjU5MTA4EdE2LjE5MTU4MzI0Njk1OAcg
LTEcDBI1hxIiLC0TAD8xLDE_ABMPhAAQEDFwBIA1NTEwOTI2NcIKQDUuNzc8A1EwMjk0MxcCQTku
NzTdASA1Ms8B8wAzOC43Nzc4Mjc1NTcwODYREGAwMzAzMDESBhI2tQlAOTA4MskCIjIzxQQQM4sA
cDUwNTQwNTGiBMI1LjE0NTc4Mjk5NTcaCFA0MC4wN6wGQDEzODghCVEzMi4zMyECXzI4Mzc4pAMp
H0_kAwThNy4wNDQ2OTc2NDg0MjPyBGA3MTgwNDmfBy8xORYDAQCYArE2NTA0MTAwNTI2NkQBBKQB
ANYTA4kJYDE2MTAzMAIIITI47A3DOTc1MzU3MDI1MjY1BhgISAAAtAXSOTUzMDA4MjAxMDUzMSIJ
YC4yNzczNr8HcDYzMywyLjWZBiAwM6sGJzkycwAFhAAQN0kI8AA5OTQ1MzI2MzEyLDguNzJQGXEz
NTY4NDI3VgAwMi42GARwOTc1ODk0OXUNCK4AA7oGAD4BcDUxOTQwMDBvCQkGAQAjABA0GAJhMDM5
ODAz5gcPvwAA0DM4LjI1MjcxOTUxNzhnDQAbEVAyODM2NZcIHzHSASoPvAMEBYIBAEgPAtEXJTku
yQ0FJgESMY0PAokBAYAPPzQuNFMEKX9FeGNsYWlt9gsLwDU4Ljg0ODM0Mjg3OM8D0Tc5LjI4Njgx
MjU4MjL4E-ADMTE1LjEwNjA2NDc3ODYzLDku0QMAHgAA9wEAmwGBOTUuODI2OTchCKA1OSw0LjY0
MjU4tAcRMY4D8gAxMDguOTIxNTI2MDY3NjdoFjAzOTP9DE8xMTI35gApEFDLAA-kAAohNzdmCCAw
N6UbIDc4ahAwODk4pgQxNzIxXAIQODkJAHsCIDMzmQnhLDEzLjQ0NjU1MjA5NjalDBExcwqQNTUx
ODUyNTA5JQ4gOTT3BSA1MVMGASIA0TIuMjcxMjg0MjEyMTHiDb81MTEyNTUxNjQzM1gCKQPJAQ8w
BALxADE1Mi42MTk0NzczMDczOFsBUTAxNzc2qgshNjSaAHA0LjYyMTc33gRwOSwxLjY1MYwOQTMz
NjiICSE5OY0cAAEDAdcGDkEHNzExMxcIAjoNCBEAD94AKQHBAQ-cAAIwODMunwswMTczWQEAzBwg
Mjh0AkE3ODMykxwgOTRmCPMKNjAwOTA3NTM3LDcuNTYzOTQxNDQ5NTQ1ObgBEDYQCyA0MhgAECxu
BiAzMOIFMzY1OB4BIDEuRwT-CDE3ODgwOTEsMzYuMjgxNjA3NzQxMDgxeA8PIzEy3QAeMfUbDxME
BUEzNCwxSgoATQcBQBYhMjBCBxA22wcBuQARM4cSETevEQAnBxI0JgARNC4UIjQyKAQDzB0fOfcW
GR82pgAWUjI2LDE0FgoSLOgQIDgsBwAgNzb7CACaABE0jQ0CKxMAsgQB2QkTMtMUITM2pQAgMjTX
FC8xNC8cEB8xpAAeAlsAAjYFAL4G8QwzNTA1MjcyMTgzMiw5NC40MzUzMzUwMTYxNjNeAUAuNzAy
MglQMjczNTK3DBA3FQhiMDgwNjE50QtQMi4zNDE0CQAJCAESHnAxNDk3MjA5zR8BmgEgOTR_DhEw
UgIAqRwAECAgMDh8CTI0MjkfGCI0OAIBAsMcMTI1NJYfHzECARcfMAEBFRs49QAAEAQH9gAB0wAJ
9gA9LDY59QAaOPUAYDguODUwMlMTEjndAQDBAAnzACw0OfIALjU05QEPAB0fD-4KBoAyLjcxNTUw
MhMQAJgI0jcuODk5ODQ5MDI0NzGdCwDaB6EwNzQxNjU2NjczoB4AoARwMjM5NTA5OccAAjgDgDAw
ODMxNDkxRQ_QNjcuOTM1NDY5ghQCXAkApwGyOTQ2MzQ0MzI2NjmxD5M3MTM5NjE5MTC0AwCXFEE2
NTI3bwsBRwAQN_MQYjg4NzcyNkcAUDY1LjY4lwEQMHccD48AAwDOFpI2MjUxNTY2OTHXABEyIBRB
Nzg1OZ4EDo8A-wA5MS41NDkyNTE3MTA5NTJTAxYPbQEVoDEwMi42NDcxNjn8BvEDNCwtMC43MDU2
NzQyNTc0MTMzlgDQNjguOTYzMjc4MTQwMlMaQDA3NzndDRAxTgoAIgBTOTEsMjQ9ExE0oQFTNzgs
NTBmCjA2NzOVDGA2NzM5NyzTDyAzMk0HAAYBETXnBCA4LpsSAGEAMTc0MU8bITU4UA4-NzYy9AAP
Hzj1AB0Aew7wAjkyNzA4MTEzNDA2MiwzNy45pwxRMzk2MjglAwEUIRA5uREgNTVyBgA4F3A4NjQ4
Mzcziw4RNuwAIDIuJAEgMDFYDCA5NgQIkjYzMzQxODU0N5cMQDkxLjneFnEwNzA5NzYzKhYQMlsJ
AH4AHznaAA4uMjLwHQ-aAAuQOTguOTg5MTky7hERNogPETX8FkEzNDY4_h0QMcwIIDkz6QhBMTM1
NRYcIDk0XgIAegcBtQ0A3AggODlmCzE4MTQ4A8E0LjQxODI0MTg0NzkhCUA4OC42uw9yMjk2NDc0
N0YAkTYzNDY0Mzg3Mj4GEDguDwHPFiA2NkQJAFsQMTU3NO8RTzcwMjbxFSgP-AADAA0gcDY2ODY1
NTmHDgHlFDA2MTChATEwNzbTFTA4Ni7_CnE1NzA5OTY3fhswLjg3tgNBOTQyMyMAIDkz9Q9hODE4
NTU18QYhNTC4EAD8AEIyNzQ1AQtxMzE0MTUwOcEMATMZoTc5MDM5MzI4NDUcAgBnCABTF3E0Mjgy
MTY2rB5QMzU2MjBcBj8xMjTIAz-wBzIxLjIzNDUwNTY0NTQxLDMuNzExNDRFJiE2NToRADIFETXW
ExA3VBECAA8gODbZBVQ0NTQ3MyMAcTc3NDU3MTEOEgBVADA3MjmPJk8xMzc3giMPD7ACHQAxFgCb
BiA0M4UMITksrhsQNvATUTY4NTA3SwHgNTEuMzgxODQ0ODI1NzcjAKUzLjM5MTcwNDc02gAgODCf
ChA3mREBJBehNjUwNzA0OTg4NKomMDEyNyQWMDAwMyUAALMBgDguMDQ2ODU3DRojMTGzAQAZFRA2
PBUhODLvERAwcgBvMTg0MDUwewVAUDM5LjcyuRpSMDc4MTX8ADA1MznrFwA7BgP8AEA0NTE5mxky
MDAy-ABANTQ1NuwiIjMxlAkA0RUxNzYy7BcAIgAgMC6uAUE2MzQwVRUAEAxgNTU3NTA1ZhEC4Ruj
MjgzMTIyMzIzNxULADEBkTQ0OTM2Mzk1NzoDQDI5MTO9Bj83NTf7AEBANDMuMToEITQwmgkBayZA
MDI4NwQkITY3twAgMjlEKQE6GBI2uCIA_RMQM5MFITI3EAwAQQEwODAxcxZBMzk0N-gBYDE4MDY5
NrsDITg4HwGAMC4zNzgwMzLGGBEy3hZQNjQzNjNpFxI31gogMzZsF4I5Mzc2OTkwMSMAACsYUTU0
MjA44woAlxYArhBQMzUyMzZqEBA5eQBjNTUxMjgz8hsQMdcGAJYUIDY5-xgBIwAhMzVQGUQ1OTUw
IwBgNTU1NDAwYgoBVg0wMi44TSlvMDk0NTA0DgY-EDH0JAAUAxA4YhcBnCJwLjU3NjYyOGMSAY8Z
ACEBojAxOTI4NzQ2NDldEnAyNDQ1NzcwBQATM4UCEDBcGlA1NzU5N2sU4zcuODg5NjA4MzA4MTg5
RAEQN24ZIDg4TxoBJBbDODQwMTEwNDMwNjc1FRAwMjY4eAAhMjH4DEA1Ljk0HAYAFisQOYcCQDk2
LjeFCgB2AxE1fhcQOCoZEDbeDk8xNDgzMgY_EDGvHJI0ODgwNzA2NTZEFVA1ODY2NmgUIzc1LgcA
2haANjE1NjczMyxREgC0AoI2MTUzMzAzOQwcEC5xAgDAGjE1OTlGABAzdBlSMTA0MjjeDQAaCGA1
MTQ1MDebBwJ3BkA1MDIzEQkiNzeDA0A2Ljg58xRCNDE4N1EHAIADAP4WIzQ0VxEAeQwgNDJtFTE1
MDTJAwAnCQDUFxM1PA6QMDEuMjI4ODg3xRsCThQQMowbMDAyNnIJD0IBPgFfK3AxNjM1MTM1MxoA
SBcRMtonUjg1ODkxVhUAgx_gNjM5MTQzNDUyMe0TYDQzNTQ5Nw0DAT8CQC0yNy4hChE1lwQgNzi8
LBA46QNxODg1OTk5NrYfAJAEUDU2MDgy2SdQLDUuNzBvLRA13gYTNI4WEDQeBEA1MzIxswYAOA8g
LjUGDUE5MzAyyAMABRVgODg1Mzc48QcBux0A2wKjMDI3MjQ2MjQyMlYUETk8IGE5MTIyNDhHABE3
cB0A4AEB8wHBLTU3LjcwNDA1NDc5ERtQLTEuMjRpKBA1SAsBcx0AHh0hMDE1ABAyTy4QLOQKMDM4
M-UbAAgVD4sBQDA2LjS-BVEyNDY4MqUbkjczOTU0NzAyMTkuAEYYgDM2NDUzMzM0IwkwLDI3mwsw
NTc1HSEC0i2gODAuMDM4NzMwNkwIEDdLJjAxNTcdBjI3MDSaFaA4OS4xODc4NjA3JhQQNGwXITky
1CEmNTEOHBA0LgUATwYwMzgxjAAQNYkpEDWFHi80MfwAFS8xNf0AFgDHLAGSHwGuKAFgGxQ5QzAA
mAISLaYFIzE4oSc-MSw0bSkOD4YAIGAuNTYxMzTIFgDSERE0wxJANTE3NT8bEzRxECA4MZETABkC
UDQsMi40SxcgODU-AwH_HgDNCDAyODgyHCA2MigFIjExHh4QMqMULzExtAUUAEQNcTQwMzI2MTGk
MBAzYAcwMTI3nAMROaINMDAuNnkdMDIxNWUT0DA5LDMuMjY5MDY0MzHOAR83jwY-AAsOcDgzMDk5
OTVNHEA4LDI0cAUgMzIuHzQ5MTVwGFA2MjE0OI8DMDgyLEEaQDIyNTHVIzM5NDkGEzE4ODDaAEA2
MDk5RgBwNDE0Mjc0MvoCFDgjACA2MYICUDQ0ODE5NCVQMDc5NzU5FRM29zBQNi4xMDJUABAzUBUA
JxYgNzP2BUE3MzI2QBsAmCswNDQ5HANQMzkyMzVGACA4MJsAMzYwNq8PAOccIDI4JQAQN34JAIAx
IDgzPB0SOVILANAAQDk5MTjBHBAydhoQMnYLAI8WAY8RFTGHGWA3MzEyMzRiEACWA2AzODgxNDWa
BgFxDACYMTAzNzGtC-ACNDI4ODcsNDQuODg4NDQzNDCJDy99LHsCDQ-wAREC8gAAmAAAhwUQNfIA
AEYCcDk1NTU3NzcBBw8TAkEAYgAAyQsACBEQM8QJAAEgIDg2IgEUMvEBEDCsCyEwNaMlEjCSBaMy
NTE0MzExNDEwgRGRLjk2OTE4MTg2PhEQLFQZMTIxMZYHIjY0Fx4ABh5wODc1MTU0Nd4MAOQXABwB
bzQyMzExM5EFPzE4NS4ZHUA3MjQ18gghNS4EAmEzNjc2MTGFAgCXJ2EzODY5NjP_HJAsMC43ODU2
MTa4GCI5NtIHEDkmIZE3ODg1MjgxMjcONEAzMjI42AESOPwbQDA0LjaQCQBiJiExNfgzAKMIUTAx
OTk36gMAfjRwODEwOTYwOQsLAIEHEDnkNDMyMTM0FDAuNjdiIQAbCiA2NWAdAMwSXzQyNTAw9g0S
DxoBHgCFCwDbG3A3MDU5NTUsBgEgNDb7CFMzMDc4N9UAUDUwODY5YxKgNjMsMC44ODQxOKERMzg4
OY4WARMjgDA1OTk2MjQz6SwAbgEQM_gnETkYDgBlMGA2MzcxOTNPHRExChpQNDk2NjJTDC8zNNYM
PgFgByAyOMMAQjc2OTe8BRA2rSUQMzsTFDkHISA2NQcIQDQ4NTZOC9E4LjUwOTMzMjE5NjU0Py0A
xSwANwAQMLQYIDkw3RQwLjcw1QAAIwQDlhQAywgAYCOANzQwMTMyNiyCISA0NS8LAxcmgC0zNi4x
NzQz9iAxMjAzhQdANjE1MA0aQzUzNTQRCCAyNhwCADASQDk2LDMFIRAw2gggNjagEgJmJBA4shQQ
Nc8HAMoQUDAuNTEyvRMAfgk-NzU5RwcVLzI0SAEVMDc1LrEkAKMIAPMEECyOFjA3MjDZEUIzNjEy
yBFBNzkxNBwOIDg5HwIQMtsfIDcytgIjNjkjAAHoFXE0MDU4NDQ3ix0BGxNROTk3MjaHHhA33B5B
NDUwMZYMANkMIC4yFBd-OTMwNzA4NSACFQPtBAD6AR8w2AANETJUE3A0MjE0OTQsrg4AeAMgMzJJ
JQG6JhA4IxYgODnbJyAzMdchMDEuNNMgETlSDCI2MyMAEDc3ADA1MjfuMgDIEQHBEQADBwA2BADZ
AAE-IiA5N9oaMTQwNNkAAD8CAMUJAOYVD9oAHT8zODKyAQsgOTHsChA2UhQgOTBkECAxLkoRMDgz
OQ8kAiMOAEwSEDbJBzE2MzEjABAyJR4AEBcAihgTMiMAcDkwNTYwNjD_BwAnLwDqBwASDQB5FhE5
iyUgLje5FGA0NjMwNjhoFzEuMTVeDACbGC8xN9oAFR8yvRsWAGAZMDQ4N-IlMDUzOBAfEDP7EzAx
MzcPDBE2-xkhLjV-CBA5_CUCigMQMygpMjM3M6ESQDI1LjaoB1AzOTY3M6URQTIuNzivAxAxKyEB
RQAwLjUxZiQAmSUwMjYz9AIgMTS-CACxKC85NNgAPwB8BlA1ODUyMZEUEDgLDUA2LjUxmSNjMDcw
OTgxRQoQM3AdIDU4hCUBXTEhOTbICzEzNTANDAAuIGE3NDg5Mjn-ARAsYTlAMDEwMYUkITM4rCkA
aQBQMTg5MjLtKCE3NVUjAJgCAGAaTzU0MTNzHQ8PyDsIH2JaPAUQMUokAYkNYjEyNiw2OcgQAJIF
Ai8IALcVABAsD-42J29kYW5jZXJ-AAMQMu4VEDh7FjE4MTPDKiAzLqoEIDA1swQUNZg7MjQ5MTYC
EjO6MlA1ODM0N6UjAp8FEDM6GQCYKTExNzjhKRA0XCoAHCRBOTY4MtY2ACYjYTcwNjg0N1sIAWgW
EDk5AkIzMTUzHCQB7gchMzDdLTI2OTR4JwD5K1EyNzU0MiEIEDTQLhA5cCQwMjMy2h0hOTKhBzAw
MDCMCRE2MgEgNC5lAEAwMDQ13ioBQzEgOTRMByAzNUYCA9c2MDM5M7Y8ADgVJDksABkQNv0QMzgy
N2QlQDM5OTYYEjI2MTYCOwDWI2EyMzkwNTNdGABFAjA0OTVjGwCTIAA_FyEyLp4qITU5jDwDzQkA
8CYwNzQzaQIRN5YSEDBhIhA3-BQTM0cHAEoWMTM5M4cvAdYyEDLBAgCqBRExdxEOswAwMzMuwxsw
NDU0rw4TOX4LETRUEQC0DQG-AxA3ByoQNS8oAEQVDyQAAwBCIhA2BSwA3AkRNSQAAM0FAJUoEDL4
LxE1AwUAIiNSMzc5MzQXMCAtM8QYIDY5AwAA7QgBlzOSMzczMzQwMTkwUwwAXxMACAAkNzOULwF-
KTA5MjgpKTEzNzgaEiAxMBsRMTk3NlgGAHcIMDkwMgYKUTg2MzY0LBUAYydDMjU0MGsKAC0aQDcw
NTO5JTEyNTKgHKIwMzU0MzE0MjY1MQgSNpU5IjQuDgAxOS4y6xwTMvEQUTIyNzUybRkARgJgNzMu
NzIzXwFUMjk4MTMZEBAz8QYACxQRMocXEDP5EQBbLCQ5NSYsYDI1Mjg2NBMcQDQ3LDa1CQDZDQB4
Jg9IAQJgMTkuNDYwPRZBNDczN8sAAOclAQspEDAzGBA0WwMBURwxNjEwlQQBGS0QOU4MIDczjA8Q
LOwEUDU0OTU3xSMQOIkAMjQ1LGgmALIJETf3KQDULoA0LDcyLjcwOaUUUzM0MzQzzT8QNzIbAF0e
EDeYMwAlBQBGDRI0aCsAsUAgODcyJ0E0NzE3xgtAMjU3MFsYEjMaIgAfFQDXBjE3NjdcLwL_IhAx
AQAyOTM5OTEQLqAkYTYxNzA3N_Q6IDQurwMAyjIhMDPzCQBhFkA4MDgyuxsAXC8A4gRRLjA0ODH3
GAEVAxAzGg8QN5AMEDRXGAGvPwH6FxA1pQ4B3hIgMzEXKII2MTYwODk4NVA8AJsOUTc4NDI1pg9B
MzUuOZsLQTU5NDAjACAwLlUaAKFAAG4zAiMAIDI2FS0AcAoAihwAIS4wMjUyMQARMdAAEDV6I0A3
NzkxmDAvMTaSAgEAeiIB5hgRMzYqIDI0QAcB2hMQMOcjnzM3MDc2NjMwMbsNKD9pcG8ZPwQA0AIR
OC4FEjbsAgHqAgL4AgK_LAFKPQHsLhI0DAAASTcBZA0QNGYaEjMhPgDxEBA2QwkvODGJAxUgNTYR
PCM2N4ALAfYLAEwCMjI0MQwFAKALAH8tETaFBwBLFyAxMZkxIDMzsQUBPRZwMjA3NTUzN0sSEje7
OxEuByYAjR0xMjA4FDEgNDEDHhAy-wQFLikwOTc3EQ8A50EBdBlQNDE3Njk_AhE0WwohLTVaHII2
ODExNjI5MeM9AKYhMjU3NkEoAC4gAt0gD_MdKV9lYXJidbNACBI1EyUAE0QCpS8gMTMkPwAsHA92
AChfY2FibGWbPAQDawAB6gEArwcSMbopETW2DSA1MjgRAIsTIC4zHhIQOPYhETR4EQDgLy8xMCkj
AgBkAA_YABcfQvgVBQE8QkM4Ni40-C4AMCcQODwtEDHqHCA5M7IKEDH-J0MyOTA1ujUSLd4NUDk3
Ljg1vSAxOTU3DSgOygMA6QcwNTUyag8AczQCXgYQOPcSQDY1NjABDgNENiA0OXENQjA1MjUICpI4
ODkxNzk3OTGENAANAzE0MzdvDgIcNDAuNDYxFzQyNjJQEzA3Ni6dMhE1mQouNTn8BQ1jAwDXAgAa
NHM0NDUyNTg35T4CNhMgMzUfAAELACAyMtcwEDG1DjExMTW0FpI2NjQ2NzQ4NTFTDgGsDwDdIUA2
MTIwkjcxMTAuwhZjNjc1NDg3iBIhMjeuOIA1MjQ5MSwwLlkxMTY2NQcIEzhzRAF3HgCWOBA3zxIA
mkCANzE0Mzk0Mzh6FA8FAgUHYSgEdxAUOX4NNTQxMFVEL3NlBgIDEDbHQxE15goArycC3Q8yLDEw
uQAgNDj5RQ8rPx4HggI-byBiM0cHAJUTAYkIAAkAAVISQS00NCxjN1IyMCw0OAgAAtIeQDMuNDKj
CUE4MjA2DBpANzI1ONsZIjQ2yRQAtSUBFzR_MTc5MzksNCIAKTc2IgAuMTNEADc5LjAiAB0wIQAp
MTVDAC0zMiIAGThCAC0yMyEAGjRDABEtESwBlRNfNDUzOTYkKx8GYT4fb2gBDVc0NCw2NFYBJS02
SzQTMlQuAMshEizWRwAFLQIVAAHPGgMTAwcsACQ2LLQBPy0zMicCKh9rJwIKETLvPgJ8ABEtuQAi
NTLBABA36CAwODg5ISMwOTM29xcQMxkYcjU0NDYwMzMiADI1LDZXPxgxKwAcMCoAAMRGBk0AEDQZ
FAshAEMxNiwwCAACfUoAdzYHlgIA-EgYN8wBAKkACbgCAHUFBe4BHzQgAABINzkuNyAAKjI3IAAs
MzNiADg5LjbXAACtDCExMT0WTzUzOTdPAikfa5ABAyMzNgI8QTMwLC0lCAHHKhU1ogEBrAEARgQY
NoABIzUxwjBBOTkuMHgOMDI4MJUJEDfFJwHnMzowNDZfAQCTGwNNAAB6Ow_EQhQkMjfxQCQwOGEC
FmnMACgxMNInFDATRyM4MPI7MS04OG4AAwoAJDYwHgAkNjIKAAGbAQKMPwcLABM2ITYENAAkOTZI
AAEfACU3OAsALzg2zAApH23MAAQkNzLMACQ2NAoAETUhCwTEAwIUACg0MAoAJDU0HgAGCgAkNzA8
ACQ1NFAAJDcwCgACFAAAbgAvNTTIACmvYXBvc3Ryb3BoZdEABQBFIRA1hAgwMjE0OxAwNy4z4DQA
NAkB4AsBdCMJIgAAIhgPIgAKLDgyIgArODFmADcyLjEiAA9nEgcO7BEPqBYWITgsiiwSOCEDRDgs
MTMNDwAMTQHeJgO9ABQyKgAPcjQMC3hED1YWEDEzLjADMhA52BARNLULMDM0NQ09UjA1ODgyohQK
IwAsNDAjACszMiMALDczIwAcNyMAKTEwJAAP2gA_ASwNIDk4ewpCMTcxOSQTC5UAAUckCCQAAMZN
AGcgAGwPEjHRPxs3IwAuMzkjAB8yagAKDxUHDgQDGw8rIBcQM4YnIDIwnwIhMDlHAgD2GCA2NK8C
ETYyFwAFLwBBUGIxOTkwMjDDRAYiAAH5AygyOSQAANwHDEUAAGYXITY5lQUxNTA5hQIQOZkSXjk5
NDgwpwgP2QAwKjc32QAsMji2AABnHgojAB0xIwAbNEYALTU2IwAqNzgjACo2OCMAD9oATQBfPSAz
ORlEMjkzM_skGjGTACg3MSEAFDQKBAciACo2NyIAD7QAPSo3NyECHTdqAQBbIFAxOTczM9g_Ejj6
AgD9LBA3yhMROfE3KjcwRQAZM0QAHzEWIBYPnRgLBzEGAv5OITg3WAVQNDIuOCxPBQP2FSAyLPkB
BEcCARYDHzjHFygPOAEDGjLzACw1OMkBKjE0FAEuODZ9Ag-tDwkbNUJHALkcHzgUAQkASkUyLDEx
MVQAACIiLDddBhAxhgYjNzQgAREurQABHwEBQU8UN-9SAA0AABcSAzAWAA41Lzgu7QsPBDoBD78z
FxE1_g8A_A8wMzkxeyQAtCwgNDEnDVI1NDY2OdMBAIBCETXXHAAiABAzfwUQNKwXAwpAAXs-AK0d
EDO3GAKxSVA2NDQzMEwrMjk2N6cUAKodgjk4Njc3MTcz_iwwODY3LBMhMDW8CgAHJDIxNDmWJyE0
OK0SEDWjMFE2OTUyNiIAGjLHAQB4IBkxQQUcM4YFLzc4hgUNEDgLLAkiADAxMy4TPTA5ODeHPBI5
IwAgNTnLKBAyGj8CgQdANTUzM9s4IDAx_RQAXwQA7zQB-RkTMvYBEDM7JiAyNmwTETK4UzAyMDNK
FjE2MDP-SCI0Ne41IDcz4igBlg5SMi4xNjODMgGINBA1mjQAVgAROA8fAscHAPAVAHE-AlUHADk3
AKUrAL80MjA0ODUGMDk5MUsyAI8qAlJGcDE1Mzc3MjlhLBI2IwAgNzDyAV83MzAzNJIDPgEtGUA3
Mzg2RCoB1R4Ax00RNdwCAKBXMTU0MDEXETLtCgUaAAEYI0AyMDE1WhsCIi4BGgAhMTHTRBEx_DYS
Nh1DLzE1tgA-AMsEAAIZIDM1oCMB6wYDgQAxMC45WjRBMzI3NhoAFjObAAArRACrGCA4OfwCIzM5
GgAAnE0QM6oFAKJDAdAtHzi1AEIxMS43DQIQOVQBAMZGIjIyggAApz8QM0FAIDk3SzEBKQ8BagEg
Ny5VMxA3BCoQN1YYFTRoAQAZICAzNGIzAaQ-AswAD1hXFh80MgYUES1DPyI2NnYAAM1DAhAIFTWK
PyM3MA4AETIOABM3DgA0Ny4xKgAPlQA-ETFsACQzNwwBAaUAFTQPAAGgWC8zOBEBQgEUFiIzNWsA
AXxUIzU08wAfMHcAFho5sgsPOgIQQjM4Ljl3GgOrGwHKGABbMwMDHQIgABQyEAARMyVVAP0aAjAA
ETQUASQxMdsDA6BPIzAyMAARNZlXARsFAhAAAc5PABcHA0AAEjFwABY5YAABJh0AgFYDQAgBYAAD
GQEAIAAAQAAmMjRgAAGgABMwUAAkNjSAAAIQAEE1MC45jQYDLwABWgEUOS4AETSeACA4OQ8AD1kH
MwfSAQGKACQ4NBkBAcgAFDAaBAEHWAB6WwRmAQNBBhc2agIQOQtAA-wcEjZBDw_nAEAhOC6hICAx
ODA3AQYeYDYuMjI2NygXEjRaHSExNd8mETjyJyEwNOoJMTU2MM1FIjAzXwkgNy4dNCA5NT0gAVAT
EDjvHxAzniJDMjk1MbkKALUmIDUyd08BoxEQLlw3AB9TRDcyMjh4IxAwbUsAHhshNSx_CwFgB2Iy
ODIzNThGCAChIBA1-jgB5CIAK02-MzY5NTQwNDUyMjeaAzQJJQMBFgQUObsBETUOABQyqwEBqlUT
OckEES3hUgFdCgAeADIyLjkGDh81lwBAEjFhAgOGBhEy6QITN5cAETFXAwCeGQ80BBYuMjG-GA8x
AgJHMzEuNT4JAKJdCmsLGjRfCQAAUwshAAD-HAchAB05IQA3OS40IQAAwDQLIQAaNCEAHDUhAAAA
CQchACw1MBAMAEI8D0IACxoxYwAdNkIAGjYIAR84Gg4aKzI45gc-MDAzqAMKAMRNIywt4AEAnQAR
LLUkAgdVEDRFAQENABA1FgIAJQMUNaZeAyYAAuwEEzFBAAD-IiMsLXEHAmpbALVVD6gCNQe4AAAu
L1A5NzI0N0Y9IjA50BgA1kgAs0ECwVMgMjT0NyA1MZQ1AZUdAG8GAFccMDA4MKAKAt8CAKdNEDGa
PD42NzdGAA_4AD4BokoQNFYzEDJhHAAQSABrPhA0MD5CNDA2NQICEDTuAXEwNTQyNTY4AClQMDI0
MzP_UALYMRAzHjsAVyYQOPBcHjRGAA-HFQ0eMbtWD7gADDg2LjO4AgEwJQt_Awn6AgDrYgxdAwnZ
Ag5CAD8xLjchAA0QMawwAFkAMDIxNzYcMDI4OIMlADYPHzb1AD8AYiQjLDN7XikyOAIBLDM24QAq
MjgCARw5wAAaM18EAEAfDkIAAJ4PHzPBAUAA9Q8ALTEALywwNTIz9RswNzI3dDASMxkyEDW9NkAy
MDExNkkBHjAwMDc38SMzNTE3AgQA5j9gNzQ1NTc2WTIAPwcAVC8hNjV0DgGIDSE0OOAoEDSTHyA3
LlIiIDA5nTIiMjXrIxA1kyQgNzM0JxAx-QQAmV8AfS0AdDAP9AANBWlaHzKFCBUA4wgXNGcTKy04
sxICKwoYNiMAAN4fCrYPAIAWGTAjADw2LjQjABo2IwAAyTgLaQAAcRUIIwAPPxMcGjaNLQ-8AA8Q
NC0xEDL0LwGPIQCUIqM5NjE1Mjc2NzQ1hFQAihghOTisKBExRS5BNy43ODAoEDeOKBM4RCcYNbgA
CBoRBNsAAMksBiMANjEuMNgCLzM52AFAKjI4TAEeOdgBKzMw2AE7NS4wtQEqMjdGAC0yMNgBAMgs
D0YADCozNGkAHzfYAUwsMzP8AB8y-AAAGjQjABw4IwAACRQHIwAYMM0EETPyEgDWAQnZAAoZAy8x
MYwIFgTZSQAERB8w2AENGjdzABoxcwACsQMIJAAsNDBGBQD3IQkiAB42IgAZNSIAHjNEABs1RAAd
MiIAKjY2RAAdOCIAKjQxThoYN3AaLzc4zQAAABQMDj0CDwcGOQCHBACjPyA5NH0oIjIxOiUgODaz
KwIpQgByIBA3ICsQNzkEIDc32gARNyVaFDkaAgDrBRA38E4QMCtBETWdIwDRIGYyNjI1MDOwKCA2
MK5IAQlYAJInEDneNgDkUiQyNGUPAE4jETk0PSExLF9YMTI3McMzLzky-ABALzYwOwINLzYy1QEN
Kjcy2QAtNDXZAAsaAi40N8MLD0sOPBo2RwIuMTHZAB8wWgMQCvQCANYLGzHtBDk1My64GikuM_oF
AlsDCNUbCTgDAiIAKTM1ZwAuMjmtABkxRAAvMzNBARobOQMNB3ZQDyoHBBo2swANGA4MMAQvMTgw
BA0AhyoPIgALAGQ7DtUAD_4COQCjKw9GAQgCZxMJIgAfMUsFDS4yMtcACuwcLjI0rAEPlRYjP3h2
aaIQBACyPBA2iUAQMXhAAccTADkwEDeRPQHxGQCpFgB0LxA4cRI_OTgxJAAPmBsDD5gALAABCwA4
KgCCOBEzQAOjOC4wMTgyNzYxNtpcAPgXMDM5MbgOEThoMgwkAA_ZAEEQLacDITI2RhMA1QUPmgAC
IDE5XD4gNzNIRANgSQ8zAU8AK1oB700BaRgvMznNAQIAbgMwNDE5ozkAsDwPNAFTADExQDEyMjhu
XzMwNjSZAGA5NjQ1OTk7TAKzEwDAXzA2MTEYOB8ymQBXIDIz7A8jNzMFMQ0yASA1LtccIDI2E2UC
7jYPmABQARgvDlgCAhcADksCDwMvJU9Cb3JkbzcFAMAbMTEzNl5iMywxM2khBwoABh4AAygAEDcW
GBM0RyIFCwAAAFEzMTQwCwAzMTM4IAAC8xwkNzMJABM5HAAkNzkwAARQAA-0CzwAzwAAWCwP2gAH
Ah8AD8YfDA-XAQhvVGhlVG93WQEFACcoAZpIACsdQTE4MDlrMQEWAAAnIlAzMjA4OHwdD1oCBQ_D
ADIfOYMAAR41FgAPgwBHLzE0gwABHzEGAVkfMQYBAg8FAVkfNQUBAh81BQFZAW0AEzOrLi8xMu4A
SR807gACHzTuADofRUJuBAB7cQPoAC8zOegALS9FMWUACA7iAB8zFgAGC-gAEyynAA8OAU4jNDYN
AS8zNgwBLR9XB04FD-QAAC8xNvMAABAyKgAAmFAhMzkPWRI3fnEPKgAAHjNUAA-FAUAvNDa6AAAf
MxUABQ2lAC40NsEBD6UAPy81MXsAAC81MaUAAABaZgBoQRA1kTghMjaVOxA39D0Ag0AvNjciAAEA
7kYQOOlKUzkzMzczWQASMk0AD90AOR9PKAQFD8cAAQ8UAAMNBAEvLTSiABR-X2Nsb3NlZK0uFC9C
R6wAAwAyJgKKD0M3NCw2pi4SLBYUAfgLLzM4SQgGD-1eEU9Td29yTDsFAPMREDJqVSA5Mm5JAAUP
AJp3YzEzMjEwMVshCyMAAMwUcDQ4NTgwNTiGJAMlNFAwMjQ4NJ5vETluS0E0ODk2AiAAV2IAIgAA
WgAQOf8KEDQQVS8wM9IARjA2OS5mAEA1OTA1PBkQLGZBMDcyMSlYIzI2JwkLIwAABigBNmkANGoS
MNUJKC430gABKCgAkE8AbT0iNDEiABg1IgA3OS43IQAfNbEBVhAtaUIQNNohADFYHzixAQEQLVde
EDUUahA4cycCMzACu38ACAAfN4sBVgBLJxA3Vz4AdBUvMziLAQEAXA4gNjieQAALKSI0MjwCMy0x
OQkALzIzWgFXAM5PADgnMDkxNgk_D1sBAgCPGABoTiE3N_xyBFsBFDYJAB85XQFXAKccAH4CIDM3
sFQfNF4BAgD1FQEXFQAvVxQ4pgAkNTIJAB82XgFXAK5BAIdIMDg0MaFWD14BAgDRXxExDlAAvVcT
OKYAFDYJAC83Ml4BVxA4a2EAPDxfMDQyNja8AgOjODQuMDUyMjkxNqFvIzczCTYBCQAfOV0BVwBj
JhA0eUYkNzaeUQ8kAAACLSN0NTYyNDU4NWoDJTAxCgAPxgQED5gHEhBzrwAAqgAPswADETcKKgDA
JxM20xwUNg8ADw0IAw91ADcA9ykGdAABDgAPcwBNGDRyAB80cQBNMzksMpKAACVWAg0AD3EASBEx
voQTLicqAgsAD28ATCYtMnAAAgwAD8IBTSg2OakCAQ4AD_QATSQ1NOIALzU0bQBOJDg3bQAfOO0K
BQ_oBBRfR3VhcmQAGQMBx0QQNs0iAGEWEjZuRwEfazI5NzjyGgwjAAGWSgDdQUM2MTU5IyEQMb9T
EDhVVACkQg8jABEMaQAPiAUCD_AALwDgGQFVdhE1tFMAbk8ArWgAmnQxOTAxwAYNJAAAAzoAglwB
9TEjNzdjNwBMezAwODlcRw8jABINagAP4gBEDJ8BAAonAMlrAPpfITU4xT8NJAAAxAcgMDH3RBAy
XlwPoAEBDyMAEA1qAA-EAVUBEUAgMTThCQBuSw-EAQEAxiQAyUlvMDI2NDQ2oQEADyMAEwxqAA-E
AVUAen4QMShREDChdB83xAEBAFAyEDmWC280ODkxMjiiAQAPJAAUDGwAD8YBVQCEXQDiYSA2Np5M
HznGAQIAn3sAKVMgOTXpYx4xpAEPJAAUDGwAD8gBVRA4anYAVXMB33MfMcgBAhE18yIAxU0AXEwe
M6QBDyQAFAxsAA9SBVUAni8AvAwAkkMvOTTHAQIQN84PIDYxxExOMTc1NaMBDyQAFAtrAA-GAVUB
mxswNzc4YFIRNmlnDiQAEDnhdxA3vzZeOTg1NzeiAQ8kABQMbAAPUVoVD3pfAV9GbG9vcuESBQBX
KgC8TkI0NDc0PxQQMHkyANlmETcfDQshACozOCEAAdZNITU4d3kyODE3IQByMjEzMDQ1OVRwDSIA
AFwuALt2ACMsHzUzhSofZbsBA1I3Myw2NooOA24DJzgxCgAvNjd1ACk-UmVjjXMDAe8KANoNIDM3
R14gOSzjVxA5klEA7Q0C6AEMIwACamghNjmbLiM2NXtBAW9dbzIzMDMzMiIAEAxnAA_5BQwPkAoI
H0yLCgYA3WgAdmkwNDc03jggODRwX2M0MzYwNzKlVAvlAQwiAA_5Cg4MwQIQNiqEA5gAj01hdHRy
ZXNzz00EAHVgAdwWYDE2OTQzMd6GIDU3Nn8yODEzPnkLvwBBNjcuNulZAe6BHzK-AAAPIgAPDGUA
D9I-KQTgAB9BWAIBD70ADwAAcQBseCAxOeeCECypOQCehRA3GygvNze8AAAOIgAPAAEMDzADKW9Q
aWxsb3cyAwNAODAuNt2AUTA1MTIyZkQBOG4AMlcCwlMAmAAQMxcqEDR2USA1NJkABn8EFDBhVRA2
KGYxMDE2f3kAgTgROEJeADFwEznSJwDHACA1OLtsETC9ARAx2C0Ak1kPW24RDl4FDyiSBQqmNRAw
8hMAYW0iMDUTPAAflFI2NjcxM54_EDWQNxAyB1AAZGcAECEQLt5fAMdfJDQwSjFQMTY4MjJ0XQCN
RCAwLp5mUDQzMjk1RSoD6okwMzUzugkA008A3VwQMn9SAK9gEjd1IQBlDQDWeAJ2PACSfg-QAR0H
GzVPSGFpcml5BDAuMjU0cQAvUxE3EykQNKkAABZYNDYxNDo4EDYlVRI2pnQAonxANTQyNq8XIjgz
LzUA7DMAYXAhMzmPIwD2bADIACAzMhAxAweWEDaTgW8xMjMwODdFAAAALzwRN4VkEzmfJQDcOgAR
XyA4Np1uAnw2IDg1vGQBP0wRNstbAKwAAByEMjA2Nyx3EDPAewDkeT8zNjUiAAAA1ZYwODUw1n0D
txMAlWEgOTCCWRA3W4kPVgIpP0FybVUCBQC-GRA2WGwB2hRAMS4wMbt6EjO8hgJmASAyMh1wEDdF
YwB_gmEuNjYzNTTPQCI0Ml0zAVQnAFtNETcXKABiVQABGgBpVhI3-RwhLjL7MACNWgGJAQCpYUA2
OTk3AC0iMzKwVgA1fgCXBCAyMGcBAIE6EDjmfCIzN5x1AG6LEDJuYgAnNgG-bQDqFAFyWAF5ZgLq
NBA2bHohOTYAFQCEE1AzNDgwNRw-QjY5OTKLADA3MzmpQBAzhW0AkCswMDM0yGcBOVIRNzQMEDNz
chA1_F0QM9yFYCwyNi4yMD6YIzE5I2IhMjZEhgDkhkA0MTQxuyoAB3gQNad2AgxYEDJvgwCQfABj
cDA0NSzROQBDNRAw-A0vMjbjBRYeNk0rT0dvd27QAQIAEwFBNTk0M60AQDgwMizKkQAtXlExMzE4
OPIVARc4IDE20mdBMjQyM0s5UDY4OTU1Q3UCUDQQLUNeEDIzFkE4NzgypTgSOSeEAPIAETHLZgB4
dzA1NjXmiwD7OwAxdiE5NCRpETNGBhA4RhcQNKpTITUzXkEAcW0AvlwA9XUiNjVCATE3MzNCPADA
fQASPiA3N5RKUjY5NzUyPTwwMTE5HGgQMwVxESwSMgD3YjI5MjO_FgCdOwATGwChYBA5lzYA7gAA
vQgxOTE5eAIQN3VUEDcRAACaARA2RisQMVlDIzEwoTwBQy4ACR0A_V8wMiw3dy1BMzY2OcFsHzJC
ABEPhAAOAfw9AE9FAhKEMjcsNNaWANY1EDOFZQDUeC05M6sBD6mRFhQywUYkMjfwA49CbGFua2V0
Qgk5BgDRHADnADA3ODNiMTAwNji_BwAvcRIxwDkBqGQAcFMwNTIyQzAAKWYAO2MQOb6JAF0oEDDR
fRExKgUwOTIs10NANDIyMPFYAu50IDUuLwYBeSgAtEQQLAhFALUwAEhWETBmAAAXLQBHXyE1MPp6
AbQfEDKLBgCqDRM4IGQLUAwLLwwMIQAqNDLQBw9EATAPRgkDDLwAANEwAL93EDANZiIwMv8DMjMs
NCcHITEyfzgwMTU4pjEhNCxXcRAz24AA3VYROJYDAVBbEDJnHj84NzhQAQAhLTO5CQDiByAzOFxh
ALRLMTgwMMxfAtpaEDndBmA5MzM2MThCBQAPfQBqfyA3NTiCAS8BMC41OachYDc5NDA0OM8MAHxc
ALZqEDk2CQFgRAA1YwBlgRA0MjMBcgEwMzI3NJASOGJXD-oBCw8_AhMxNDYuGlgPoQEEDzhcEx94
Rj8GUTg0Mzkym2cC-kgA6HIGAysAOSggMS4AMwDbhxE3U2cMJAAPJysDD5gALVAwMDU5MQpoEDEQ
hgCyKxk1sisAmAAgMTNNgSAwODIBDiQAD5gAQCEtNmsyEDGqaQL0ZQ4wAQ0jAAC4cAACbm8yNTk0
OTaXAEEgOC75CAC3Nl83NDkwOJcAAQDvV0AzNzIyqR0-NDA4lwBkDcYBAN1jAEpDIDQ3dYcOgQIP
hC3mBjwlD9VEFAr8TzE4LDllAEU3LDU2bQATMEUlAVglDyILAg9YAQAP-C0UALebEDJrACI4LN8A
EjCOgwHihAQBABI3d385OS42FQAClV0Ayo8HAQACRxIArwAfNJmaGB83IwEWMTQzLAM4QzEwLDWG
ahg2lQACWEQbMxUALzE0qwABBBcATzYsNjAVURUEckQAdXUPWgEKIjE1hYVBLTQ5LGYJQi0yNSzT
CQJoLQB8ACY3MAkALzkxH1cWA1ICAEwHHzGWPwsC_VoyNTMsgR0yMzIsmlcA82QRMwcLSjcsNjmn
ADAyLDkbAATBABA0_pcFowABTyEvMjNRNkEwOC41swkQOXtwITc5JFIAEhUBCyYCE2QAaCMKJAAt
MzMkAABcgwkkAAAJUAskACw0OEgACyQAD2MVDA4SFA_4AgwQNAM9ITUwjZMALHQBEE9ANDY4M2iI
JDY1BJEPlQALAN0AACsWCyUBCyQAACAKC2sAAfBtBWsAD5YDDRs5HGAPuwEOEDFTDDE3NjXQhCEy
NWAkETi4NAD6TgFKBQCFmQUiACI0Nt5KCiMAES2VFRAzQF0gODC3dj8tOTYkAAAbNCQAAJp_CSQA
EDHVcQiOAEg3OS42IwAPSlQ_AE9JAFULAJILUTg1OSwzWnEhMzlEUCI4NucNYDU2MDg1M4QnEDTW
OwB7DjA0Nzb6ixIzIQAhNDP3DQAWeQGuPHE0NTgwNjAwQ44AIgAAMWcBxI8QMoxiICw2L0cAuWcj
ODa2RQCFfgDkZSAzMopqAKJTITUzz0oQNQdtAhcQITAyFGsRMBMKALhiMDI5MOuVQjkyNjGHABAw
A4dgODQ4NzY0biMA1n0hMjKGgh81JAUVHzU4ARQBLKgzMjAuz0cAMVgQOEhxACFEITM4gRIgOTDV
jyI2OLYTIDU1qBMAx3UCZgEABwwCN5sTNZULAM1xcTgyMjI5Mje7KwDkdQAKe0IxNDcyyQ5hOTQw
MTI1xFsRLGtDEDJqbwCudhE2HAwA6Y8QMVipAEsAABGQAFV3EDcGmBE18QYA1kEA8oIA2YAA03cA
OxUAE5gQOFJ9EjRUBScuNKQDIDIs74kxMDg5Tpk-ODQ1gQI-Ae0LAH90EDN6diA4MT4BAfdvQjkw
OTMKbgCMKhgyIwAA1qEMIwAA_ywHIwAASgULIwAbMmkALTcwaQAqMjJGAC43NIwAJi4xIgAwMDgs
6GALIwA5My40IwAA9E8IIwAPiwI9KjIw2QAuMjO2ABo22QAtNDMfARsxRgAeNEYAADouCNkALTQx
RgAbNCMALTI5RgAbOB8BLTIyRgAbMkYACRMCLzY5zgEBGzYjAA9MQDMHZwEQNtKLAgydASAPEi3m
SxEz9mgCKGQCg3ACcRYAIZUxNTg2o3cDlBYA2IIRMRyJD50APjEtMTU5UwIiCBAw1FEhMzYXOSAt
Mvl9HzZ9Cz4hMjH5ABM05DYAzQcSNZUJABgAA_yOARYAECzuLB81gQA9IzQ3fgAA7EoAtHoBqEwB
pXYArFIJVwgAWEEJIwAQNa9SCnoIEzYzaw9iCBUPpV8KGTDGrADpmgBjggARNQIpAQDmBSM1OPeE
Dy0CDQHjACE4MZR4AISRAF8BEDnFDhA2mHwD3YElMzerKCIzMAsAJC41txhRNjM5MDOYchIsg0MA
KJgyOTEwn3UBP3wgODeIFxA2dSEB71UA-JIQNX50ETA6BhEtcWUDb6wAZlcA8oBAMTcwMxMIIS00
qBoAFxQAb24DIwAQNOtxITEx5ywCUBkQN1EZIDM5_xcDaUcQMUBgAeURMDEyLOwVEDIUawFNlxIx
SgUZMI4GACdsBo8GEjWyFRA5ABsROGyFADN4ADaZAcQRAI9aAjEdAXmBIDE4dnUhNzVxXwD1jiE1
MqsxEjZcBxM14AAPKAM9ASdSEzVJpBExmgMTNbOkAMmYEDE4jmE4MzI0MzlnLwC7MgCgEBQ48SMA
PwASNoemALZXYDM4MDU3M0GNEzQadBAyfoIAyAAfOP9DFQ8cCxUBvLAATgIBIlcRMsUBEzYnBwDT
AQMdaSEyMhkFAGKlD1oNPgAxmwYQDBEyNAsWMxAMETPfAQwjAABFHAkjAAB_hAlQBgCVIxs5JAAZ
N58LEjN1VQqfCwBcGwskAB01JAAAQJUAvFUQMy4ZAQFwAMsJIDM2eBYiMjXWARA2XFsgMDZ6hQJl
cgCHYACucUI5MDM18QoAREEAYokAQo4AdSoB7SwAsZd-NDQwNjg5OEECQgFxGQEzdhA2_YshODQX
WiE3MO6HAEmSHzNGAAEABQFQNTM0MTR6XS8yNwYCPwDOXwrjBQBNoQnABQBjBgojABw2XQ4A06kM
KQYLIwAAHXgKKQYA9lIKRgANIwAATxcJIwAAh14KIwAaMK8AD2QEDA_iDx4uNTBxAAsDByw1NwMH
AO1YDCABGTQjAABUsw63AA4ZFQ_4ACcAb3gAvwwBxqQwNTguJiUAzWsyMzQyJq0RNKxoAUQhAVk1
MDI4NbFgIjg4nA4A2HcAkHYAzWsAKUsjLTUXWRE0lYQPsgA-EDavnwlHARw2RwErNjRHASw1OOgR
AP2LDCMAHzYhAkpQNi4wMzlUfABvpBE1gwYAmBsAenIAhjQC2AIwMTc4UyYAkyMAbwQANIcxNTg3
qH0iNDPpUgAgpwC0kiE0NpEBMDcuM6gpTjkwNzGMJg88By4QNSoJIDgzlnNBNjg4NN8EETkYgwDX
VBM5bQEaMSMAHTUjAADYDBA5sSkhMjTjYABvSgA4jACFoTIyNDd-Uxk5RgAAIwAKRgAsNTSMAADE
BQcjAA_zAT03My44dhIRN48GGjdrBgH7Kwj6BgAcNwrWBgByJQZGABI24BIeMVISDyMDOABsIAsl
Bxo0cwAB3QYKRg8AV1sJuwAPlwA-D3QHEDkwLjAuASIxNO2QDzABGSsxMG4XD2laDjg2LjN2ABAs
8ikaNDABHTkjABoylgABLbEaOTsUHDYjAABMPQlGAC44NNwAD8ADOQDqDyEwN5akQTI4NSwXmjAz
MzknHwIjHCs1MSIAAA6rCiIAAAsQByIAKjc4RAAPswA8AO2uCG8AEDSWcgmRAAC-DRc2oBkARJcC
kGcAW6UgNzKbpQEEGwCucgA3rkM3MTc23BYgNzjnKhA2xJMRMWUgAARgITg35C8CyyUoMzZbAC8y
LpQBPio2MV8aAfMaALV_MDIxN8IkAHUkANQAAGcNEDhLgTI0NDZFBQkiAAC9AA8iAAsAcwoKIgAA
ySQJXAE9OS44DwIJ7QFLNDAuNiIAGjaABwDLXgoRDgChnghEACwzNVMCKzQ0IgAcNiIAAIMUD0QA
CyszNyIADSgCKjQ0zQEAzAACKF8ZNigCAD4KCSgCAJRhCxQDCycBKjQzIgAtNThJARo14wAsNjhJ
ASo2MYgAKjg0sAIPJBtAPzAuMAAbDSw1NyQAHDGjCwDiBwskAA3qCwCMMg4kAA9hCUkCVykRMZEQ
AgoAD8EGPgCOkzMxMjKuEAqRGy4xMSYbD3wAOw9yAAwDfxkIuxtPOTguNNIHSgDgaQLAewHMBg9z
AUAQNtV6CPUJKTEwGQoCggwKIwAqNzQ7Cg_VAAMPwQUnJDcyWCEiNDWTRgB9BgAbAhM1SXgCDzcA
8oUzMTA0okEOizoPdRYwAGxvCx8BOTYuMh8BLTI5QgEbOCMAGTUiAAA8mh41QgEPbLgQD7YAFSsy
N5MAKjc3cAABYQULIwAdNiMAGzX8ACw4OCMALTM5HwEbMvwAKzM4aQAtOTFGABwwaQANrwArMjUj
AC85MkIBEA9MCykgNC7JlgDCtjAxMjeOhRExEXwgMzR6VgIzkQGruAC8DwAvkzI1Mjb-JUEwMjI1
X48SMLsTAf8wAEaYEDJMlw8jAAAQNN8oAK1WANFjIjQ2agAAvJ4A84MCQToOIwAhMTgWDgBNhj83
ODhpAAIAvi8QNBUAACySHzWwAAMOJAAAbg4AJAAA4T0BcRMAawAAMR0AM2kA7poPn0oMD8dT1Q9q
BR8J2gAD0lMB3AAHDAAB3gAPYgEKD0lUiQ-5AAMAPBsCm5wBCgAvMjnGBj8CC1QBYwASNAoAD2MA
PhU2YQAHCQAPzABCFDS9TgEIAA9gAEAGwgAPwwBGBMQAAfesD8YAQhUzxgAfM8YARSQxOcYAAeZS
HzNjAEUVOWMABQoAAtoAHzHMAkQjNTFsABg0CQAPagBBAMYjFTE2UwQJAAFzAAAbAB8yTwYMD3oA
KCMyNnEAGDMJAAM5NQ56AA9oUQIPVRwZCHwAFDR1ggBgggGMDjM5NiwQABI0pY0CGociMCyfHgQQ
ABQtIQAAcIIEEQACQgAVLVUAALmJHzYJHRUvMjVqfxUSME_GQjY0LDAHAAJ4AA-MAC0PqAAMKzI1
qQAPXgGFD5YCAg__aB9CODAsMK4rIjM3qwABdgETMKIABBAAIC02eyQDowAfMKotNAeHACMzMvkA
ITMyOyMB7FYGCQAvNDhzAD8BRboCbQEFbAAA8iwHCgAPdwAEUHIifX19
:: vgfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI4IDE5OjExOjQyIixtb2RpZmllZD0iMjAyNC0x
Mi0xMSAxNTo1Njo1MyIsc3RvcmVkPSIyMDI0LTAzLTI4IDE5OjExOjQyIl1d
:: canvas.lua
--[[pod_format="raw",created="2024-03-28 12:58:10",modified="2024-12-11 15:56:24",revision=8898]]


highlightedlayer = -1 --for mousing over the layer list to highlight which it is

dragfrom = vec(0,0)
op_pivot = vec(0,0) --the origin of vert/polygon operations

snapping = false

moving = false
draggingpoint=-1
rotating = false
scaling = false
scaleaxis = {x=true,y=true}
panning = false


view = {
	x=0,y=0,zoom=1,targetzoom=1, w=480,h=270,
	top=0,left=0,right=479,bottom=270,
	mx=0,my=0
}
zooms = {0.1,0.25,0.5,1.00,2.00,5.00,10,20,50}
function reset_view()
	--view.zoom=1.0
	view.targetzoom=1.0
	view.x=0
	view.y=0
end
function update_canvas()
	--find view bounds and size
	if showpanel then
		view.top=toolbar.height
		view.bottom=disp_h
		if ve.panelright then
			view.left=0
			view.right=panel.x
		else
			view.left=panel.width
			view.right=disp_w
		end
	else
		view.left=0
		view.right=disp_w
		view.top=0
		view.bottom=disp_h
		--uncomment this for fun when the ui is hidden
		--[[
		view.left=100 + sin(time())*20
		view.right=300 - sin(time())*20
		view.top=60 + sin(time())*20
		view.bottom=200 - sin(time())*20
		--]]
	end
	view.w=view.right-view.left
	view.h=view.bottom-view.top
	
	--need to know if the view has the mouse pointer
	mouseonview = mx>=view.left and mx<view.right and my>=view.top and my<view.bottom

	--modes and stuff
	if (kbp("Toggle Info")) toggle_info_display()
	if (kbp("Toggle Grid")) toggle_grid_display()
	
	if (kbp("Grab Tool")) pick_tool("grab")
	if (kbp("Rotate Tool")) pick_tool("rotate")
	if (kbp("Scale Tool")) pick_tool("scale")
	if (kbp("Point Tool")) pick_tool("point")

	--position mouse in canvas space
	snapping = kb("Snap")
	if (ve.passivesnapping) snapping = not snapping
	btn_snap.sprite = snapping and 15 or 7
	local canvmouse = screentocanv(mx,my)
	view.mx = canvmouse.x
	view.my = canvmouse.y
	local snappedmouse = snap(view.mx,view.my, snapping)
	view.mx_cursor = snappedmouse.x
	view.my_cursor = snappedmouse.y
	
	--figure out what has mouse focus
	highlightpoint=-1
	highlightedge=-1
	if mouseonview and tool=="point" and not panning then
		--check for mouse over verts
		highlightpoint = mouse_over_point(get_curr_layer().points)
		
		--check for which edge the mouse is closest to
		if highlightpoint==-1 and get_curr_layer().type!="strip" then
			highlightedge = get_closest_edge(get_curr_layer().points,view.mx,view.my)
		end
	end
	
	
	
	if mb>0 then
		--we're doing /something/
		if draggingpoint<=0 and not (panning or scaling or rotating or moving) then
			if clicked and mouseonview then
				dragfrom=vec(view.mx,view.my)
				op_pivot = vec(0,0)
				
				if kb("Pan") or tool=="pan" then
					--begin pan
					panning = true
				elseif tool=="rotate" then
					--begin rotation
					rotating = true
					layers_pre_op()
					if (pivot_place=="Centroid") op_pivot=get_centroid(get_curr_layer().points)
				elseif tool=="grab" then
					--begin moving
					moving = true
					layers_pre_op()
				elseif tool=="scale" then
					--begin scaling
					scaling = true
					layers_pre_op()
					scaleaxis={x=true,y=true}
					if (pivot_place=="Centroid") op_pivot=get_centroid(get_curr_layer().points)
				elseif tool=="point" then
					if curr_layer>0 then
						undo_checkpoint()
						if highlightpoint<=0 then
							--add a point
							local tgtindex = max(highlightedge+1,1)
							if (tgtindex>#get_curr_layer().points) tgtindex=1
							if get_curr_layer().type=="strip" or key("shift") then
								tgtindex=#get_curr_layer().points+1
							end
							add(get_curr_layer().points,vec(view.mx_cursor,view.my_cursor),tgtindex)
							
							draggingpoint = tgtindex
							rebuild_this_layer()
						else
							--begin dragging the highlighted point
							draggingpoint=highlightpoint
						end
					end
				end
			end
			if clickedright and mouseonview then
				if highlightpoint>0 then
					--remove this point
					undo_checkpoint()
					deli(get_curr_layer().points,highlightpoint)
					highlightpoint=-1
					rebuild_this_layer()
				end
			end
		end
		if panning then
			view.x = view.x-(view.mx-dragfrom.x)
			view.y = view.y-(view.my-dragfrom.y)
		end
		if draggingpoint>0 then
			get_curr_layer().points[draggingpoint].x = view.mx_cursor
			get_curr_layer().points[draggingpoint].y = view.my_cursor
			rebuild_this_layer()
		end
		if moving then
			local offset = vec(view.mx,view.my)-dragfrom
			--if (kb("Snap"))	offset= vec(round(offset.x),round(offset.y))
			if (kb("Snap"))	offset= vec(onedeesnap(offset.x, ve.grid_size.x),onedeesnap(offset.y, ve.grid_size.y))
			buttoninfo = "Moving: "..tostr(xdp(offset.x,3))..", "..tostr(xdp(offset.y,3))
			for i=1,#vspr.layers do
				if vspr.layers[i].selected then
					layer_op_move(vspr.layers[i], offset )
				end
			end
		end
		if scaling then
			local scalar = rnd()*2.0
			local homedist = (op_pivot-dragfrom):magnitude()
			local currdist = (op_pivot-vec(view.mx,view.my)):magnitude()
			scalar=invlerp(0,homedist,currdist)
			
			if (kb("Snap"))	scalar= round(scalar*4)/4
	
			buttoninfo = "Scaling"
			if (kbp("Axis X")) then
				scaleaxis.y= not scaleaxis.y
				if (not scaleaxis.y) scaleaxis.x=true
			end
			if (kbp("Axis Y")) then
				scaleaxis.x= not scaleaxis.x
				if (not scaleaxis.x) scaleaxis.y=true
			end
			if scaleaxis.x!= scaleaxis.y then
				if scaleaxis.x then
					buttoninfo..= " X"
				else
					buttoninfo..= " Y"
				end
			end
			buttoninfo..=": "..tostr(xdp(scalar,3))
			
			for i=1,#vspr.layers do
				if vspr.layers[i].selected then
					layer_op_scale(vspr.layers[i], op_pivot, scalar, scaleaxis.x, scaleaxis.y)
				end
			end
			
		end
		if rotating then
			local homeang = atan2(op_pivot.y-dragfrom.y,op_pivot.x-dragfrom.x)
			local currang = atan2(op_pivot.y-view.my,op_pivot.x-view.mx)
			local angdiff = homeang-currang
			if (kb("Snap"))	angdiff= round(angdiff*8)/8
			
			buttoninfo="Rotating: "..tostr(xdp(angdiff*360,3))
			
			for i=1,#vspr.layers do
				if vspr.layers[i].selected then
					layer_op_rotate(vspr.layers[i], op_pivot, angdiff)
				end
			end
		end
	else
		--we're not doing stuff rn
		panning = false
		
		
		if (rotating or scaling or moving) then
			layers_post_op()
		end
		
		rotating = false
		scaling = false
		moving = false
		draggingpoint=-1
	end
	
	
	--keyboard panning
	if not panning and mouseonview then
		if tool!="grab" then
			if (kb("Left")) view.x -= tdelta *200 /view.zoom
			if (kb("Right")) view.x += tdelta *200 /view.zoom
			if (kb("Up")) view.y -= tdelta *200 /view.zoom
			if (kb("Down")) view.y += tdelta *200 /view.zoom
		else
			local nudge=nil
			if (kbp("Left")) nudge = vec(-1,0)
			if (kbp("Right")) nudge = vec(1,0)
			if (kbp("Up")) nudge = vec(0,-1)
			if (kbp("Down")) nudge = vec(0,1)
			if nudge!=nil then
				layers_pre_op()
				for i=1,#vspr.layers do
					if vspr.layers[i].selected then
						layer_op_move(vspr.layers[i], nudge )
					end
				end
				layers_post_op()
			end
		end
	end
	
	--flipping horizontally/vertically
	if kbp("Flip Horizontal") or (not key("ctrl") and kbp("Flip Vertical")) then
		layers_pre_op()
		if pivot_place=="Centroid" then
			op_pivot=get_centroid(get_curr_layer().points)
		else
			op_pivot = vec(0,0)
		end
		for i=1,#vspr.layers do
			if vspr.layers[i].selected then
				layer_op_flip(vspr.layers[i], kbp("Flip Horizontal"), op_pivot)
			end
		end
		layers_post_op()
	end
	
	--edge subdivision
	if tool=="point" and (not panning) and draggingpoint==-1 then
		if (kbp("Subdivide 1")) subdivide_edge(get_curr_layer(), highlightedge, 1)
		if (kbp("Subdivide 2")) subdivide_edge(get_curr_layer(), highlightedge, 2)
		if (kbp("Subdivide 3")) subdivide_edge(get_curr_layer(), highlightedge, 3)
		if (kbp("Subdivide 4")) subdivide_edge(get_curr_layer(), highlightedge, 4)
		if (kbp("Subdivide 5")) subdivide_edge(get_curr_layer(), highlightedge, 5)
		if (kbp("Subdivide 6")) subdivide_edge(get_curr_layer(), highlightedge, 6)
		if (kbp("Subdivide 7")) subdivide_edge(get_curr_layer(), highlightedge, 7)
		if (kbp("Subdivide 8")) subdivide_edge(get_curr_layer(), highlightedge, 8)
		if (kbp("Subdivide 9")) subdivide_edge(get_curr_layer(), highlightedge, 9)
		
	end
	
	--zooming
	if key("shift") then
		if kb("Zoom +") or kb("Zoom -") or mwheel!=0 then
			if (kb("Zoom +")) view.zoom+=tdelta*sqrt(view.zoom)*2
			if (kb("Zoom -")) view.zoom-=tdelta*sqrt(view.zoom)*2
			if (mouseonview) view.zoom+=mwheel*4*tdelta*sqrt(view.zoom)*2
			view.zoom = min(max(view.zoom,zooms[1]),zooms[#zooms])
			view.targetzoom = view.zoom
		end
	else
		if kbp("Zoom +") or kbp("Zoom -") or (mouseonview and mwheel!=0) then
			if (kbp("Zoom -") or (mwheel<0 and mouseonview)) change_zoom(-1)
			if (kbp("Zoom +") or (mwheel>0 and mouseonview)) change_zoom(1)
		end
	end
	
	view.zoom = clerp(view.zoom, view.targetzoom, tdelta*15)
	
	if abs(view.zoom-view.targetzoom)<0.01 then
		view.zoom = view.targetzoom
	end
	view.zoom = min(max(view.zoom,zooms[1]),zooms[#zooms])
	view.targetzoom = min(max(view.targetzoom,zooms[1]),zooms[#zooms])
	
	if (kb("Reset View") or kbp("Reset View")) reset_view()
	
end

function change_zoom(v)
	local zoomIndex = 1
	for i=1,#zooms-1 do
		if view.targetzoom>=zooms[i] and view.targetzoom<=zooms[i+1] then
			zoomIndex=i
		end
		if (view.targetzoom>=zooms[i+1]) zoomIndex = i+1
	end
	if (v<0 and view.targetzoom==zooms[zoomIndex]) zoomIndex-=1
	if (v>0) zoomIndex+=1
	zoomIndex = min(max(zoomIndex,1),#zooms)
	view.targetzoom = zooms[zoomIndex]
end

function draw_canvas()
	clip(view.left,view.top,view.w,view.h)
	camera((view.x*view.zoom-view.left)-(view.w/2),(view.y*view.zoom-view.top)-(view.h/2))
	
	
	--draw axis
	if showgrid then
		fillp(42405)
		local gridcol = (ve.gridcolor<<8)+ve.clearcolor
		local gridboundsy = 100*ve.grid_size.y
		local gridboundsx = 100*ve.grid_size.x
		local yh = view.h*0.51
		local xw = view.w*0.51
		for y=-gridboundsy,gridboundsy,ve.grid_size.y do
			if y>=view.y-yh/view.zoom and y<view.y+yh/view.zoom then
				line(-gridboundsx*view.zoom,y*view.zoom,gridboundsx*view.zoom,y*view.zoom, gridcol)
			end
		end
		for x=-gridboundsx,gridboundsx,ve.grid_size.x do
			if x>=view.x-xw/view.zoom and x<view.x+xw/view.zoom then
				line(x*view.zoom,-gridboundsy*view.zoom,x*view.zoom,gridboundsy*view.zoom, gridcol)
			end
		end
		
		line(-9999,0,9999,0, (ve.gridcolor<<8)+ve.axiscolor)
		line(0,-9999,0,9999, (ve.gridcolor<<8)+ve.axiscolor)
		fillp()
	end
	
	
	
	--draw current sprite
	vgfx_subpixel = ve.subpixels
	vgfx_wire = kb("Wireframe")
	vgfx_trisdrawn = 0
	currspr = get_sprite(vspr)
	sprv(currspr, 0,0, 0,view.zoom)
	
	
	
	--draw selected layers edges/verts
	if (mouseonview or highlightedlayer>0) then-- and not (scaling or moving or rotating) then
		fillp(0xc936936c36c96c93 >> (((time()*15)\1)%4)*16)
		--draw edges
		if not (moving or rotating or scaling) then
			if highlightedlayer>0 then
				draw_edges(vspr.layers[highlightedlayer])
			elseif tool!="pan" then
				for i=1,#vspr.layers do
					if vspr.layers[i].selected then
						if i==curr_layer then
							draw_edges(vspr.layers[i],highlightedge)
						else
							draw_edges(vspr.layers[i],-1)
						end
					end
				end
			end
		end
		
		
		if mouseonview and tool=="point" then
			--draw vertices
			local points = get_curr_layer().points
			for i=1,#points do
				if highlightpoint==i and draggingpoint<=0 then
					circfill(points[i].x*view.zoom,points[i].y*view.zoom, 4, (7<<8)+9)
				end
		
				
				if i==1 and (get_curr_layer().type!="ear") then
					circfill(points[i].x*view.zoom,points[i].y*view.zoom, 2, (1<<8)+8)
					circfill(points[i].x*view.zoom,points[i].y*view.zoom, 1.6, (7<<8)+6)
				else
					circfill(points[i].x*view.zoom,points[i].y*view.zoom, 2, (0<<8)+1)
					circfill(points[i].x*view.zoom,points[i].y*view.zoom, 1.6, (7<<8)+6)
				end
				
			end
		end
	end
	fillp()
	
	--draw the screen guide/frame
	if ve.guide.show then
		--[[
		local l,r,t,b = (ve.guide.x-ve.guide.w*0.5)*view.zoom-1,
		(ve.guide.x+ve.guide.w*0.5)*view.zoom+1,
		(ve.guide.y-ve.guide.h*0.5)*view.zoom-1,
		(ve.guide.y+ve.guide.h*0.5)*view.zoom+1
		--]]
		local l,r,t,b = -ve.guide.w*0.5,ve.guide.w*0.5,-ve.guide.h*0.5,ve.guide.h*0.5
		l+=ve.guide.align_h*(ve.guide.w*0.5)
		r+=ve.guide.align_h*(ve.guide.w*0.5)
		t+=ve.guide.align_v*(ve.guide.h*0.5)
		b+=ve.guide.align_v*(ve.guide.h*0.5)
		--(ve.guide.h*0.5)*ve.guide.align_v,
		l*=view.zoom
		r*=view.zoom
		t*=view.zoom
		b*=view.zoom
		l-=1
		r+=1
		t-=1
		b+=1
		
		line(l, t, r, t, ve.axiscolor)
		line(l, b, r, b, ve.axiscolor)
		line(l, t, l, b, ve.axiscolor)
		line(r, t, r, b, ve.axiscolor)
		line(l-1, t-1, r+1, t-1, ve.gridcolor)
		line(l-1, b+1, r+1, b+1, ve.gridcolor)
		line(l-1, t-1, l-1, b+1, ve.gridcolor)
		line(r+1, t-1, r+1, b+1, ve.gridcolor)
	end
	
	--draw a line between the mouse and the pivot
	if rotating then
		line(op_pivot.x*view.zoom,op_pivot.y*view.zoom,view.mx*view.zoom,view.my*view.zoom,8)
	elseif scaling then
		line(op_pivot.x*view.zoom,op_pivot.y*view.zoom,view.mx*view.zoom,view.my*view.zoom,12)
	end
	
	--draw the centroid point for scale/rotate
	if mouseonview and (tool=="scale" or tool=="rotate") then
		if not scaling and not rotating then
			if pivot_place=="Centroid" then
				op_pivot=get_centroid(get_curr_layer().points)
			else
				op_pivot = vec(0,0)
			end
			--op_pivot=get_centroid(get_curr_layer().points)
		end
		local vorigin=op_pivot*view.zoom
		circfill(vorigin.x,vorigin.y,3,0)
		if tool=="scale" then
			line(vorigin.x-2,vorigin.y,vorigin.x+2,vorigin.y,12)
			line(vorigin.x,vorigin.y-2,vorigin.x,vorigin.y+2,12)
		else
			circ(vorigin.x,vorigin.y,2,8)
		end
	end
	
	--we're done drawing the canvas
	camera()
	clip()
	
	--some of the tools need a custom mouse pointer, so lets do that stuff	
	local cursortype = cursors.crosshair
	if (tool=="point" and (highlightpoint>0 or draggingpoint>0)) cursortype = cursors.pointover
	
	if (tool=="rotate") cursortype = cursors.rotate
	if (tool=="grab") 	cursortype = cursors.move
	
	if (tool=="scale") then
		if (view.mx>=op_pivot.x and view.my>op_pivot.y)
		or (view.mx<op_pivot.x and view.my<=op_pivot.y) then
			cursortype=cursors.diag_down
		else
			cursortype=cursors.diag_up
		end
		if scaling and scaleaxis.x!=scaleaxis.y then
			if scaleaxis.x then
				cursortype =cursors.horiz
			else
				cursortype =cursors.vert
			end
		end
	end
	if kb("Pan") or tool=="pan" then
		cursortype=cursors.hand
	end
	if (panning) cursortype = cursors.grab
	
	mouse_cursor_gfx = cursortype
	
	
	
end
highlightpoint=-1

mouse_cursor_gfx = 1--canvas mouse

--[[function cursor_reset_check()
	if not mouseonview and not cursor_reset then
		--we just moved the view away from the canvas, lets put it as it was
		if not (panning) then
			cursor_reset = true
			--cursors.current=cursors.pointer
			window{cursor=cursors.pointer}
		end
	end
end]]

function screentocanv(x,y)
	local p=vec(x,y)
	p.x-=(view.w/2)+view.left
	p.y-=(view.h/2)+view.top
	
	p/=view.zoom
	
	p.x+=view.x
	p.y+=view.y
	return p

end
function canvtoscreen(x,y)
	local p=vec(x,y)
	p.x-=view.x
	p.y-=view.y
	
	p*=view.zoom

	p.x+=(view.w/2)+view.left
	p.y+=(view.h/2)+view.top
	return p
end
:: gui.lua
--[[pod_format="raw",created="2024-03-27 09:28:11",modified="2024-12-11 15:56:24",revision=10227]]

buttoninfo = ""

acceptclicks = true




function generate_gui()
	--embarrasing how long it took before I noticed the API comes with a gui
	gui = create_gui()
	
	
	
	local panelw = 146
	
	--toolbar
	local toolw = disp_w-panelw
	toolbar = gui:attach{ x=0, y=0, width=toolw, height=11 }
	function toolbar:draw()
		rectfill(0,0,self.width-1,self.height-1,5)
	end
	
	local bw=11
	btn_point = create_icon_button(toolbar, {x=5,y=0,width=bw,height=bw,sprite=25,bg=6})
	btn_rotate = create_icon_button(toolbar,{x=20,y=0,width=bw,height=bw,sprite=27,bg=6})
	btn_grab = create_icon_button(toolbar,{x=35,y=0,width=bw,height=bw,sprite=26,bg=6})
	btn_scale = create_icon_button(toolbar,{x=50,y=0,width=bw,height=bw,sprite=28,bg=6})
	
	btn_pan = create_icon_button(toolbar,{x=65,y=0,width=bw,height=bw,sprite=29,bg=6})

	btn_pivot = create_icon_button(toolbar,{x=90,y=0,width=bw,height=bw,sprite=20,bg=6})
	
	btn_snap = create_icon_button(toolbar,{x=115,y=0,width=bw,height=bw,sprite=7,bg=6})
	btn_snapmode = create_icon_button(toolbar,{x=130,y=0,width=bw,height=bw,sprite=35,bg=6})
	set_snap_mode(snapmode)
	
	btn_undo = create_icon_button(toolbar, {x=155,y=0,width=bw,height=bw,sprite=40,bg=6})
	btn_redo = create_icon_button(toolbar, {x=170,y=0,width=bw,height=bw,sprite=41,bg=6})
	
	btn_info = create_icon_button(toolbar,{x=toolw-15,y=0,width=bw,height=bw,sprite=6,bg=6})
	btn_nightmode = create_icon_button(toolbar,{x=toolw-30,y=0,width=bw,height=bw,sprite=23,bg=6})
	btn_grid = create_icon_button(toolbar,{x=toolw-45,y=0,width=bw,height=bw,sprite=5,bg=6})
	btn_frameguide = create_icon_button(toolbar,{x=toolw-60,y=0,width=bw,height=bw,sprite=22,bg=6})
	
	
	btn_zoomin = create_icon_button(toolbar,{x=toolw-90,y=0,width=bw,height=bw,sprite=39,bg=21})
	btn_resetview = toolbar:attach_button({x=toolw-120,y=0,width=30,height=bw,bg=21})
	btn_zoomout = create_icon_button(toolbar,{x=toolw-120-bw,y=0,width=bw,height=bw,sprite=47,bg=21})
	function btn_resetview:draw(msg)
		self.label = tostr(flr(view.zoom*100)).."%"
		draw_text_button(msg,self)
	end
	function btn_resetview:tap(msg)
		reset_view()
	end
	function btn_resetview:hover(msg)
		hover_button(msg,self)
	end
	

	btn_point.selected = true

	--side panel
	bw+=1
	local bh=bw-1
	
	panel = gui:attach{ x=disp_w-panelw, y=0, width=panelw, height=disp_h }
	--panel = gui:attach{ x=disp_w-panelw-panelw-1, y=12, width=panelw, height=disp_h }
	function panel:draw()
		rectfill(0,0,self.width-1,self.height-1,5)
	end
	
	--colors block
	panel_cols = panel:attach{x=4,y=5,width=panelw-8,height=38}
	function panel_cols:draw(msg)
		rectfill(0,0,self.width-1,self.height-1,0)
		acceptclicks = not (display_help or display_settings)
		local mx,my=mx-self.x-self.parent.x, my-self.y-self.parent.y
		local coly=1
		local colx=1
		local colw = 16
		local colh = 8
		if paneltopmode=="cols" then
			for i=1,#colors do
				colbutton(colors[i],colx,coly,colw,colh,mx,my)
				colx+=colw+1
				if colx+colw>panelw-5 then
					colx=1
					coly+=colh+1
				end
			end
		elseif paneltopmode=="fills" then
			--rectfill(1,1,self.width-2,self.height-2,3)
			colh=11
			for i=1,#fills do
				fillbutton(fills[i],colx,coly,colw-1,colh-1,mx,my)
				colx+=colw+1
				if colx+colw>panelw-5 then
					colx=1
					coly+=colh+1
				end
			end
		elseif paneltopmode=="layertype" then
			local x,y = 20,18
			print("Polygon:",x,y-11,6)
			pal(32,6)
			
			if (get_curr_layer().type == "ear") rect(x-1,y-1,x+12,y+11,8)
			if button(19,x,y,11,10,"Ear Clip Triangulation",false,false,6,mx,my) then
				set_layer_types("ear")
				update_style_buttons()
			end
			x+=13
			if (get_curr_layer().type == "fan") rect(x-1,y-1,x+12,y+11,8)
			if button(11,x,y,11,10,"Fan Triangulation",false,false,6,mx,my) then
				set_layer_types("fan")
				update_style_buttons()
			end
			x+=13
			if (get_curr_layer().type == "strip") rect(x-1,y-1,x+12,y+11,8)
			if button(3,x,y,11,10,"Strip Triangulation",false,false,6,mx,my) then
				set_layer_types("strip")
				update_style_buttons()
			end
			x=85
			print("Line:",x,y-11,6)
			if (get_curr_layer().type == "line") rect(x-1,y-1,x+12,y+11,8)
			if button(4,x,y,11,10,"Line",false,false,6,mx,my) then
				set_layer_types("line")
				update_style_buttons()
			end
			x+=13
			if (get_curr_layer().type == "line_closed") rect(x-1,y-1,x+12,y+11,8)
			if button(12,x,y,11,10,"Closed Line",false,false,6,mx,my) then
				set_layer_types("line_closed")
				update_style_buttons()
			end
			pal()
		end
	end
	
	
	
	--top-block-selecting block
	btn_pickcols = create_icon_button(panel, {x=5,y=45,width=bw,height=bh,sprite=1,bg=6})
	btn_pickfill = create_icon_button(panel, {x=20,y=45,width=bw,height=bh,sprite=2,bg=6})
	btn_layertype = create_icon_button(panel, {x=35,y=45,width=bw,height=bh,sprite=19,bg=6})
	--btn_outline = create_icon_button(panel, {x=50,y=45,width=bw,height=bh,sprite=4,bg=6})
	
	--layers block
	btn_addlayer = create_icon_button(panel, {x=panelw-31,y=46,width=bw,height=bh,sprite=10,bg=6})
	btn_dellayer = create_icon_button(panel, {x=panelw-18,y=46,width=bw,height=bh,sprite=18,bg=6})
	
	panel_layers = panel:attach{x=5,y=59,width=panelw-10,height=126}
	function panel_layers:draw()
		rectfill(0,0,self.width-1,self.height-1,0)
		if (layers_content.height<=self.height) rectfill(self.width-8,0,self.width-1,self.height-1,5)
		layers_content.height = #vspr.layers*12+2
	end
	layers_content = panel_layers:attach{x=0,y=0,width=panelw-18,height=30}
	layers_scroll = panel_layers:attach_scrollbars({autohide=true})
	function layers_content:draw(msg)
		layers_content.height = #vspr.layers*12+2
		layers_content.y = min(max(layers_content.y,panel_layers.height-layers_content.height),0)
		acceptclicks = msg.has_pointer and not (display_help or display_settings)

		local mx,my=mx-self.parent.x-self.parent.parent.x, my-self.y-self.parent.y-self.parent.parent.y
		--circ(mx,my,10,8,9)
		highlightedlayer = -1
		for i=1,#vspr.layers do
			local y=1+#vspr.layers*12-i*12
			if (vspr.layers[i].show) rectfill(2,y+1,self.width-3,y+10,1)
			
			local fillx=5
			if acceptclicks and my>=y and my<y+12 then
				--mouse over this layer so highlight it
				highlightedlayer = i
				local hcol = 21
				if (vspr.layers[i].show) hcol = 16
				rectfill(2,y+1,self.width-3,y+10,hcol)
				
				if vspr.layers[i].name!="" then
					buttoninfo = "Layer: "..vspr.layers[i].name
				else
					buttoninfo = "Layer: "..tostr(i)
				end
				
				if button(vspr.layers[i].show and 16 or 24
				,3,y+2,8,7,"Layer Visibility",false,false,17,mx,my) then
					if vspr.layers[i].selected then
						--set selected layers visibility
						set_layers_visible(not vspr.layers[i].show)
					else
						--toggle this layer's visibility only
						undo_checkpoint()
						vspr.layers[i].show = not vspr.layers[i].show
						vspr.icon=nil
					end
					
					acceptclicks= false
				end
		
				fillx=14
				
			
				if button(32,self.width-32,y+2,7,7,"Edit Layer Name", false,false,17,mx,my) then
					--edit layer name
				--	begin_tinput(vspr.layers[i].name, vspr.layers[i], false)
					textinput.begin(vspr.layers[i],vspr.layers[i].name)
					
					acceptclicks= false				
				end
				if i>1 then
					if button(8,self.width-22,y+2,8,7,"Move Layer Down", false,false,17,mx,my) then
						move_layer_down(i)
						acceptclicks= false
					end
				end
				if i<#vspr.layers then
					if button(8,self.width-13,y+2,8,7,"Move Layer Up", false,true,17,mx,my) then
						--move up
						move_layer_up(i)
						acceptclicks= false
					end
				end
				
				if acceptclicks and clicked then
					select_layer(i,key("shift"),key("ctrl"))
					acceptclicks= false
				end
				
				--[[local t=readtext()
				t = t or "_"
				print(t,90,y+2,7)]]
				
			end
			
			
			if (vspr.layers[i].selected) then
				rect(2,y+1,self.width-3,y+10,2)
				line(1,y+2,1,y+9,2)
				line(self.width-2,y+2,self.width-2,y+9,2)
			end
			if (i==curr_layer) rectfill(1,y+1,2,y+10,6)
			
			
			
			fillp(vspr.layers[i].fill)
			rectfill(fillx,y+2,20,y+9,(vspr.layers[i].col_b<<8)+vspr.layers[i].col_a)
			fillp()
			if vspr.layers[i].outline>=0 then
				rect(fillx,y+2,20,y+9,vspr.layers[i].outline)
			end
	
			--if button(0,x+11,y-1,89,11,vspr.layers[i].name,false,false,16) then
			--	select_layer(i,key("shift"),key("ctrl"))
			--end
			local namestr = vspr.layers[i].name
			local namecol=7
			if (vspr.layers[i].name=="") namestr = "[ Layer "..tostr(i).." ]"
			if textinput.active and textinput.target==vspr.layers[i] then
				local x = print(textinput.s,24,y+2,7)
				if ((time()*5)\1)%4>0.5 then
					rectfill(x,y+2,x+4,y+9,9)
				end
			else
				print(namestr,24,y+2,7)
			end
			
			
		end
		
	
	end
	
	--output block
	btn_tolua = create_icon_button(panel, {x=5,y=189,width=bw,height=bh+1,sprite=42,bg=6})
	--btn_topico8 = create_icon_button(panel, {x=20,y=189,width=bw,height=bh+1,sprite=43,bg=6})
	

	btn_settings = create_icon_button(panel, {x=panelw-18,y=189,width=bw,height=bh+1,sprite=44,bg=6})
	btn_help = create_icon_button(panel, {x=panelw-31,y=189,width=bw,height=bh+1,sprite=45,bg=6})

	--btn_addsprite = create_icon_button(panel, {x=panelw-31,y=190,width=bw,height=bh,sprite=10,bg=6})
	--btn_delsprite = create_icon_button(panel, {x=panelw-18,y=190,width=bw,height=bh,sprite=18,bg=6})
	
	--sprite atlas block
	panel_atlas = panel:attach{x=5,y=204,width=panelw-10,height=50}
	function panel_atlas:draw()
		rectfill(0,0,self.width-1,self.height-1,0)
		if (atlas_content.height<=self.height) rectfill(self.width-8,0,self.width-1,self.height-1,5)
		--atlas_content.height = 260
	end
	atlas_content = panel_atlas:attach{x=0,y=0,width=panelw-18,height=30}
	layers_scroll = panel_atlas:attach_scrollbars({autohide=true})
	function atlas_content:draw(msg)
		acceptclicks = msg.has_pointer and not (display_help or display_settings)
		
		local trailingspritespaces=20
		local sprsheight = (flr((#vsprites+trailingspritespaces)/7))*16+5
		atlas_content.height = sprsheight
		atlas_content.y = min(max(atlas_content.y,panel_atlas.height-atlas_content.height),0)
	
		
		
		local mx,my=mx-self.parent.x-self.parent.parent.x, my-self.y-self.parent.y-self.parent.parent.y
		--circ(mx,my,10,8,9)
		
		
		
		
		local ax,ay = 1,1
		local selx,sely = 0,0
		--if (true) return
		for i=1,#vsprites+trailingspritespaces do
			if button(-1,ax,ay,15,15,"Sprite "..tostr(i-1),false,false,5,mx,my) then
				--select sprite to edit
				select_vsprite(i)
			end
			if i<=#vsprites and vsprites[i]!=nil then
				spr(get_spr_icon(vsprites[i]),ax,ay)
			end
			
			if i==curr_sprite then
				selx,sely=ax-1,ay-1
			end
			ax+=17
			if ax+16>atlas_content.width then
				ax = 1
				ay+=16
			end
		end
		--selection rectangle
		rect(selx,sely,selx+17,sely+17,7)
		rect(selx-1,sely-1,selx+18,sely+18,0)
	end
end

function create_icon_button(parent, b)
	b = parent:attach_button(b)
	function b:draw(msg) draw_spr_button(msg, self) end
	function b:tap(msg) tap_button(msg,self) end
	function b:hover(msg) hover_button(msg,self) end
	return b
end
function hover_button(msg,b)
	buttoninfo="Mouse Over!"
	
	--toolbar buttons
	if (b==btn_point) buttoninfo= "Point Tool "..scut("Point Tool")
	if (b==btn_rotate) buttoninfo= "Rotate Tool "..scut("Rotate Tool")
	if (b==btn_grab) buttoninfo= "Grab Tool "..scut("Grab Tool")
	if (b==btn_scale) buttoninfo= "Scale Tool "..scut("Scale Tool")
	if (b==btn_pan) buttoninfo= "Pan Tool "..scut("Pan")
	if (b==btn_pivot) buttoninfo= "Pivot: "..pivot_place
	if (b==btn_snap) buttoninfo= "Snapping "..scut("Snap")
	if (b==btn_snapmode) buttoninfo= "Snap mode: "..snapmode
	if (b==btn_undo) buttoninfo= "Undo"
	if (b==btn_redo) buttoninfo= "Redo"
	if (b==btn_info) buttoninfo= "Info Display "..scut("Toggle Info")
	if (b==btn_nightmode) buttoninfo= "Night Mode"
	if (b==btn_grid) buttoninfo= "Grid Display "..scut("Toggle Grid")
	if (b==btn_frameguide) buttoninfo= "Guide Frame"
	
	if (b==btn_zoomin) buttoninfo= "Zoom In "..scut("Zoom +")
	if (b==btn_resetview) buttoninfo= "Reset View "..scut("Reset View")
	if (b==btn_zoomout) buttoninfo= "Zoom Out "..scut("Zoom -")

	--panel buttons
	if (b==btn_pickcols) buttoninfo= "Layer Colors"
	if (b==btn_pickfill) buttoninfo= "Layer Fill"
	if (b==btn_layertype) then
		local triinfo = "Layer Type: Polygon (Strip)"
		if (get_curr_layer().type=="fan") then
			triinfo = "Layer Type: Polygon (Fan)"
		end
		if (get_curr_layer().type=="ear") then
			triinfo = "Layer Type: Polygon (Ear Clip)"
		end
		if (get_curr_layer().type=="line") then
			triinfo = "Layer Type: Line"
		end
		if (get_curr_layer().type=="line_closed") then
			triinfo = "Layer Type: Closed Line"
		end
		buttoninfo= triinfo
	end
	if (b==btn_outline) buttoninfo= "Layer Outline"
	
	if (b==btn_addlayer) buttoninfo= "Add Layer"
	if (b==btn_dellayer) buttoninfo= "Remove Layer"
	
	if (b==btn_tolua) buttoninfo= "Copy Sprite Lua (Picotron) "
	if (b==btn_topico8) buttoninfo= "Copy Sprite Lua (Pico-8) - Not Implemented"
	
	if (b==btn_settings) buttoninfo= "Veditor Settings"
	if (b==btn_help) buttoninfo= "Veditor Help"
end

function tap_button(msg,b)
	--toolbar buttons
	if (b==btn_point) pick_tool("point")
	if (b==btn_rotate) pick_tool("rotate")
	if (b==btn_scale) pick_tool("scale")
	if (b==btn_grab) pick_tool("grab")
	if (b==btn_pan) pick_tool("pan")
	
	if (b==btn_pivot) then
		if pivot_place=="Centroid" then
			set_pivot_mode("Origin")
		else
			set_pivot_mode("Centroid")
		end
	end
	
	if (b==btn_snap) then
		ve.passivesnapping = not ve.passivesnapping
		save_settings()
	end
	if (b==btn_snapmode) then
		if snapmode=="Pixel" then
			set_snap_mode("Point")
		elseif snapmode=="Point" then
			set_snap_mode("Edge")
		elseif snapmode=="Edge" then
			set_snap_mode("Grid")
		else
			set_snap_mode("Pixel")
		end
	end
	
	if (b==btn_undo) undo()
	if (b==btn_redo) redo()
	
	if (b==btn_info) toggle_info_display()
	if (b==btn_nightmode) toggle_night_mode()
	if (b==btn_grid) toggle_grid_display()
	if (b==btn_frameguide) toggle_frameguide_display()
	
	if (b==btn_zoomin) change_zoom(1)
	if (b==btn_zoomout) change_zoom(-1)
	
	--panel buttons
	if (b==btn_pickcols) then
		paneltopmode="cols"
	end
	if (b==btn_pickfill) then
		paneltopmode="fills"
	end
	if (b==btn_layertype) then
		paneltopmode="layertype"
	end
	--if (b==btn_outline) paneltopmode="outline"
	


	if (b==btn_addlayer) add_new_layer()
	if (b==btn_dellayer) del_sel_layer()
	
	if (b==btn_tolua) copy_spr_as_lua(vspr)
	
	--[[
	if (b==btn_addsprite) then
		create_vsprite()
		select_vsprite(#vsprites)
	end
	if (b==btn_delsprite) del_curr_vsprite()
	--]]
	if (b==btn_settings) show_settings()
	if (b==btn_help) show_help()
end

function draw_text_button(msg, b)
	local yy=draw_button_bg(msg,b)
	local labelw = print(b.label,1000,0)-1000
	print(b.label, ceil(b.width/2) - flr(labelw * 0.5), (b.height/2-3)+yy, 22)
end
function draw_spr_button(msg, b)
	local yy=draw_button_bg(msg,b)
	spr(b.sprite,1,yy+1)
	
	if b==btn_pickfill then
		if curr_layer>0 then
			fillp(vspr.layers[curr_layer].fill)
			rectfill(2,yy+3,9,7+yy,(5<<8)+7)
			fillp()
		end
	end
	
	if b==btn_pickcols then
		if curr_layer>0 then
			rectfill(2,yy+3,5,7+yy,vspr.layers[curr_layer].col_a)
			rectfill(6,yy+3,9,7+yy,vspr.layers[curr_layer].col_b)
			if vspr.layers[curr_layer].outline>=0 then
				rect(1,yy+2,10,8+yy,vspr.layers[curr_layer].outline)
			end
		end
	end
end
function draw_button_bg(msg,b)
	if msg.has_pointer then
		if msg.mb > 0 then
			--pressed
			line(1,1,b.width-2,1,7)
			rectfill(0,2,b.width-1,b.height-2,7)
			line(1,b.height-1,b.width-2,b.height-1,7)
			return 1
		else
			--hover
			line(1,0,b.width-2,0,b.bg)
			rectfill(0,1,b.width-1,b.height-2,b.bg)
			line(1,b.height-1,b.width-2,b.height-1,b.bg)
		end
	else
		if b.selected then
			rectfill(0,0,b.width-1,b.height-1,b.bg)
		end
	end
	
	return 0
end

function update_style_buttons()
	local trispr = 17
	if (get_curr_layer().type=="strip")	trispr = 3
	if (get_curr_layer().type=="fan")	trispr = 11
	if (get_curr_layer().type=="ear")	trispr = 19
	if (get_curr_layer().type=="line")	trispr = 4
	if (get_curr_layer().type=="line_closed")	trispr = 12
	btn_layertype.sprite = trispr
end

function pick_tool(t)
	if (panning or draggingpoint>0 or moving or scaling or rotating) return
	btn_point.selected = t=="point"
	btn_rotate.selected = t=="rotate"
	btn_scale.selected = t=="scale"
	btn_grab.selected = t=="grab"
	btn_pan.selected = t=="pan"
	tool=t
end
function set_pivot_mode(m)
	pivot_place=m
	btn_pivot.sprite = pivot_place=="Centroid" and 20 or 21
end
function set_snap_mode(m)
	snapmode = m
	if snapmode=="Pixel" then
		btn_snapmode.sprite = 35
	elseif snapmode=="Point" then
		btn_snapmode.sprite = 33
	elseif snapmode=="Edge" then
		btn_snapmode.sprite = 36
	else
		btn_snapmode.sprite = 34
	end
end
function toggle_info_display()
	showinfo = not showinfo
	btn_info.sprite = showinfo and 6 or 14
end
function toggle_night_mode()
	ve.nightmode = not ve.nightmode
	if ve.nightmode then
		ve.clearcolor = 0
		ve.gridcolor = 21
		ve.axiscolor = 6
	else
		ve.clearcolor = 7
		ve.gridcolor = 15
		ve.axiscolor = 29
	end
	save_settings()
	btn_nightmode.sprite = ve.nightmode and 23 or 31
end
function toggle_grid_display()
	showgrid = not showgrid
	btn_grid.sprite = showgrid and 5 or 13
end
function toggle_frameguide_display()
	ve.guide.show = not ve.guide.show
	btn_frameguide.sprite = ve.guide.show and 22 or 30
end





function button(s,x,y,w,h,infostr,fx,fy,c,mmx,mmy)
	fx = fx or false
	fy = fy or false
	spr(s,x+1,y+1,fx,fy)
	
	if (not acceptclicks) return false
	local mmx = mmx or mx
	local mmy = mmy or my
	local click = false
	if mmx>=x and mmx<=x+w and mmy>=y and mmy<=y+h and acceptclicks then
		buttoninfo = infostr	

		if (c==nil) c=6
		line(x+1,y,x+w-1,y,c)
		rectfill(x,y+1,x+w,y+h-1,c)
		line(x+1,y+h,x+w-1,y+h,c)
		spr(s,x+1,y+1,fx,fy)
		click = clicked
	end
	
	return click
end
function colbutton(c,x,y,w,h,mmx,mmy)
	
	rectfill(x,y,x+w,y+h,c)
	if curr_layer>0 then
		if c==vspr.layers[curr_layer].col_a then
			line(x,y,x+w,y,0)
			line(x,y,x,y+h,0)
			line(x+1,y+1,x+w-1,y+1,7)
			line(x+1,y+1,x+1,y+h-1,7)
		end
		if c==vspr.layers[curr_layer].col_b then
			line(x,y+h,x+w,y+h,0)
			line(x+w,y,x+w,y+h,0)
			line(x+1,y+h-1,x+w-1,y+h-1,7)
			line(x+w-1,y+1,x+w-1,y+h-1,7)
		end
		if c==vspr.layers[curr_layer].outline then
			fillp(0b1010010110100101)
			rect(x+2,y+2,x+w-2,y+h-2,7<<8)
			fillp()
		end
	end

	if (not acceptclicks) return
	local mmx = mmx or mx
	local mmy = mmy or my
	if mmx>=x and mmx<=x+w and mmy>=y and mmy<=y+h and acceptclicks then
		buttoninfo="Color: "..tostr(c)
		--buttoninfo..="\n[^+LMB]=A  [RMB]=B  "..scut("Set Canvas Color")..","..scut("Toggle Grid")..","..scut("Set Axis Color").."=Canvas,Grid,Axis"
		if clicked then
			if not key("shift") then
				if not key("ctrl") then
					--no modifiers, set colors a and b
					set_layer_colors(c,c)
				else
					--ctrl click, set outline colorset color b only
					set_layer_colors(nil,c)
				end
			else
				--shift click, set color a only
				set_layer_colors(c)
			end
		elseif clickedright then
			--right click, 
			
			set_layer_colors(nil,nil,c)
			
		elseif kbp("Set Canvas Color") then
			ve.clearcolor = c
		elseif kbp("Toggle Grid") then
			ve.gridcolor = c
			unpress_key("Toggle Grid")
		elseif kbp("Set Axis Color") then
			ve.axiscolor = c
		end
	end
	
end
function fillbutton(f,x,y,w,h,mmx,mmy)
	
	fillp(f)
	rectfill(x,y,x+w,y+h,(5<<8)+7)
	fillp()
	if curr_layer>0 and f==vspr.layers[curr_layer].fill then
		rect(x-1,y-1,x+w+1,y+h+1,8)
	end
	
	if (not acceptclicks) return
	local mmx = mmx or mx
	local mmy = mmy or my
	if curr_layer>0 then
		if mmx>=x and mmx<=x+w and mmy>=y and mmy<=y+h and acceptclicks then
			buttoninfo = "Fill: "..tostr(f)
			if (clicked) set_layer_fills(f)
		end
	end
end

function scut(s)
	return "["..get_keybind(s).."]"
end
:: help.lua
--[[pod_format="raw",created="2024-04-10 08:40:56",modified="2024-12-11 15:56:24",revision=1846]]

helptxt=nil

display_help=false
function show_help()
	unpress_key("Help")
	display_settings = false
	display_help = not display_help
	if display_help and helptxt==nil then
		helptxt = create_help_doc(fetch("./help/general.txt"))
	end
end

function generate_help_gui()
	help_gui = create_gui()
	helpmenu = help_gui:attach{ x=20, y=20, width=disp_w-40, height=disp_h-40 }
	function helpmenu:draw()
		draw_gui_box("Help", self.width,self.height)
	end
	btn_closehelp = helpmenu:attach_button({x=20,y=settingsmenu.height-20,width=40,label="Close"})
	function btn_closehelp:tap(msg)
		display_help=false
	end
	
	scrollarea_help = helpmenu:attach({x=80,y=14,width=350,height=200})
	scrollcontent_help = scrollarea_help:attach({x=0,y=0,width=350,height=150})
	scrollbar_help = scrollarea_help:attach_scrollbars({autohide=false, height=200})
	function scrollarea_help:draw(msg)
		rectfill(0,0,self.width-1,self.height-1,21)
		rect(0,0,self.width-1,self.height-1,6)
	end
	function scrollcontent_help:draw(msg)
		local xx,yy=10,10
		for i=1,#helptxt do
			
			if type(helptxt[i])!="userdata" then
				local linetxt = helptxt[i]
				local linecol = 7
				if sub(linetxt,1,1)=="`" then
					linecol=29
					linetxt = sub(linetxt,2)
				end
				xx,yy = print(linetxt,10,yy,linecol)
			else
				spr(helptxt[i],10,yy)
				yy+=helptxt[i]:height()+4
			end
		end
		self.height = max(yy,100)
	end

		create_help_button(14,"General","./help/general.txt")
	create_help_button(28,"Tools","./help/tools.txt")
	create_help_button(42,"Snapping","./help/snapping.txt")
	create_help_button(56,"Colors","./help/colors.txt")
	create_help_button(70,"Fills","./help/fills.txt")
	create_help_button(84,"Layers","./help/layers.txt")
	create_help_button(98,"VSprites","./help/vsprites.txt")
	create_help_button(112,"Settings","./help/settings.txt")
	create_help_button(126,".vgfx Usage","./help/usage.txt")
	create_help_button(140,".vgfx Files","./help/files.txt")
	create_help_button(164,"Shortcuts","./help/shortcuts.txt")
	help_buttons[1].selected=true
	
	--create_help_button(175,"old help","./help/old.txt")
	
end

help_buttons={}
function create_help_button(y,name,path)
	local btn_help = helpmenu:attach_button({x=10,y=y,width=70,label=name,selected=false})
	add(help_buttons, btn_help)
	function btn_help:tap(msg)
		helptxt = create_help_doc(fetch(path))
		for i=1,#help_buttons do
			help_buttons[i].selected=false
		end
		self.selected = true
		scrollcontent_help.y=0
	end
	function btn_help:draw(msg)
		local c,tc = 5,6
		if (self.selected or msg.has_pointer) c,tc=6,5
		rectfill(0,0,self.width-1,self.height-1,c)
		print(self.label,3,3,tc)
	end
end

function create_help_doc(txt)
	if (txt==nil) return {"Couldn't load documentation :("}
	local lines=split(txt,"\n")
	
	for i=1,#lines do
		--check for gfx images to unpack
		if sub(lines[i],1,7) == "--[[pod" then
			local unpacked = unpod(lines[i])
			if (type(unpacked) == "userdata") then
				lines[i] = unpacked
			else
				unpacked = lines[i]
			end
		end
		--check for strings to replace (shortcut controls)
		if type(lines[i])=="string" then
			for match in string.gmatch(lines[i], "key%[.-%]") do
				local k = sub(match,5,#match-1)
				lines[i] = lines[i]:gsub("key%[.-%]", scut(k))
			end
		end
	end


	return lines
end
:: input.lua
--[[pod_format="raw",created="2024-04-09 11:32:00",modified="2024-12-11 15:56:24",revision=2024]]

textinput = {
	actvie=false,
	numbersonly=false,
	s="",
	target=nil,
	begin = function(tgt, t, numsonly)
		readtext(true)--clear pre-existing text from the queue
		textinput.active=true
		t = t or ""
		textinput.s=t
		textinput.numbersonly = numsonly
		textinput.target=tgt
	end,
	update = function()
		local s_in=readtext()
		if (s_in) textinput.s..=s_in
		if (kbp("Backspace")) textinput.s = sub(textinput.s,1,#textinput.s-1)
		if kbp("Enter") or kbp("return") then
			--apply now
			textinput.active=false
			for i=1,#vspr.layers do
				if textinput.target == vspr.layers[i] then
					vspr.layers[i].name = textinput.s
				end
			end
		end
		if clicked or clickeright then
			textinput.active=false
		end
		--print(textinput.s.."_",50,50,8)
	end
}

mx,my,mb,mwheelx,mwheel=0,0,0,0,0
mb_last=0
clicked=false
clickedright=false

--having input cached from _update prevents them being missed when checked
--in _draw during low framerates
function update_input()
	local wheely=0
	mx,my,mb,mwheelx,wheely = mouse()
	mwheel+=wheely
	
	if (mb_last!=mb and mb==1) clicked = true
	if (mb_last!=mb and mb==2) clickedright = true
	
	mb_last = mb
	
	for i=1,#keybinds do
		if (key(keybinds[i][2])) keybinds[i][3]=true
		if (keyp(keybinds[i][2])) keybinds[i][4]=true
	end
end

function clear_inputs()
	clicked = false
	clickedright = false
	mwheel = 0
	
	for i=1,#keybinds do
		keybinds[i][3]=false
		keybinds[i][4]=false
	end
end

keybinds={--{Name, Key, key(), keyp()}
{"Enter", "enter", false, false},
{"Backspace", "backspace", false, false},
{"To Lua", "e", false, false},
{"Point Tool", "p", false, false},
{"Grab Tool", "g", false, false},
{"Rotate Tool", "r", false, false},
{"Scale Tool", "s", false, false},
{"Axis X", "x", false, false},
{"Axis Y", "y", false, false},
{"Up", "up", false, false},
{"Down", "down", false, false},
{"Left", "left", false, false},
{"Right", "right", false, false},
{"Zoom +", "=", false, false},
{"Zoom -", "-", false, false},
{"Reset View", "0", false, false},
{"Toggle Panel", "tab", false, false},
{"Toggle Grid", "l", false, false},
{"Wireframe", "w", false, false},
{"Toggle Info", "i", false, false},
{"Pan", "space", false, false},
{"Snap", "ctrl", false, false},
{"Set Canvas Color", "c", false, false},
--{"Set Grid Color", "l", false, false},
{"Set Axis Color", "o", false, false},
{"Help", "f1", false, false},
{"Flip Horizontal", "f", false, false},
{"Flip Vertical", "v", false, false},
{"Prev Sprite", ",", false, false},
{"Next Sprite", ".", false, false},
{"Subdivide 1", "1", false, false},
{"Subdivide 2", "2", false, false},
{"Subdivide 3", "3", false, false},
{"Subdivide 4", "4", false, false},
{"Subdivide 5", "5", false, false},
{"Subdivide 6", "6", false, false},
{"Subdivide 7", "7", false, false},
{"Subdivide 8", "8", false, false},
{"Subdivide 9", "9", false, false},

}
function kb(n,p)
	local off=0
	if (p==true) off=1
	for i=1,#keybinds do
		if keybinds[i][1]==n then
			return keybinds[i][3+off]
		end
	end
	return false
end
function kbp(n)
	return kb(n,true)
end
function get_keybind(n)
	for i=1,#keybinds do
		if (n==keybinds[i][1]) return keybinds[i][2]
	end
	return "??"
end
function unpress_key(n)
	for i=1,#keybinds do
		if n==keybinds[i][1] then
			keybinds[i][3]=false
			keybinds[i][4]=false
		end
	end
end
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAYAAABRmsRnAABaD0lEQVR4Ae2dIZSrPBCF7_55
IhKJREZWIpHISCQSWYmsRK5EIpFIJBJZGYlEIhFP-H_XhaUtUCB0t32de8pJCblDEjLz2be6Kv_C
RCKRSCTSj_rPI05ql2r-1CYf7ar7b3jZqhhFaNFpJZFIpH8dwGOQ_AkIrIVvC7mt4L1lvF2q4WhX
q_HbfhOCMIlEGqvXbX24vJ-jHfKvrflr-GuZc6umLpl-W2OX1Nq2ti99NglgFQhMbci9AHK0qw6U
-f9bxCORSKRngW-7-1Srl4BE9f1b1PhL7y24bq2l8J0C7Vx_DAJ4aCPayS3dxJ-U5SbMgXTfM7Zp
WwOeRCKRSL_vIaZd9k0xreVBH8JDbFkE4P4E2pfPge_tcfeEc7sRcxY9Btah9idhW4TW7H0mkUik
e8NobR17Ng3Neel_LOXPKIAvYbBkQ39r87cCZbuJ-Xj9jb0XkNt9IwiTSKSfhs9lzVlbh-qetSxY
8t5HgH2fF207F8SjAG43YejDrN28R9ysORvV91zCeSsZXkbwJZFILyXVenfLf2-mTDFkDl8GAawC
gt_AbH_hfThewnIInn2wPvthJJFIr6W2Vp_utva2dWRuLR6qO79Zi9Yw5NKzdP6q6_2zZQlLBgH8
WyBVhfBU39Dz-mZNjZ0Th0QikR4BWEtqt2qdf1T-3LhbcG6XalfQncuJUQC-igioJBKJRFqjPnjH
-k8C2HXdq05v78_eQPgRbAvEf-RDuTFgqcZwIzrxJBKJ9I-ofc4gx-vorqXKJOuuNV4zrBd527Fj
7ZoYW2konmsv39N7SuV7-dT7jCPrLtK-I2-vd-_jKBrsv3e9_enzTyIA34RvETndNRfC7SEubKe7
lkLQzyoA_GzneDPJYCfRZDsnRpGHZ_29krGF770hHLsMKTTE7vQ62nUGLv8RGJ-2GDsH2iEGdvPO
h3Fk8EoHB_HAK52nhLBt7q7u5-Q9uqIoQhRF4Ia4utpnt_Dr7f3R-3PqjXaIu2vu2e3G7ZzPdRR5
2OU_ifRrAG5ha7jxWXsLwi14T4fZSOPumgvhDgSW1l39-jFZvEYq3K49zbXfWrxeB7Bwv3kydvD9
aArLvSCcSYZMNOvORH1zHYHL4Xh7BC5HkYcdjO8GXyFQJQk0IW5CuIWv7gFliM-22SA8BNo0PyLN
j92zob4t33lPBYcE-kFcXcEhmfSFH0HXjv2-Je0Qozo4qA5N7dEOTb2apS-4ftYs04NherNqDol0
FwA73geKqHcov_B7elhEziSEW-i2rcVrWLyeBeFMMvhZ1d1f-r-ltZOoG2Mn0ed9_39JMt0LPJfw
LfJwcwjHbrPO2GWoOYMQ2mdBatsp_ZFEHH7AjyQM04MfybvtgyYEzF0NHGNUyXSB7qsMgVCPAVOH
3tTJp1GaH2dDst839v_R1MLXdd2raw6E16rN6xa8-f-aIb5ZMzr4HpsaV_QhijwkOpDurj_3BhSR
A8ONz9pbMtJvWFu8Hn02CIAB_PpZhcBq4OFnFXJvOKEsXiMV7nexE24H4FS4V3MZS_TPeZr23UAc
pXu49geifQDD9BDtg65-S-ieakrlNmvWIgYmp9dv8RqZZHC8PfzIu7lfqgXT3NXIj197foy-C_EN
hfrXGcpLwNSBBDCODMXuPvOdC8wxuM6JlebHK8j2_9rYbf-SOV7GeTRFUZOnZhQhP8rPM_ztfZi7
Jv-MKILrfuf2vdSC1zC95jx_Qflm3iUp0YR0U45ouDIbwIbbHMB_OwfChe2cwTaTDIX97XOLJuEu
FVhaB972fwvftm8MDJlkHXBb6LZAtpNoEsKf88tDxOEH8qPsEr8F8T0hvBV8T2uurfCsUEVRBGEK
5NyYD-Hw48y-ZeHLJIN2iDv4mrsa_aE5J9Xh9rkK9RgH8TXO1D8hfAj2TZvEPwbhLUE2FGuobwl8
10L7t_S6Lry9j-CjyQczihB_BAi-QNz2k2bkr9ipQSI5oj546hOxLfUY5jAnlijfIkcNphwjKJKr
vlEAx_EehvtdiIvIOYNwHI4Dw_I1jDS_gnC-z2r4Nui9BO4c_J5tlnDPQGzxehK_3ZxND0UeIj-K
H0mUDsIbwff0kVnmIet9Z5Z5QKADaNauRaz7PyY-_l5-HH4gipq93ALEp33ODg6QRDC-YGnumu-T
Ph9TsathHBkOSdxAt4Uw8KPw-Q31IfqoQPUPAsEh6c7LWfE5JPAPAq57XYQ2OVOSQTvEqA5Oc84P
Td2pDs7NvM_OMbBrfGc6xrPqzdaqq3L9NzDVoCeiFNCanCLdX2_OsP9ednp7v-vveB8oou-DeQnf
8CMYDZ5JhsLueb9gPOdQZ5LBz6pF8M0kOwNvC_J_OydGkYef72xB7HgfmyRiJtmPJHTssu5-A1zA
xvderin_jtd88y0g3N9nr2Sz4NuXcWzWdAj2gM1x2HlPA1-b3H2fzx5Q_-djfY_uFrzB4Rqy-kFM
np9_zTnlnLnjXf7NrTV98LbwnXOuWm_b94bpnQF6Vs4l6aYAVgGpyb-zfw2AmaajPnzvwfrDvn4N
34v5rudrlW-wTVJj-Z52DCsSOMI_6-tz82CFexjux9n9XFm87qC75DC3YwNLg59Vs_Dbetpi3r-v
t7Pm3EvApfOeA55b71eVE-VjqMdrIPB9BrbQ5T4vWXexqz8hfPA-AL_5fxYNAXVu36NrDK7Ns2so
X8LV2-sdZM0o6v73_2-lTfYF3SVnqh239jySSGt1E8BLobslUCxeI-fYYnAP3avE2BI6z6p7AEFl
P54JuqR56kO2D-Nb8N2y3pBIPwrgOEmvOitZIZX56qA2N8lPfvKT-5-1O8ImepCU9QbgL20DifSt
LMtgWRZtBGk2gOMk3Sx2XZXwzfXnz_RstVdEKZimoz546guxN8ghM1IOkW-wTVJj-Z62Cork6ty8
D_4bN9X2nfzkf2J-4Pm0f_R-aokoXXWRflZvAP7SNpBI38qyDJZl0UaQRuUI__w_TraD155zJf_H
lMpzqA_e_kLsDXLIjJRD5Bt8k9RgyjGCIrk6N38G942bSOX6aZOf-M-sDzxfre7Q-r_k3_amcpHW
uIZSMUbkCnVomeegWMVOztXJF_vq88hVdxQwQvWlBEiu_t7bQ9NvU5mf3S9tyU-_Z-b7YUD7R-7J
cSTSFnoD8Peysz2Ea0V_8pOf-P_y3xH22X2cpJvAWeOacgzb3CnHMMzz9a2RuePqhEqleoy8VA5R
hurTMGrn6twMAphEemVlWQbLsmgjSARgAvBdAfw__AEVDxL5yf-M-sDzaf-ITyLdXW8A-tI2kEjf
yrIMlmXRRpBG5Qj77D5O0k3ArXFNOYZt7pRjGOb5_tbI3HH1jU6leoy8VA5RhurTMGrn6ty8D35A
xYNEfvI-sz-wfNo-8pNId9cbgL_0DSTSt7Isg2VZtBGkUTnCPruPk3QTcGtcU45hmzvlGIZ5vr41
MndcfaNTqR4jL5VDlKH6NIzauTo374MfUPEgkZ-8z_wPPJ-2j-wk0t31BuAvbQOJ9K0sy2BZFm0E
aVSOsM-u4ySFzoV64J2jHKK0a_UYnKnPw9ypz8PJSuUYucyUY1RSfS0f6f7q3LwPDbS5qfQi8pP-
mf2B59P_kZ9EurveAPylbSCRvpVlGSzLoo0gjcoR9tl9nKTQuVAPvHOUQ5R2rRyDM-V5mDv1eThZ
qRwjl5lyjEqqr_Uj3V_dm-ehgTY3lV5EfvI-sz-wfNo-8pNId9cbgL_0DSTSt7Isg2VZtBGkUTnC
PruPkxQ6F_qBd45yiNKulWNwpj4Pc6c_DycrlWPkMlOOUUn1tXyk_6tz8z400Oam0ovIT-5n9gee
T-tHfhLp7noD8Je2gUT6VpZlsCyLNoI0KkfYZ-dxkkLnQj3wzlEOUdq1cgzO1Odh7tTn4WSlcoxc
ZsoxKqm_lo90f3Vu3ocG2txUehH5yf-M-sDzaf-ITyLdXe-tYeu3qczP7pe25Cf-M-v9MKD9I--k
OBJpC70B_HvZ2R7CtSI-_clP-n-Z7wj77D5OUmjCUS7I1a5Wr_q7DciwK5RDfDBNOYYH9XkgVY9R
rT9OnfTw_twMAphEemVlWQbLsmgjSARgAvBdAfw_NNDmptKLyE-_Z-YHnk-7R34S6e56A-CXtoH0
KqphgyGdHJNlGSzLos0ijcoR9tl9nKTQhKMct9rV6pPbbbDAXaEc4oNpyjE8qM8DqXqMKlefhh5e
n5v3oYE2N5VeRH7y-5S-hr3oGvJcKvB82n-yk0h31xuAv7QNpEfQEAx-Q3nmw7Is_iCkUTni-KzG
SQpNOMpxq12tPrndBgvcFcohPpimHMOD_jyQqseocvVp6OH1uXkfGmhzU_lF5Cf-b8C38tJNiqtp
Bahhr54Tff-X9pNIc-UG4C9tA_m3tAV4LyGshfZVu5UYtoE86bnliPMzFScpNOGon99drT653QYL
3BXKIT6YphzDg-o8kKrHqHL1aejh9bl5Hxpoc1PpReQn-xzw-hR8K6_B5mW7Ru28p_ZP3-_1-STS
XL0B_EvbQPpJbQ3euRCe064Vw3qok55Pjjg-K3FC35_0-Nz8GRpkcxOpzFe-hPzb_HUuUMrkn1n-
PcG7BXy3gjOd39fzXxZWEmmO3gD8pW14PLXwrasShukBwCoYP4LuDd6fgPAcMaR0cF9EBFzSFnof
6rS5qRSU-Or_Fr75USIO94vg_0jr-0n4ArgLfCtvHljbtdL5fW0-iTRXbwD_0jY8pnQuEId7WJb1
dHP-afC2ugd8__0tMcyDNem55YjfOd_kf0t-hjptbiKV_eqg5FfzO8KGLgvE-xNlDXwfYf2Qv3Og
fxO_AFDDhuAVnf8X9sdJuhrev_Ulje-jPfft3ebmd9HsHb6h-rkt_df5HWF38DU5gwOJWOyw5xx1
VT7V_gWvfiV57gXfypsubn3R_f-3-VPFe8-52RWL3fk1Aso4SeEIG3VVjrZTXpub3eXKCq6szvpu
AZrUUyKa6856A-D3srM9hGtF-uV_R9gQKJHLGiZnV20CfXYCPcr6a9i-kzxVBGju3WA8Rwzrix3l
z_P7HTF8DloA92Vydu5NjoP_OElRVyVc10UURYNtC_kxALcqDlnz7l2N8mt8KvPReZOaPTwDMACI
ZPKb36rJt-Z7EMCkn1ObcFPwbVsRpWCa-jxruzeAcxfgFiCz4fYOEJ4rFQCTHl-3ArAj7FH4RlEE
pumzAKwnKaI8gWsKAvASALfgvZRIRvd9rM4xNN9zSu9Dnf0PuUbkv_2vq-Lz8k1rFnxzWb-M-nVw
raLp9hK6hn9_X0Wbwrfy5kN1LCnp-L-I_V2pKfi6rjs-fY4MrimQHuafWdLP6w3AX9qGn1VdlUhc
exZ0L9uSG4iT50gqFQihis5hOtYaPsByoDav2yJoxmnuphDWwnnrYqDi96-KEcNnIE5S7Dk-6zM5
O-cmx0F-nKRwhD0JYabpo16bm929nqRIDyl2x4_uL5X56LxJzR52SkTTimTym9_qxbf2exDANjeR
ynz1Qsg-7G_Tay18Tc4gohRM059m-ashnLu34cutL9I30GWajroqryBcRc6Pw1cFwpQ-j__fKqwq
Rfm3vKSLfewB_J77Nghg0vZyhA1dFquge9km0G8m26PoEsB55sO0gtvGKloM3_6dfQgDgMyeDsKk
x89n0j8M4B-61u9DnTY3lYKS-9vvCHtT_Oayftr9yzP-rJ2U5k7DV2aD8AXQ3LO8ef41XnPjzeBb
efcFKuXPc-tJz622ZrfXPfUG4C9t_bbSuUApEzjChkA5G64dqGaMD-LsCjyPqBrfB-gSvKYVTJvz
GRA2-EEI16XRQBg4G19FziYQXiqG_0Kb9PNFmkRS1ftQp81NpaCv7M_yrPu-FL5iZ84e77ru0_-f
JZCvdAu_3GogW5uoqxJ1aXTtEHzBLWhurAzfyrsvTCn-nttPIs3VG4C-tA3bqIWvueNgmo4954vg
mxxziJ0JP85m_USUgmn6w_9LDfsmbE0rGCC0exvCht9BuGuLYNqnuZtAWAvtRfvAcF9wk35Ojlj2
7UmkIf0Z6rS5iVTmq4O_ol-nAo73gSIPwTQdOhcweXETormsEThWB9-kmM_Cby5rCAB7zvEh5dPv
X575sCwLNXqF7RZ8uQXIAOBooGvMgK-MgCqCtgGE7yXKv_f0x0lKRHlhHfbh5HNZJFd9bwD_0tZt
K50LfKyEb9sCmOUvufEUiZ9l2axxlmXB5iYSqQG5OxPCK9tfgDADFel-QY64-vYEYALwSZbg57Uv
kaMA-jMUyOYmUtlAYI1e3V-kIXzTuglPk7NB_IqdCT-OZvlFFEG4Npzk_E-sXwtq4flITaeBcZ7c
B8JVBG0FhAGsgi-lz2v4dS6IRi_kUn6D9RK_bV8L4Uu9AfhLW7i9HGFDl8UkPP9n9SB8l0I4gY44
SR92L1qoLpFlWV0h7LebwHgBdO8lhsf9XqR5_X2pNgf7AN6hvDrDS9p_rCIPr95pmN7g-NqxY89J
2wP4sA8HAXxSlkjI4hvUrd6HBtvcVJoQ_U1EUXQTnlPwTY75LPjmsoZAiboq-5n9a2MMFaSfgC_A
u8IXAGqMx6f8ef7z20oFvpfzMEyvA2r--5AIvM_h9-Yj99v_x1-Tkj_HMAUS6KPQDBxrEr5i18Sb
C_EhcD3S-i2VHwaDBYmZzl3g_xPQHYIw5c9z_pfAXAXCc1XkIYo8XDSmvb-lI91PbwD_jh2atSJ-
43eEDV0Wg9D8--xPwrdt-TibDeGSG4iT9OH2L8uyVXEsyxotTHUer4bvI4ohpfx5Ir8jrs9RnDTf
UOei6ytlogThI-RBkBqmNwrZ9tmt-2PPSctUyuTzz2EfwhJ8cEyWSMiiGdfXn6HBKoeX-N-_KIqQ
uPZq_CbHHIFjzYawiCLEmv5Q_7cWvv1CONQy05kPYc393POl8M0BmD_UxDXsDsKUP8-tn3uG57R9
mE_pyEMi4RPqfezQqB468gNM05FAXw3ftp0D31zWSFwbjrCffv9a_WFwE8Jz4btEB4N9wjf9atv7
tr0nhCl-nt9-CXMVCM_Fr2F6MEyPiPZkegPwl7bhfnKEDV0WyhAGMAvCJTcQJ_nDrD-LMiW-ZVk3
C1Wdx8rwPcHVLupP6K5tD0W9yZ4xPM73I43n9aXavNO56Pp2KJUg3I91CdzLvlbts7Zv6n7oP2mZ
Spk0NWQfwhJ8uA4mErJoxvX1PjTY5qbShMj-7Y_TFEGenUFyKXzFzpwFX5OzT9jXVfnU_3cJ8FuF
ipnOKvieoJtvBF_7qM-ite0a1bBR47rAU-493-lVge-YPIZAaZhed132Td1PxSTdX28A-tI23FeO
sCFQdpD8-7yvgrAfZ7MgnEBHnKQPsfYsy1Z7A89fVLDqPJ4F3xxQhq1Keyjq2XvA8BjfkXSd05dq
c07ngjbohVTK5PPPYR-CEny4DiYSsmjG9fVnaHBb0NaK-Of_OEkRVSXg2t_QXAjf5JjPgm8uawhe
IqpKME1-yv1bA1_bm5PwfRTomgvgCwA17MUQpvz7XX9bkEmkW3oD8Je24f6qqxK_aXWQDBxrFYQB
zIJwkGerAbylsiz7Efi2bSK1s1iHX4TuqTU32selECbdV46wr-rihL7RK_uwD2EJPlwHEwlZJFf9
f4YGtwVtrch-7XddF6IHyTXwbdtb8DU5g29acIS9qihsuX7LshZBeCl8a9iABNC1jwFds6g3Te4a
TcGfA2LKv9-161wQjV5IpbwG61y9AfhLW-gzqqsSiWt3kASwCsJ_nM2CsIhSME3-9XXPBfAc_CZS
G-XnwK9C96c0B8Kk_8oR9lVfnDTfpQ-gwtEX53e-3UvjO1Yedv8N07vLuoo8nBW7P27s-9z47br6
-WviLJn-PQB82IewBB_ugYmELK5B-T402OZq5YT84-4_JNcmZeBYN_GbyxqJaw8Wikfcv8DzofFz
uPbhC_AKvgeD4fSkbX8Duocfhi8A1Jj_ppR-v_vvSwW_Ync9D8P0Pq8_jB9Ja_A35PlpiP6W3gD8
fYmVPogcYUOXBUzO8P85W52clzAfa0tuIE7SX11zlmU3x4QfASpZdbCdA56fhu6hqB-uPDH87rd9
5Ty_VJtnOhddX_HoShDeS_M7Vh52YGr-99s_uMbuL_F22T827lJjc1kb-zLemjj9vp_EeCmTzz_H
fQhL8OEamEjIohnX1-vQYJubShMi-7g-iqIOjv_zaXVyArgJX5OzT9jXVfmr67cs66ankhU0ri16
-0-B9zSbLeF7MNhmsWpcg4Dy73f9fanAt83zS-D1YdWHV7_vvb8EVb_v77vlHYPwFLCH5jUn-to4
7fOhsY_qQQCnMlcKSv5xP9N0JNA7SKok5y34tq3ruojF7lfXfwvCGtdQyWrR_38CutuV4h6Av2B_
WuXBYGftFhCm-Ptdf18q_Z0cr_cxBtZbcLyHngl0TwVgm6uVHfLf9rdwVEnOwLFmQVighIjSX1--
EIQDz0f4EaCSFTSujfovIZMDTwXdIZnA1TzWQrmG3e0R5d-v_vtSyW_xWzePE3wfAY6nOZzmUuTh
Q8R5SAC3h63fpjI-u1-akn-aH0VRB0fVJL0F37ZNXBuOsH99-YHnd9ANPB8a1zr4VrIa9V-qWaE7
B8JzoNxvL_FB_Xd--1ypwDc5nr7wNVxbwKoCqz9uC7i1MfqxTu_YmuuUf02cZ4P1G4C-l53tIVwr
8t-2O8KGQIlc1ggcSzlJ50C45AbiJH2Y-XOEfQbftgVw5a9hn93nChD_Ldje0gmqW6xH8Iry7wfy
91JtbulcdH0fvFCCsBGXTwGSW1CdC_F7x7mHSpk0_bsPYQk_OCZLJGTRjLsJYNL95QgbuixgctYU
TYUk9ePsJnzbNsgzME1-qH24hHBbyKYAvBZWqcFwKOqHPhs5oARhhuv9I21-bucAmPTvSwXAf4YG
29xEKvPVEyL-bX_cpKirEr5pweRsNXyTY47AsWZD2HXdh9q-tmjZMDsIX-ov4XuC1L8KXwANTBeu
y_yti-Lvd-1tQSaRbukNwF-aht_RI2wIlMhljcCxlCAM4CZ821ZEKZimP_yetFCeAvBhBXxPrflk
Z2TuOi-XxXC_h6Ttz_mlLs8t6bV02IewBB98liUSskiu_v8MDba5iVQ2RX2NyD-f30JRBb5tOwe_
uawhHnj-4iSd5V8D39RgMIv6uZK6qGdBGAMQpvz7eX_WZf_XWyB1P4hIL6JgAKxz9QbgL23h76mu
SvimBZMzAFCCsB9nsyFccgNxkj7_-sC_6suBVfA9wexZNQfC-fUxPP63fWY54vpcxknaAdjxGgB-
8GJWPo61MXgXv8jD7r9hendZV5GHd4v9L8r9SrmgSHDYh7DE9-fqK0sk5ACo34cG29xUmhT55-td
1_2STQW_yTFH4FizkzuKoqfdvzXwtRXhy4oSLHJ_D8AL11fjGhCUfz-j70sFviZnV-EM0-u8_jAm
Pa-eAPylbfhd1VWJxG0KpiqElyR9Ah1xkj723gyAJF8BYdWSyooSiAzALVAb_q-sxZx199fJ8Njf
9pnliOtzGScpsixrnnsfn-n8wQslCMfgXfwiD2GY3tn-ftsCun0_dN-vG_ofG0calls3bVAkOOxD
WOL7e-WVJRKySK7634cG21ytXJF-uT_XtTJ8xa5579zkftb9Wwrf1GBK8zE4A7L9rye7Cdx1nZS-
2-gv83otfM3TubvQCbh9EPdh3O9r7y_B2u-r_255SfOVJfLsmtKfwQInc6UJkH_Zn2k6HGHDjzME
jqUM4eSYz0zyAnVVgmn6w_4fQ4oa9tnzQ1HjsAC_p-G3VHkptPD8PaPf68BQH27HvBeEMbHevmrY
YEgp-37Yf-a9FOCby_sz1oKyD_E_PPtQJv2OLMFnj30f6rS5qTQB8i-3R1EEk7NN4Ct25uwkd133
KffvMBO_l1BShW8H4aLECYhh_fMgnlrvFuig-FXz96UCX5OzVe9s4TwEZtL9lSXy7JrSG4C-tGW-
r7oq4ZtWl3SqEF6S-CJKwTT9cfcGw3DMb8Do1N4qpS18xyBscAbsHJT2F2itDyAyALcAIgO1d0QI
A56_rliu1WFi3Yfia64AGFJKrjvIEddnJU5SZFnWPPc_PvP4gxdKEI7Bz8DancsvuLawHYJwf2x-
3OX-OeNIw3K-Ui0oEhz2ISzx-b0uoSyL5Kr-fWiwzW_VrWmRf7mfaTpKbiCXtTJ8xc5clOTPun8m
MAnfE4yWwLfylsOK1dpnwQ3L6328p6bW3VeNa1BQ-t3X35cKfE1_fn5PgGyvSxBf6nLsmGfuONJ9
9AbgL23DY6iuSiRuUzC3gLAfZ7OTveQG4mQ5gH5sbyZAkv8PwCEYHS5gNBfCWvj9LoMzYOegtL9i
WR9AZABu0bUfTIOHAiEMePo09LfU2LpPbR8hDI-7XZ9Vjrg_j3GSIsuyz-Oauh_0SS_ioEg_-xz2
ISzBB8dkiYT8GtfXn6HBNjeRynz1hMi-zs80HY6wIVAqwzc55rPha3IGEUUQrg0nOT7d-o1BaAv4
lr6AvoBfYVn-GITH1p0aDOaM9VP_be_3LIuIRJqtd5ub3aHrH76h-rkt_df7ASCXtTJ8xc6cDd9c
1khcGwn0h92-yYI5AKFbrjH4Vt4C2n5pH2rdfw8FUMofSd7DCHztC-jWsCn-NvaTSFvoDcDfq4L2
dQjXivxq-roq4ZsWAsdShrAfZ7MhXHIDuiwgoT3c-tWwx0E0AKHDBYTmwrffGpyh9AX0lKG0v_JZ
H0C2b9rIANwCiAx8eFUH4BBGA2Kd3z2Bc2AUwn1UMKSUfxv6HXF9HuOk2WOdCyLLC6mUSVOH9iEs
MZzzWSIhi2bcTQCTfleOsCFQnr6pEnyTY1NE5sC3bYM8A9P0h9yXMQhfQmgr_GLnoLTrWQCGW_CD
ad8ATjPANn4Vwv19WAJg0rwcnQPgQjbfoD1Xl_fw1r3B2XesPDx7n2F6i_Zc5OGZ5-J_jbaI8coA
fh8abHNTaULkV-O30FSFr9iZi_BrcgbftAaLyyPv3yV8VOFbeethFcL4WsRXW8q7F4Ah_F7uQ435
35TyVz1-7yXD9Lrrt1Xk4UuDdwu9AfhL2-B4qqsSvmkhcCxlCPtxtgjCIkrBNP2h9sM3BA4jcM17
ELpVOufAd5cJlL6AnjKUdt21n7I_gGzftJEBuMVZW3tHhDDgoWjaNGtgrPO77s9hBML9-WBIKbE2
kiPsq744afZX56LrO1oJtPB7bHvO5t4bnJ0Bbwi8LQj7zy77LmF5gni-75a3P-5y7NCcXkmlTJoc
3IewxHCeZ4mELJpxfb0PDbb5rTI2LfKr_13XhcmZMnyTY74Ivrmskbj2YIH5rf3z-4dv9F2HrtSH
jip8_8VPRSGMr8V8tXfWEHxv7Qfl333899QJeH1wtgAcAuoQNNv_sXFj8fr9pO00COBU5kpBya-u
j5MUIkqV4St25iL4tu2j7F8LX-f-KRl8GCgtbA7F_LznwrfyUqW5s1oDAHgozh9EanFvyRyBcF81
bMq-H-D3pYXNnrfnaun9pYYgeAnlsb61kO8DnPQDALa5qRSU-Nv5-ThThnDgWIshrMsCdVX_6vr7
8G3bS_XAIGzWwneXCWDnzJuoIW4OCWEghNHclPLHIbwGJZR-av6fVgvlFpIngA6Bem080v30Z6gz
lWvSlvxb_5mmwxG2Enzbdgl829Z13V9b-xB8T_3hcmwPNuYAhJfAVwttgI-PS08ZSuv2-PehBu_r
dnkoGgDbXxCOUsC175bQ-f2Y2hfKv-v5h86fFjbffOn9HFgWeXgFz37f0NgxuA7FG1M7rgU_abne
hzptbioFJf92-iiKPhNTFcJL4ZvLGgIl6qr8lfUPwdcd4EgLmcMG8K28dLPECvEF3N5911fKszlu
qcMFfO2ixsFg3fMatws75Z_a-16agmZ7TfX1_y-jTXmXvJe0AYBTmSsFJf_2-lzWSvBNjjkCx1oF
4d9a-xB8o2_OfI-9gswW8N1lAqUvpieX7WetwUMxeY_oAa8W3gbiYoAMQJjy7_f8fe0yAYOz7lp6
T-q39WcwgbmpdAjJv52faTocYSvBt22XwtfkDL5pwRE24qQBxk_tP-q-FA5BeAg25kCMpfDVQhvg
2yUWqzV8MCCEcdYf2tY3jEsJ6M1LuzlsIPPUXEDYXABhyj81fykTIgtplt6HOlUOH-m390dR9Fmk
VSG8FL5t277-J9c-BN_IjcBmQEvhW3np7Pnp6cVEDDE6toNt7-4MylHz3q3g2_1hD752UeNgfM_5
xvS7KP-U-CTSXP0Z6rS5qXQIyb_tn2k6HGEj2hlKEA4cC36cLYYwXBuOsBEn8yClun7fEIPwdet5
-jXw1UIbRy-BLgCwczZJrn2owfOa-2fQBQC7d19KQOdnc1fV4Qu6fQhT-v2MX_eCyPJCKmWyLYBV
Dh-57_dXgW-bLoVvB_GGDz_y-jH4ntrDneDbgW-uOrP9ojV5KK4hfLboFHDtDr5bgLgP39RgMGdC
mPJPzd9X4SeAbQBpsao1rN13rDw8i22Y3rK55OGZ5-J_8dq_5qMS49X1Ppi43FRLfPJv7o_TFCJK
lSG8Br4mZ9Blgboqf2T9Y-At5DRAVOFbeWnzjmO8WYKxWju770M4hNEU21al3DS5zQsIH4z-N-FL
NcbhTvmn5j8P1vu_a_4vZJhed-2mWnifrhbEpBUAbg9bv01lfna-tCX-ffyu6yrBNznmq_Dbtq7r
Iha7u69-CL7uNHs3gW-b3lMeiukBUfN_LWwAqTqfFr5tOwYbyr9l-vkf4OJ7L72fCcNLCF72tf_H
_td4DdMjem6gNwB-h5IylfnqoOS-j98RNnRZIHAsJQgDWA1hEaVgmn7X9fuGGIRwIacpvCWEd5kA
dg5Ku4aesvE2CIBsD1gfQGQAbjHYfnhVB_AQxjiQ0wKwDUDnZ2tS0aEH4UMPwgzDcKf8u_13xPU3
iZNmP3UuvuHlJ833vPy_M_8Na3cFwj4AT1Ac_t-3jD0fejbWNwbdoXe_mkqZNHm2D2GJJm8vlSUS
smjG9fU_NFjl8JL-fv44SRHkmRJ8xc5cDd-8C4B7PnzItlr-EHzdafZuCt-VwDO_C__lLkHbvw9h
NIX3bBOaYt7OpfKGYTkLKF-wtYsaB4N1-TWG10n5p_YfDnrxfZfe98A7BNk_nMf65mrIS-C9jwYB
bHNTKSj57_d3XVcJvskxXw1fkzP4poWSG3dd-xB8o29uDGpL_Fb-w66QNXCMb082289aE6u1b9j2
1N3bFy0AlHKTJDcvIEz5d1--ebCLXFl6P0MtlFsYtmBcC8fLeGOQJvjeCcCpzJWCkv9_-jhJgf1B
CcKnwq8CYV0WqKvybusfgq97mxubQ3hr7UMNHoqzvv59CANIz58jauahhfZnjLXz6kOY8u__-vNg
F99z6f0MWJ5g2F6XfWNjl8SbgvCccaSFALZ5U6TXivz396_Fb9uuhW-buq57l-XrXAzCN7rNjc0h
PHvO6cXkDDE6ltXaN2x7uryH3bsv5TYsMBjsosahB_Ea1_uk-FPzDwed_L5z7r-gOAbN9prq6-df
xpvyDr23P2ZsXqTb_jOYqDJXS3Ty39XPNB2OsAEFCKvAN5c1BC8RVSWYpm_6-jH4uvU8-1bwrbwU
RWjDCBJg52yadPtQQ_0dz6DroWju28KbFmdFuJ2XFjbAbO_X6PAF3xOEKf-u5z8DVSCAoN_zW3hP
ejkA29xUOoTkv78-iiLg47AKvptB_A7rH4PvqT3M8G8F37ZFNrbKC2X7VevtQ7h-76H42szmXjMB
hOoJbxc1UoPBnIAw5Z_av5QJkYU0S_9DnSqHj-w-51eBr9iZSvA1OYNvWnCEven6x_DrjvPirhA_
WglwjNctxhiHN6u1c9B_6RK8SHvPS4nKS7s1Auju58r8gvDBYKN_yj81P_l1lSVyVl_rP0OdNjeV
DiH57_9nmt7ATwHCKvBtWxFFiDV9s-WPwffUHhbE2RLC4PdJ1n2owfOa-yG_gPulEMY5nL_ArJkA
QrX3pgbDoai7_xo2GL5BTPmn5te5IBK9kEqZzAbupd4A-KUtfE7VVQl8HFbBt20BKEM4gY44_S7g
KvINMQrhPjRuaSv4tq3BGbBzUNo19JSNt0EAZHvA_rhuIwNwi6v2g2nwUHTQPWvTrIFvWpy11aGA
9v_8Lte7dH9a9QFMui1HXO91mwN9ABfZcfi7zmwDS-uOlYdn7zNMb9Gcizw881zeL1U7H5UY-xKA
D-vz73MpWZyDGgDehwba3FSaEPl-xs80He6xWA1fsTOV4ZvLayiqrH8MvhFbFmdL_FbefeG0D7_L
bAjj7FloWxeb2zzX1I4Y5c8d-Wff7-J7Lry-lGF63fWbauF9uloQk5ZrEMCpzJWCkv9n-Wvhmxxz
ZfianEGXBeqq3GT9Y-B1rzn-oxA_WglwjG_-NNuvWjerGwh7KM76L__R9u5LicpLu7UC6O7HNGc8
5Z_af_r7Lb2fC8NLCF72tf_H_td4DdMjet4LwDY3lYKS-_f8URSthq-YNe-ZAsKu6yqv3zfEKHwP
xQoCbwxhZRli9tAQxvl-_-u_2eTmXrux1beATPm3vf-W91xzPwVHw-Q_r37-ZV8LzLZ-bNxYvH7-
5VwIxhsDOJW5UlDy-5yfaTrcY6EEYVX45rKGQIm6KpXWPwbfiK3fy63guwRkerpuwvtQ6-57KG4c
kt7zUnbz00L7DLxz7yn-tvMP6fJ7Lr2-BOYUlMf65mrIOwTZIVCTNgCwzU2loOT-ef9a_CbHXBm_
bau6-jH4ut_hF2sr_Gr-t0crgR4k6llniNFHrP6GMACEMM7-29-3zWY395rakaP829A-9v3W3M86
Tl8gbCF5AugQqNfGG4M0aQMAt4et36YyP7tf2pL-Z-1xkkJE6WoInxJ-Cwj7pgVH2KvXPwbfiKkd
8i0hPFvZfvV89_E3hD0U5w-TiftSovLSbs0AZt-XaO4p-_b55_ry_y29nwPLE3Db67JvbOySeLfG
rQU9CXgD8Peysz2Ea0X_n-c7wka0M1ZD2I_zTSAsohSJa8NJjqvWrnMxCOFDUSsf9q0gbHCG0hfQ
U4bSrkfbT1kfDYyn2sgA3OKq-WAaPBQIYUwD2f5_jrQA3Aam-TWP3SNKOz-Tm9iUf7f9jujt4Zfi
JO3OcKsiO159vyX3gaURpR5cpUw_-xz24eQ4WTTj_vozNFDl8JL-d-xxkiKKSoiPwyoIbwHfXNZA
D746F93hXHKYowEIHx4EvpWXAtl3gb2n9qEGz7suzCEMeGl2Dd72vpSoDgW00O5g286-g28L3oYZ
jZ-ybxN-X4a1O7sPsOye9G9rEMA2N5UOIfl-z78GvltCuIVvlmVwvI9Va7iEr1urH-St4HuC2NFL
sAsA7JzJd_opQ2mpzZvVGj7Y930L4Q62fQj37jUTQDgQsJRflDkfT-mznb_UCZGFNEvvQ50qh4-8
v_d3XXc1fMXOVIZvLhtSZln2OZ8iHyLAbQVFcgXhg9Gj0ANAeFMZYvZQD8XFYZm4LyUqryGtZn7B
d2o85d8mfhJprv4MddrcVDqE5P8df5ykiKIS4uOwCsKq8DU5gw4Bx-tAkYdgmg6dC5QyWbz_QCbw
DXEGYRgMh6KB-G9DuAhtGIgB_wY8s71yku5DDfCMs74QzX0HZPv8eXuvmQAOEvgaf-n8-L6JRfmn
5tf5jTNB_qe0tL7dBLDK4SP-7-vXwHcrCH-wAk5yBNMS6FzggxdIuP15UOMkXbT_oNgewlvAt22R
bVxoDQHgYxjCdYUPpnX3HooGwi1I0_Icqivu69IA0wvKP0X-WXFOCyAyAHddq8ffsYo8PD8uprdo
LkUennku79doixivrPehTpubSkHJ-3t_pulIoK_G8On9gWN9FqK1EI7FDnvO8cGLTygLlNBlgboq
F68-KJIOvm17ME4kXqet4KuF9ux36un6_Z5BONQa6PYUwjjv60N1zT3ln7L-njJMr7t_W0UeEkHv
AeBU5kpByf_7-iiKVsH3HjDut75pwRH2TRBfrr8P30eCcCFr6EHyowm7r6uzew-FxeYp3lP_KPt-
A4SXMLzsa-8P9a-xnv4bpkcEvQeAbd4U37Ui-_-6hSngHotNIDwE48CxVkNYlwUS14Yj7NnrL2Xy
sBCerWw-f6whpiEcaghhnPWFdvNtvjfx-PmSe8o-Nf9PwrYF4enq91-2tbBs_8fGjcXr95O205_h
zlTmSkHJ--t_h9ubwXeoDRyra-04WwxjwUtEVflZ8Jim31x-KRNEXFxBGAbDoagX79EW8NVCG0cv
wS4DYE9Dc2vt6wofTOvuPRQIYcBD8bWJxTlkF9xT-qj576khAPZBOdW3BPJL3tvCmbRc70OdNjeV
gpL-9-1RFN0NvkMwPr23bedCOHFt_KYFR9iov2A8tf5SJmfwbduDcSLxMm0B37a9X7W9DfUQPYgC
51Bdc0-5o_z-DSi3Vx_Ia6F4GW9qzBicSfP0Z6gzlblSUPL-vp9pOhxhI-ohCA9BOTnmM2FcIHFt
OMJGnKST6y9lgoiLKwjDYDgU9a9AuAhtGEEC7JzJ9_kpQ2ltl7z7UEPtHa8hfHYYinPI3rivI4C5
lD-PBN8iD6-A2O8bGjsGzaF4pPvpfajT5qZSUPI-jv834NtvT-MJnIY6gWNNwligRF0115Qu4du2
B_NE4mXaAsL3r7Ji9BGrtU_49yEcwjiHLLDonvJHzX9P2I71t9dUX7--Mt6UdwrCBOg7ADiVuVJQ
8j_GX6CEiNJfh3C-vQXjxLXhmxYcYY_COCiSzSC8FXwLWQPH_PYLs-3mSbwPNXgobhyKi_cT95Q-
av6_dNuAHq9vSf_2-gx12txUOoTkfwy-kxwBTW8KgTRQOI8B4T6M__05jAskrg1H2IiTdBDCviGG
Ibxgr9ZCtw-fRxCrNXwwIIRxcRiW39tcp-xR8JcyIbKQZund5iayLEO-9cPg7H5pS-7H8LfKsqwp
0ofwYeA71J6KX_BYANDBWKBEXTXX5TrtaH8F31NrcLYoCZbCV1V6umx_nQwx_XgfavBQdPchDCD9
vv-c2In7Ft6UP7f9JNIWegPw97LT5iZSma8OSv7H8bfFwtxxME1HLHYPDeGx1o8zlNxAnKRX6-UN
cQXhU1vI-2m8QFvA1_AM2Dko7Rp6ysbbIACyPWB9LG8jA3CLwbb2jh1IAZwBuQOu-f0caYHQtr4h
XldNvENC_TMhR1yfh-Zs6lwQWV5IpWxy5bAPJ8fJ4jqn-gwNVDm85H8cv84FHO8DRR6CaTp0LiB2
_tPBNznmMDlDLgvUVQnXdc9APATfU2twNhvCU9CdC99FOsF0rQzxPyo-Bh_xWsMHa8DbgjiEAS-N
rsAL2_j6_uNV9er5d1ac06L51tbHqlYPvot2kZ8XeMP0Fs2lyMMzz_X90lgqcyE1eh-qtLmpFJT8
j_EvZYJSJh18S5n8nykhhDg_HYRPIDE5g29aEChRV83VrnMKwnM0Bt-FhUnWwDGeNVZP581tqfah
1v2-gmoLYdtAiOa69Onzpk-59wsyTK_7aC7-KIBTmSsFJf-j_UuZfBYX5jaXiFL4cfZZeJ8Nwrms
kbg2fNOCIxpQbg3hH1O2v0tYVjcw9VCcg-cCyu3zdvwWevX8_2kVeYgiDyf72v9D-Wu9pDsB2OZN
sVsr8j__n2k6Al9CROln0XkWGPchbHIGXRaoqxKOsDeDsHJBlDX0IJk9Xk-nze1Khph8vA_-oRrC
OANv-39-3BZ69fz7Sdie7g3T_7z6-Zd9humd9Y_NG4vX75_CN2mZ-gx1pjJXCkr_5-AzFwB01BEg
APgBh8kZ-DiDydlDw7gPYd_0IDhDVJVdURmDcCH---OIyvZ3CctqDR8M8FCcQbe9Z-W28KX8u6-6
AOyDcE7fEsjfeu8liIfmRbqt96FOm5tKQcn-XH7mNleQZx3U8i9Q_XF2yrGHgzCAMwjnskbi2vBN
Cxavr_Dbh-BPqJA1cIwXefR05dwMMfl4H35Dtg-hMZX_dDzKn8eDcnv1gbgWipfxSPfTn6HOVOZK
Qcn-nH6m6agjAKIEXPsMbiZn8OMMJmcPBeNLCDdtgSLP4Lou3CMbhHAh---ziMr2dw3voeggvA81
wK0Gx_lcoJQJ5c8TwLfIwyt49vuGxo7BdSjekOaMId3W_1CnzU2loOR-Xj9zAWEKCHFE4MsBuDXg
8uPss4j-NoSH5mdyBt_0IFDicAzP4NuH8KNKT9nmIGa1Nnm-pV49-_4J27H_9prq6-dfxpvyDr13
LD5pAwCnMlcKSv7n9zO3gXGQZxDiOAi5R4Bx4FijEM5ljcS1UexqWLz_cQgXsoYeJGogXlShxeTj
fdhAt203ey-lz-he2gb0IFndkv5t-RnqtLmpdAjJ-_-4maZ-FqW6SgHXnoSdyRn8OIPJ2Y9DuH3v
0LwEL5HLGkWewXVduEd2BuFC-v-nUZXtNw3H6gn4GgLAh-I7Xj1-SkngJM3T_1CnyuEj-7-pZ5oO
IY4IfHkTwvkX0Pw4A4Afg-CtefmmBYESh2P4Cd8_hA8Gm2zXqpA1cIyVvoeeLny-IX61qLx6-pBI
c-VnqNPmptIhJP_-6Wdu09ZVBiQ6kOxmwdjkDH6cweTs7hBu3zM1H7g2ip0OC0Ak2RmMx1qDT487
FP8Puqey-dMUlVfPH50LIssLqZTJtgBWOXzk--f9TNO-QJwCrj0bwj8B41sQltDwkeRdka2rEq7r
YicrBEUO3xA3YTzUHib2q-gf_kaQADtH6bvoKUNpLTAYAsDHj4P_1fPnXiry8Pzzmt5if99zeb92
PioxXl3vQ502N5WCkv81-EzTIcQRgS8XQziX9Wex8_PslMObQ3jsvRxVB1_bm2CajkpWSPLk8z4o
EuxQIiiSRRD_MW0AyHvr1fPnSjsHpS_WtwMyTK_7flMtvAm_igBuD1u-bYvTZf-clvyv4xeBCeYC
QZ5BiONiCN8LxksgnMocwhTQuAZH2F1-H8Y7lJMQvlmwZA0c402SVk-Zj4GYzv9w_0g6wbDIw8m_
9v9Q-1ovSV1vAP4OJV0qc6WkJf9r_uuqROLaqyA81P6f96shDGA0rpMcryDctnVVgmn66HObmzhC
7_BbyHrW3hicofQF9JShtOtt2iBoYGx93G4jA3CL8fYL6nrKgGOMUiZ0-kfkCPuqL07SZv_4OH_w
c9Z93_B8--vwM0yv6xv63-eMPR96NtbXf_fYXF5VbZ4c9t97MiRZXOfTn6GBKoeX-K-tZ5qOOgIE
AD-gm0DYjzMEjrUKwmNxY7GDkwzDlWk6HGEjiiIIU4xCOChy_MZFsZ3QCdRGkAA7Z7vs-4KmkgwB
4GOzKb16-txTQ7Drw3Cqb-Y5HfAOvXcK-KR5eh-qtLmpFJT8r_0XgQnmAkGeQYjjZhAGsBjCACYh
zFGdtS1c4ySFMAU0rsER9gSEEwhezd6b0hfAMd40ifWULQDt-Dg1bDr-TyDD9LqrD8S1ULyMR7qf
-gx1pjJXCkp_8gMA0-SmkFcp4NrKEG7bpRBOjvns_LHYIZcVXLGDk_Sw0cC2rkowTR_EcCpziN59
IrXRvandGAafCcwlyvYPU1Re-fz-NHyLPLyCZ79vaOwYXIfi3RpHoF6v96FOm5tKQclP-r6YpkOI
IwJfbgJhAIshDGDRe5zkeAZZpulwhI0kT0Yh-A3jCgzp6P4UsoYeJJsns57eAex0ftV1jJvvvbQd
gN4YDNtrqq-ffxlvynvrvaSNAZzKXCko_cl-KeY2V5BnEOK4CYT9OLsbhIfgGicphCmgcQ2OsCch
bHMTDCkEr0YhjGO8fUZn_9tjDHFzSOkLGHwd0F-9-JNIc-VnqLMtImtFfvKP_Zmmfxa5ukohAPim
pQRjP84QONZsCCfH-GZcCW0armjauirBNH0SwqnMIXr3idS_N2PnQA9iYOdsmtR6ylBadwA3nd9Z
KmVCZCHN0vtQp8rhIz-55-iZpn9egS9Xw7cP4bnwFTvzZjyOCrHY4dROwZVpOhxhI8mTmxD_hnHV
7UERR-fL7GwPPWXTYwxxl1e-_vknkebqz1BnWyzWivzkn_tnLlBXGZDoQLJTgnDgWLMgHDgW-Dib
FReygit2yGUFDEA1TlJUpoDGNdiYC2ETidQaCMsaBmLAvg8Mke1-vKi8_vnX_Z2_JekhVcpkWwCr
HD7yk3_pn2n6p6_uUggAvmmthrDJ2eYQngVjmEjyJhHb9RyhQ_cCqUyuIHwwBA5F-Q3hIAF2zl0K
hJ4ylNbPFaRXP-99WbxGJStoXFvVHtGcJQAo8rD7b5jeonkUeXjl2TpeP_bSeK_q96FOm5tKQclP
-jVimv55Bb5cDN9_C2A2hNe_h6NCLHY4tS1UhSk6_OpcIA73KGUD5TNYcxNBkeBgMBic4WAwlL4A
jvH9Mj3b-1hRefXz35cKfDWuXcUzTO-z6sNTRVvGa6G85fxeEsCpzJWCkp-8KmIuEOQZhDg_NITH
YNzC19xx1FUJnYsz_LZtxAC3BiIG_IcG1PeUnrJF-XR_1aUC30pWs8F3Cbyhvv6zJfHa-2MxCbYb
A9jmplJQ8pNf1c80HcwFRJQiyLPVEPbj7Ecg3IfxqfJalvVZnAzT64r6JYR3KM8g7NaAHtwZxNn_
7kXl1c9vXyrw1bg2Csf2XLX-T1cfhEN9-fFTGvL23zMVbwr8pGv9GepMZa4UlPzk38rPNP2zr44A
P_CroOjHGQLHuglhP842gTCkxEcPvg4kSmEjiiIIU5xB2DfEFYSjYwzY4m5Jr6cMpXW-ovLq57cv
FfhWsgLQnP8_HC-BNwS8sb5b8B3zDvmG4k3NiXSt96FOm5tKQclP-q39zAWCPIMQx9UQHoNvH8Kq
8G3bPef44AUcSJicQZcFhCmgca2Dr81NBEVyDl8GYOdAD5L7Zn62h56yu4R_9fPblwp8Na7Neodh
et3VB_MQHG_Bccw79l4CrSKA28PWb9vicNk-tyU-_e-hZ5oOEZgQUYogzx4ewpctR4VKVkjyBHVV
IpX5ZyGLvjjYQhjH_OcqQLafBSM6f_ftXKnAt5LVICBbSPYh2F6XfbegORVvLvwJwuv1BuDvUNK1
xWGNyE-_n-DXEeAHfBUM-68dkzD24_wuEM5lDQmtW5-OBeJwD8uyunu3-oZy6QvoKUNp1z-fBglK
mdD5G5Aj7Ku_OEm7b9hqh1IJwpn8Ogikh1WbI4d9ODlOFte59GdooMrhJT-5f8rPXKCuMiDRgWS3
GIZj8E2OOQLHQnLM7wJhyArgJo7QEYd7mDuOuiphmF4H37bVgwTYOU9VkF79-PZ1hA7IE7LXtqR-
WYMAtrmpdAjJT-6f8jNN-yyadZVCAPBNazMI92Hsx9nmED5Ch2VZHXxP6sPXrYHgIKAHMWCLn68O
Owc6gFImdP4WaOl_kV5X70OdKoeP-OT-DT-T9M8r8OUiGJ7e58fZLAgD2BTCDuQndFv4ntSHb8QA
--B8xfzVzy_JNFd-hjptbiodQvI-r1-nAjuUTzt-5gJ1lQGJDiS72TD04wyBY01CuG23hPAeHBIl
NK6hkhUipl9B_LMNEmDnPEVRefX807kgsryQSplsC2CVw0f_5-XrXKDIQxim99TrZ5r_GaeuUggA
vmltDuHAseDH2SYQ-khyONxGKnP4hriGb9seY8B_-OL_6vnXVxzulfyO99H9L-Kw_780R7fIa9L2
eh-qtLmpFJT8z_1X1aOsn2n65xX4EiJKZ0P4Fnz7EAagDOFY7BAnKeqqRFAkw-BlAHYO9CB5_KJC
_XM-Gab3efVhTPrHAJzKXCko_Z-br6pHWz9zGxgLcZwNYQCzICx2TbEOHEsZwq7rwubmIHzdGsAx
foqiQvnzsyry8ArIQ339Z6TH0J_hTpubSoeQ-M-j17no-pcyAdMS2NzE8aL-X1g-c4G6SiEA_KY1
C45zIZwccwSOheSYr4YweFP8GwjrgxA_FDUMxID9-X0eTa_af46wv-7VXV-4ESjtpcW--7uu291f
-h8a2_8b85I2EG__uyyW1clRAKscXvI-j1-nAkUefgNKaw5QKnPUVdn1G_YyCD-y_pmmNyUyAiBK
wLU3hXDbroNwgboqwTR9FMKH-5dRyBpGkAA75yHr0avnH4k0V_9DnTY3lYKS-zn8pUxgmF539f39
-iXwfZb1M7eBsRDHm3A8FWU-zhZB_DSPwLEWQ9h1XfiGwBHX8HWbqTTfzhfAMX7IovLq_UcizdWf
oc5U5kpByf88-j5cdS5Q5OEq6D7r_pkL1FUKAcA3LXxICR2ieSjlGRz9OEPgWLMhnBzzbvxcCIMD
NZNwa34F31MLg_FQ1KjdGAY-dTyeXj3-SKS5eh-qtLmpFJT8z_1X1bOtn2k6mKY38OUCcbhHKRN8
SHkFST-OZsO3357mFTjWTQjrskCQZ4Pw7SD8pULW0IPk4YoK5Q_JpADgVOZKQcn-3H5VPev6W-ia
O466KqFzMQjJtRBOjjkCx-qc4xSEXdcdha9bn8_5kDVwjB_qqLxy-kQJ4CWAcWSoZEWEeTLZ5m7w
muvbBMA2N9UWQf6n9JcygWF62KF82f2zrAaQhul9xhqDpB9np2GrIDwVN5cNYWsmRyF8pZ0DPUge
p4i9cP7lAFKD4chKHKEjk_zqIj0ufAEgzY9nV--ZmK8duxTC7_1h67epzM-ul7bkf17-DuXLrr_U
DcRa_Fp8HJJ9WC6F8FQ8kzPoskCQZ4PwdZtXnqmIo7sVpdIX0Lmg-Llox9SHb5GHV9dpUwnCj6sW
uLf6LqHdh-cSCL8B_HsV9OsQrhX5yf_v_Ouq-Gx905qE5v-cng3hU8LegnACHcaRjUL4UFyT2OCs
AWbKUNr1dm2QoJQJnZ_eHGEP9ley6uA7JsP0YPHr70f6XdnmroNtH6iXzy7Hzxk7pvehTpXDS37y
P7vfD4PuP9N0nK6SG5PQPL3Xj7NZEL4F31zWEChxOIaD8I0a3l9r50AP5oPyXnrl86NxrYPsLtW6
61OHjCj3BBC_BOrN85IfZ4_dBWCbm2qLID-5n9gfeP5VX5ykCPLsJjxvwTc55jfh24f6EHzd5tGV
ijhC6QvgGP9uEXvx83MCcJGHONoVjnb13XmwiHAPrD5I_0BtgTw0fujZWP9sAKcyV1sI_cn-xH4-
DAb7maaj5MYkNG-BV_zMWfA1OYPruoPwjdj43Gv3d_FL56enQ9b93aUadqkGw-SIdE_kFqR9IA-B
tr2WQngQwDY31SZNfvI-sT-w-NFncZIiyLNRaN6Cb3LMZ8E3lzUEShyO4SCEDT5O4ULW0IPk94rW
i5_fbwBbAICjXXVXkYdEtScB7y349mHbXkshPAjgVOZKkyc-_Z-Z74fB5HOm6Si5ARGl19C8AV_x
M2fBt21PuoRv206p9AVwjH_leL36_QEAw-SIYk_sFqhrfC10bXN3M8YggG1uKk2e-OR-Zn-g_TfH
xEkKpulIoONDSuylgRj8JnyTYz4bviZncF13EL4Rm55f7cbAzoEeJD9evF79-Fi87iA8dLXPSY8r
29x1IF0L4TkAfwPwl7abRPpWlmWwLGv2eJ0LxOG_88RiNwlhP84WQVhEKQ477wrCh_J2ITc4A3YO
SruGnrJ1bZCglD8P8keWI2zaBJKy3gfpz02loOQn-zP7A89fDF9zx1FXJXQuJuGbHPNF8M1lA9lL
_EYMOBjs5vwKWQPH_EeLyqufHxJprt4A-KVtIJG_lWUZLMuaDeBSJqirEobpAQA_eDEJYT-OFkE4
gQ7jyAYhXHwBekqG4zYQ3jko7Rp6ypa1QYJSJnQwenKETZtAUtb7UKfNTaWg5Cf-M-sDz589tgXT
XPgmx3wRfHNZQ6DE4Rhewde9zd7PuRVxhNIXDYR-QK9_fkikuXoD8Je2gUT6VpZlsCxrkaeuSvim
hcCxJuErdib8OFsM4SDPYJjeFYQLOZPC--8MzlD6AnrKUNr1-DZIUMqEDkZPjrCv_qIo2iQ203Ta
4CfUYR9OPpfFdQ79GRpocxOpzFdPhPzkf2Z-4PmLPa7rQnB2E77JMV8MX5OzrihHXJxB2OBsNoRP
44wgAXbOXQvRK5_fIXjWsFF5KbTQBkM66a_r8p_AUY3ba10Ub_a_DO3-ljHmyBL87D5L5OjY96FO
lcNLfvI-u98Pg1W_XNY34St25mL4OsmxSeQs_3xPUCRnEF6i0hfAMV5m2jnQuaDzMxcWB__7_GYZ
UEXQQ6DyUtSwHxaaPK6hOzF0pzkfNezRq-98aOzgvpSG_iQTHUh0MO37Qm0210x1vht9W8B3rG8S
wDafvxjyk-9f8weev9gTRRFMzm7CNznmi_Cby4awLXyLPGze9wXfiC2Egxs3QA2SuxXyVz4-sdh9
fuM_hPOjBABooY2DwZQhrHPRfMuqPOvPFOLqXKBKvs7EsQHwmaqouxjSBlpIz-5Pnrsv_NalcQXi
GjYy2N26bgLUbdaawe5iMb1YvOYziP_S3tvD1m9TmZ-dL23JT-5n9vthsNgHALmsb8JX7MxF8DU5
g84FHO8D5o6DaTp0Ljr4ug2fF6mII2U4vfr5GZOTHLtvDQCB5yP8CJDBBjsw2EWNg8Fmw7IP6ww2
bG6ilA0omaafzcdC2t3XVXkFultA7_C7c0aBNQT_7vkNCN9a39VcZijX_a-Bcwu9Afg7lGSpbA7Q
2iQlP-lfye8IGwJNYboF4RbWSyDsJMeuQPXhe2oLuYLC--8MzlD6AnrKUNr1ZItj3BV__v7N975U
FEU4QTEWO4idCT-O8CHlJ2QOBoOeV3AOGbSwuQ_K6-2sq7IDXQYb1hfU_nNq_y-by3H9WEPicY2j
kQDcas6D6TXw-frWHRyrCNBcMKSoYXegbeP3_-pQHQNy-f9zgzMUskYOwASQ-9-vcIaaMzBZX521
Fvqu6yJORuLeWG8b49aYqedTOuxDWIIPPssSCTnwvd_HBqscXvKT-9n9fhis8uWyvglfsTMXwzeX
NWKxQ12VV-A9tcb-xWyVdg70YB5U6fwsU3LMETgN2E46FDUCS4N2MLr7KdnchPUFPABIpHYGt-5z
5_v7Z7DP5n4JkjqPUVdl17bwjcMP5Ed5Bt8zaW4D4RGYzlUNG9nX_ELWZ_fW-OpLkgqFrBfFPeWs
I5aNfxQNAtjmplJQ8pP-mf2B5y-2RFEEk7Ob8E2O_WL4tu1Jl-Bt2zUq4gilL4BjvGlRefXz4yTH
7lvHYvcJ0MpLUcgarG5AWnkp6rKB8ZQYUuhcgCE9609ljroqwZB2wGxBPCSdCxhuDMP0YLhxA91a
R36U8CMJk5UdfHUuJudzAmZdlWCaDob0bG5D4NS56MB7OneG4yL-Aq4VOZ9x869nVuR8PmeRMzmP
fwG_owBOZbsd60R_8j_z3w_DVb5c1jfhK3bmKvianMF13UH4RuN196Zqd1v40vlp1H7rTx0M6GEP
YgcG7Qbj0-8B2wKoyMMzsFn-Q7muyg6ErVoQX33jqkSRhyjyEIHLcYrneHuYOw6TNc_69-Ti9aHL
NH3w2dl7enNsodyuwXHczzEmABzj7r52Y7AvCLPIgR4kwDGGlqSD6-G_uqLA7-ripHnXPwNgm984
HTdEfvI-sz-wvpN7rlzXhcnZTfgmx3wVfBPoECgH4evWakWgkHVT_DbSq58fAHCSI9ihAVtyzGFz
8xNkts0AQ4BZOxjWbnIOZwCqItRVCfYFX6bpYJoOYTaAm5LvxDBM7_uyAZnB8LLm-gNnLdP0QbDW
sAHNRV2V3fvH4NtXt4ZjDMNxkX_dtziOPteZA9CDBA5n0IMENWcoZYIqiQfjWV9g3wLCff9v6c9Q
ZypzpaDkJ-8z_-0wQGpZi325rBE41k0I_3G2GMLgwF4ag-A9tTAYDsV6Epe_gB7EgH27oNP5WQbi
E1BjsUPieEiOOdzkAw72AHqAHZhDH3R94DFNh81NHKEDKG-O4SPdf88ndDogYuectaVMoHNxDv4N
VMoEmnDAjjEcx0URRzABsMiBnjLgGKPmrIGuvB0vg43i678rK0RcWzUv1w9_HcDvQ502N5WCkp-8
z_wPPH_xJ4oimJzdhG9yzBfD1_QMURSNwreDsIJqtynEeqBefF-9-IyBmB1CiJ2JXNaz9nkIvn1A
lzJBKvN1E5qAr85F816k1z7NHZzPLVVJ3JyzOoHhuA18gwR1naCUSfd8jqzevNbCt4N5lv0qgP8M
da7_qOQn-z-g98MAqWUt9uWyRuBYNyHsx9liCIv-3zAFX7dWLwZFHMHgiiSn8zOp5JjD5AwfQsyC
8JbicY0q_XrnBHxLuXxeg7C_UCkT6BAAYmh1c86WgPdSrh8o74llWeBxDc_yfwXA70OdNjeVgpKf
-M-sDzx-eTFwXZic3YRvW4CXwNfkDK7rTsI3UudmA2FZN8WZzs9dJHbm5zet3bjZ69-QDfjqXJyB
9fJSUQv3Kmnevfb7uH4AR2wDTc_yEWYpwkxtbZsBOJW5UlDyk-_Z-X4YrPLlsr4J37YAL4XwSVPw
PbUG34jCOwd6sK440vmZVnLMYW71nRZKOgxl7KCUSdf2oXjZ3ktbxLe5_bkmR9jd-2fUIIBVF0R_
8j_zP-D8xZ4oimBydhO_bQFeCuEoilDK5CaEt1ARRyh9ARzj76LpC_hc0PlRlNiZyOVGH_rFxDQd
AJDKHKnMEScp4iRFKvOz50u11zNIh0E67MfX9AbgL31aEulbWZbBsqxFnroq4ZsWAse6CWE-zhZD
OMizrsDoXIxCuNiwuBucNeBNGUq7hh4kKGVCBwSAI_yrviiKbkIgFrvGnxxRwwZDenWO1oLkX9YW
_1JX5SLQL9VhH8ISfLimJBKyuM6dP0ODbW4ilfnqhZKf-M-sDzx-scd1XQjObsI3OeaL4WtyBtd1
u3edIBiNQHhLnWBuBAmwc_j8bFzk20_19JOV3vd-PXwdAKvCd6sYc5Ql8ux_DMr-8xdvAP6_zmck
kWYkUJbBsqxFHkfY0GUBkzMAmISwH2eLIVxyA3GSdu-zDXEF31N7guamhS9yoAcJSl80rUzogHx9
70v1v8_W6kNXM7--V-lrwvhRddiHo7DNEglZXOfO_9Bgm-e_8gqRn-zP7A88fzV8c1lPwjc55qvg
q8vifI5FcgXfU2vw-ym8oWo3BnYNhOn8zNyzqmza0uguFfhq5vfVV7_-D2nS7ypL5Nk1pff2sPXb
VOZn90tb8pP-mf1_GCwaH0XRGTSn4Ct25iL4mpwhiiJIaFfvHYPw1iri6ApOr35_lojphRJ8Z4P-
_zORflGW4GfXlN4A-L3sbA-hWpGf-K-kr6sSvml10AwcaxLCABZBOMgzME0ffb9viDMIF-IOFP7-
Z3CGUib0-QE4wr7qi5O0Ow9M01GXxhWA69KYBeRL_DL3HLKX9wBQ5YAeEgB-S4d9OArcLJGQxXXu
DAKYRHplZVkGy7Jmj3eEDYGygyaAUfiKnQk-zmbD1_QMCfSuuM_B8KG4D4AZpufwSpoD4L404aBK
4tnx1wCYIPx8AH4fGmzz3pdfIfKT-5n9gecv9vShOQXf5Jgvgm8u58G0hW-EgIPBfrUQvfr5GdIS
_F5CdfY7coLgs_kNwF-aBhLpW1mWwbKs_QWzKpG4dgdNAJMQ9uNsEYRFlIJp_s156Fx0EC5mgnuJ
GFI6HF9yhH3VFyfN-tRVCabpqEsDumeiSmJowkGVxKhLo9lLvRiNXXqAZip8J5e_z2-osA9hCT5c
UxIJWSRX-e9Dg22u8PXJT-4n9weev9jTh_YUfJNjvgi__QKQljL5hK_7PXsf_vvVVYm6Kif9l2OW
9KmoSuKzdglE11yk59IbgL_0DSTSt7Isg2VZs8c7woZA2UETwCSE-ThbBOEEOuIknT0fnQsUC8A9
GwqYP4efUl2VYJp_9f-WmLl9U9-8Uu03uuW9pdID9BDYc77I9yEl6ohA-Fs67ENYYvibZYmELJKr
-vehwTY3lSZCfvI-sz-w-MWePjSn4Jsc80XwzVeAdIcSBme-Vohu7X9dld01dN-2Df2firnm_8_J
vVpR1FwLpZkNfD_kXATfPeeocgLhM_kNwF-aBhLpW1mWwbKsRUU8ce0OmgAmIezH2SIIiygF0-RF
a-ANgUOxHN5TYkiVY9RVebWWfl-7f6hvCqCXnqlxU74_kKf23BH2VV_cNPszNY_5Kj1ADxsQzwVw
HQFV3vhIP6-DPoQlhr9XlkjIIrnqfx8abHNTaSLkJ-8z_wPPX_zpQ3MKvskxXwTfXC6HqM1NBAPJ
-lNS3f_luoTd5ftbILawnQJsO24rtQCdC9KzeUcNWOeK4Pt8_jPUmcpcKSj5yf-Mfj8MkFrW7PGu
60L0oDkFX7Ez4cfZbPgGeQbfnD_XLdavqjXvb8G4Bfx_e-19tQD9kBI2N2fPTQ_B8gvcbYwhiLfP
So-g_4x6H_q0uakUlPzkf2Z-4PmLPX1oTsE3Oeaz4Wty9gn3tsj_1PpVNfV_pumoq7K7_v0tfG1u
no2bUn9cH96XsS-HTPku_7bSXPj2IRz4Eie41lED28urjgi_z6w3AH9pG0ikb2VZBsuyZo_vqxKJ
a3fQBDAJYT-OZkO45AbiJF29lhr2ZvvCsH4et-bvHsC7pxxxva-td7rHekqvaTXzu6-64jnB9zF0
2IewBB_uKYmELJKr-vehwTbvfeUVIj-5n9kfeP5iTx_aU-BNjvls_JqcIYqiH1_-qpa_-xJWz35_
toZvC1k9BJj7fbV9pOfVG4C-tA0k0reyLINlWbPHO8KGQNlBE8AkhP04mw3hIM_UCnoNe7N9YUjp
cPS__aXihPbnlXXYh5_tJfh5PUnk55mRRXLleR8KZHNzfoJXJeqqHOxfXTQuvGPvGNOS_ZOf-JcK
PH_xpw-NKfgmx3w2fE3O4Lruj69fFea33n8rl1v-PWtIez9UW_61f6TX0Am4-WtK7_1h67epzM-u
h9r2EDNN-7wu_y8P89x2KHHad8yNO2f_5Cf-WOuHwaLxURSdQXMKvmJnzoZvLutVedRfv_DVpsVF
df9vxQOAVOafff26cum-VZdu1ZD2nmn6Vdy59Y9EUtUbgL9DSdEmwZTagz3UN-Rsbry_d_z-rSIx
Z-7kJ7_qX_cCAFDKBLHYIZc1AseahDCA2RAWUbo4jy7nX8PerGAwpEr7dwnHfr734dj-P_S9tSdD
dWMo5lBdmfP9HXG9p3Fye29I-64O_3DyuSySq773oYFLilddlVdJtaXaxFkCdJXiS37y_2GwCL5F
3iTeXhowOZuEr9iZs_Gby-pX1q_qqfe3Ocw0-Qqu-b4xSF76ltSpId9Q-2-vH_l1NAhgm5ujoL0E
bpsQ-b72-xowX3r7iTc33tD8l4j8r_0PPH-22Ba_WZZ9enNZT8I3Oeaz4WtyBtd1f3z9qlrz-j4E
h-xt-q_pKUNAn4Lyb_8f6cUBnMp88AD3r6mD3j6fGre199b8yU-_ufLDYNa4UiafZzY-SjjeB0qZ
wORsEr5iZ86GbwIdAsuBc7l_hvRHi8q9vl9bH9ZC_KfmTyIpAdjm5mxg1lWJuiqVgLn1O_bOn-zk
H1Lg_bPH6lx08I3FDrmsJ_GbHPNZ8M1l-RnfSY4-vn5V3Xp-P6fH1D7rt3PrwKV3aQ357f0jvY7e
APylbSCRvpVlGSzLmj3eETYEyg6eACYh7MfZLAiLKJ0FjDmqYW8ShyGlA-L1zS8VJ7Q3r6zDPpx8
Lovkqu99aKDNTaWJkJ-8z_wPPH-R_DhJIaK0g_cUfJNjPgu_e2nAML1fWb_qXv38kEhz9QbgL20D
ifStLMtgWdYiT12V8E0LJmcAMAlhP85uwvc0jyIPwTQdOhcoZaK8rhq2cgyGlA4IAEdc72Wc0N68
sg77cPK5LK5z_H1ooM1NpYmQn-zP7A88f7HHdd0OolPwTY75JHxzWXfwPbVZlv34_lU15-11VaKu
yk3mPxRrKv6tMb_9f6TX0RuAv7QNJNK3siyDZVmLPI6wocsCJmf4n583IQxgFMJOcuzm4XgfKGWy
ybpq2MoxGFL1eVQlmKZvs6aBWP2_sXfNGXPre18qTtT3hvS8OuzDyeeyuM7j96GBNjeVJkJ_8j_z
P-D8xZ4oijqI-s-OSfiKnTkK31zWiMUOOher4au6flUtfX9dld3V91-2r4HzmjG-vX_k19EbgL_0
DSTSt7Isg2VZi4u9b1odRAPHmoQwgEkIt23JDcRJusm6atjKMRjU5nIJPKbpqKsSTNO755d9c_P1
YwzFHvIteVdfjrjey62_E_k5ddiHk89lkVz1vQ8NtLmpNBHyk-_Z-YHnLweTpqPkRgfPKfiKnTkL
viZniKJos-WrwnOL-W9Bd9qvKei1YLwE9tjYdvzle2757nF_SKS5egPwl7aBRPpWlmWwLGuxr65K
JK6NXNYIHGsSwgBmQTjIs1kwmT1H2Er_LSBeV_XZmm6B83L82LP2-1DfHN8SOUJtH0kkAHgf6rS5
qRSU-OR-Zn-g_au9LTyn4Ct25iz4mpzBdV3EYvej61fVmvczTb_CcntNwbEFbn-cUN8Q6Mfi--b_
kV4IwO1h67epzM-ul7bkJ-8z_-0wWOVzXbeD5xR8k2M_C765rCFQQkTpZuvfCq4q_880fXQ_bX8L
5BaOt_Jdjmv7xt475pt7fkikLfQG4O9QEqQyV0pS8pP-1fyOsKHLAiZnAHATwgBmQTjIsw4UW8y-
hq1UNBjSl--_jlDbQxJpFMAk0isryzJYlrXYV1clEtduoOlYk-AVOxN_nN2Er8kZEuiIk2noLZrn
nQH8CiIAk7bQf_pgyGG3rUifAAAAEHRFWHRMb2RlUE5HADIwMTEwMjIx41m2wQAAAABJRU5ErkJg
gg==
:: layer.lua
--[[pod_format="raw",created="2024-04-03 08:45:10",modified="2024-12-11 15:56:24",revision=5520]]
--a layer is basically a single polygon and the info on how to draw/triangulate it

nulllayer = {}

function layers_pre_op()
	undo_checkpoint()
	for i=1,#vspr.layers do
		if vspr.layers[i].selected then
			vspr.layers[i].sourcepoints=copypoints(vspr.layers[i].points)
		end
	end
end
function layers_post_op()
	for i=1,#vspr.layers do
		vspr.layers[i]["sourcepoints"] = nil
	end
	vspr.icon=nil
end
function layer_op_move(l,v)
	for i=1,#l.points do
		l.points[i] = l.sourcepoints[i] + v
	end
	l.points_triangulated={}
end

function layer_op_rotate(l,pivot,ang)
	local s,cs = sin(ang),cos(ang)
	for i=1,#l.points do
		l.points[i] = l.sourcepoints[i]-pivot
		
		local sinxy = l.points[i]*s
		local cosxy = l.points[i]*cs
		
		l.points[i] = vec(cosxy.x-sinxy.y, sinxy.x+cosxy.y)

		l.points[i] += pivot
	end
	l.points_triangulated={}
end
function layer_op_scale(l,pivot,scalar,axis_x,axis_y)
	for i=1,#l.points do
		if axis_x then
			l.points[i].x = pivot.x + (l.sourcepoints[i].x-pivot.x)*scalar
		else
			l.points[i].x = l.sourcepoints[i].x
		end
		if axis_y then
			l.points[i].y = pivot.y + (l.sourcepoints[i].y-pivot.y)*scalar
		else
			l.points[i].y = l.sourcepoints[i].y
		end
	end
	l.points_triangulated={}
end
function layer_op_flip(l,horiz,pivot)
	for i=1,#l.points do
		l.points[i]-=pivot
		if horiz then
			l.points[i].x*=-1
		else
			l.points[i].y*=-1
		end
		l.points[i]+=pivot
	end
	l.points_triangulated={}
end

function subdivide_edge(l, edge, cuts)
	if (l==nil or edge==nil) return
	if (edge<1 or edge>#l.points) return
	undo_checkpoint()
	
	local pa,pb = l.points[edge],l.points[1]
	if (edge<#l.points) pb = l.points[edge+1]
	
	local dir=pb-pa
	dir *= 1/(cuts+1)
	for i=1,cuts do
		add(l.points, pb-dir*i, edge+1)
	end
	l.points_triangulated={}
	--notify("Fart")
	return true
end

function create_layer(name, ca, cb, fill, outline,type)
	local layer={
		show=true,
		name = "",
		points={},
		points_triangulated={},
		col_a=flr(rnd()*31+1),
		col_b=0,
		fill=0b1010010110100101,
		outline=-1,
		type="ear",
		selected=false,
	}
	
	
	--layersmade+=1
	--layer.name = "Layer ".."X"--..tostr(layersmade)
	

	layer.col_b=layer.col_a
	
	if (name!=nil) layer.name = name
	if (ca!=nil) layer.col_a = ca
	if (cb!=nil) layer.col_b = cb
	if (fill!=nil) layer.fill = fill
	if (outline!=nil) layer.outline = outline
	if (type!=nil) layer.type = type
	return layer
end

function add_new_layer(layerdata)
	--add(vspr.layers, create_layer())
	--select_layer(#vspr.layers)
	if layerdata==nil then
		table.insert(vspr.layers,curr_layer+1,create_layer())--,curr_layer)
	else
		table.insert(vspr.layers,curr_layer+1,layerdata)
	end
	select_layer(curr_layer+1)
end


function del_sel_layer()
	undo_checkpoint()
	deli(vspr.layers, curr_layer)
	--also any other selected ones
	for l in all(vspr.layers) do
		if l.selected then
			del(vspr.layers, l)
		end
	end
	if curr_layer>#vspr.layers then
		select_layer(#vspr.layers)
	else
		select_layer(curr_layer)
	end
	vspr.icon=nil
end
function move_layer_up(i)
	undo_checkpoint()
	vspr.layers[i], vspr.layers[i+1] = vspr.layers[i+1], vspr.layers[i]
	if i==curr_layer then
		select_layer(i+1)
	elseif i+1==curr_layer then
		select_layer(i)
	end
	vspr.icon=nil
end
function move_layer_down(i)
	undo_checkpoint()
	vspr.layers[i], vspr.layers[i-1] = vspr.layers[i-1], vspr.layers[i]
	if i==curr_layer then
		select_layer(i-1)
	elseif i-1==curr_layer then
		select_layer(i)
	end
	vspr.icon=nil
end

function select_layer(l,multispan,multione)
	
	
	if not multispan and not multione then
		--select only the specified layer
		for i=1,#vspr.layers do
			vspr.layers[i].selected = l==i
		end
	elseif multispan then
		--toggle all layers between current and l
		local increment = 1
		
		if (l<curr_layer)increment=-1
		for i=curr_layer+increment,l,increment do
			vspr.layers[i].selected = not vspr.layers[i].selected
		end
	elseif multione then
		--toggle whether l is one of the selected layers
		vspr.layers[l].selected = not vspr.layers[l].selected
	end
	l=max(min(l,#vspr.layers),0)
	curr_layer = l
	--[[
	if l>0 then
		points = vspr.layers[l].points
	else
		points = {}
	end
	--]]
	
	local selectedcount=0
	for i=1,#vspr.layers do
		if (vspr.layers[i].selected) selectedcount+=1
	end
	if (selectedcount<1 and #vspr.layers>0) vspr.layers[curr_layer].selected = true
	
	update_style_buttons()
end

function get_curr_layer()
	if curr_layer<=0 then
		return nulllayer
	end
	return vspr.layers[curr_layer]
end

function rebuild_this_layer()
	if (curr_layer<=0) return
	vspr.layers[curr_layer].points_triangulated={}
	vspr.icon=nil
end


function draw_edges(l,highlightedge)
	--local pts = l.points
	local closepoly = l.type=="ear"
	
	for i=1,#l.points do
		local pa,pb,c=i,i+1,(5<<8)+7
		if (pb>#l.points) pb=1
		if (highlightedge!=nil and highlightedge==i) c=(9<<8)+7
		if (pb==1 and not closepoly) pb=pa
		line(l.points[pa].x*view.zoom,l.points[pa].y*view.zoom,l.points[pb].x*view.zoom,l.points[pb].y*view.zoom,c)
	end
end

function set_layers_visible(show)
	undo_checkpoint()
	for l=1,#vspr.layers do
		if vspr.layers[l].selected then
			vspr.layers[l].show = show
		end
	end
	vspr.icon=nil
end

function set_layer_colors(col_a, col_b, outline_col)
	undo_checkpoint()
	for l=1,#vspr.layers do
		if vspr.layers[l].selected then
			if (col_a!=nil) vspr.layers[l].col_a = col_a
			if (col_b!=nil) vspr.layers[l].col_b = col_b
			if (outline_col!=nil) then
				if vspr.layers[l].outline == outline_col then
					--reset outline (none)
					vspr.layers[l].outline = -1
				else
					vspr.layers[l].outline = outline_col
				end
			end
		end
	end
	vspr.icon=nil
end

function set_layer_fills(fill)
	undo_checkpoint()
	for l=1,#vspr.layers do
		if vspr.layers[l].selected then
			vspr.layers[l].fill = fill
		end
	end
	vspr.icon=nil
end

function set_layer_types(t)
	undo_checkpoint()
	for l=1,#vspr.layers do
		if vspr.layers[l].selected then
			vspr.layers[l].type = t
			vspr.layers[l].points_triangulated={}
		end
	end
	vspr.icon=nil
end

function copy_layers(all_layers,noclip)

	local copytable = {}
	for i=1,#vspr.layers do
		if all_layers or vspr.layers[i].selected then
			add(copytable, make_save_copy(vspr.layers[i]))
			copytable[#copytable].points = convert_vec_lists(copytable[#copytable].points , false)
		end
	end

	if (not noclip) set_clipboard( pod(copytable,7,{pod_type="vgfx_layers"}) )
	
	return copytable
end
function paste_layers()
	
	local clippy = get_clipboard()
	
	if (sub(clippy,15,25) == "vgfx_layers") then
		add_layers(unpod(clippy))
	end
end
function add_layers(l)
	undo_checkpoint()
	
	for i=1,#l do
		l[i].points = convert_vec_lists(l[i].points , true)
		l[i].points_triangulated={}
		add_new_layer(l[i])
	end
	for i=1,#l do
		l[i].selected = true
	end
	vspr.icon=nil
end

function duplicate_layers()
	--duplicate selected layers
	
	local duplicates = copy_layers(false,true)
	local insertpoint = curr_layer
	deselect_all()
	curr_layer = insertpoint+1
	add_layers(duplicates)
end

function select_all()
	for i=1,#vspr.layers do
		vspr.layers[i].selected = true
	end
end
function deselect_all()
	for i=1,#vspr.layers do
		vspr.layers[i].selected = false
	end
	curr_layer=0
end
:: main.lua
--[[pod_format="raw",created="2024-03-24 09:47:34",modified="2024-12-11 15:56:24",revision=13160]]
--[[   Veditor
an editor for vgfx vector sprites

todo:
- general code refactor/tidy-up
- middle mouse pan?
- add a 'focus' shortcut to center selected polygons in view

known issues:
- sprite icon framing isn't perfect
- ear clip triangulation sometimes fails when it shouldn't
- Seams between edges that share the same vertex positions (with subpixels enabled)

try:
- own line rendering function that will match tri edges
- tline3d for outlines (maybe for tri raster? test if it's faster?)

maybe but probably not:
- snap to axis when moving points horiz/vert/diag
- maybe better preview for point adding, showing where verts/edges will be?
- boolean operations between layers?
- path triangulation (strip with width, and closed/open option)
- load custom palettes
- export pico-8 lua
- curves? (Bad idea!)
- move all selected layers together in the stack
- type in specific values for positions (+ rotations/scalings)?

-- changelog:
v1.01
- fixed bug where loading a .vgfx file with only one sprite crashed when
	trying to draw it
- you can no longer switch tools whilst actively using one
- you can no longer use major keyboard shortcuts (cut, delete, select all, etc)
	when actively using a tool
	
v1.02
- Added ".vgfx Files" help section to explain picotron file association added in v0.1.0g
- 

]]




include("undo.lua")
include("vgfx.lua")
include("mathfuncs.lua")
include("layer.lua")
include("vsprite.lua")
include("spritelist.lua")
include("settings.lua")
include("help.lua")
include("canvas.lua")
include("gui.lua")
include("tablestuff.lua")
include("input.lua")




function save_working_file()
	trim_empty_sprites()
	local savedata = {}
	
	for s=1,#vsprites do
		add(savedata,{})
		for l=1,#vsprites[s].layers do
			add( savedata[s], make_save_copy(vsprites[s].layers[l]) )
			--gotta do this until f64 user data can be stored/fetched
			savedata[s][l].points = convert_vec_lists(savedata[s][l].points , false)
		end
	end

	--cls()
	--recursiveprint(savedata,1)
	--print("done")
	--stop()
	return savedata
end

function load_working_file(savedata)
	local savedata = savedata or {}
	if (savedata==nil) savedata = {}
	if (#savedata==0) return --nothing to load
	

	vsprites = {}
	for i=1,#savedata do
		--add(vsprites,{icon=nil,layers={}})
		create_vsprite(true)
		
		--savedata[i].icon = nil
		--[[if savedata[i].layers!= nil then
			for k=1,#savedata[i].layers do
				--savedata[i].layers[k].name=""
				add(vsprites[i].layers, savedata[i].layers[k])
				vsprites[i].layers[k].points = convert_vec_lists(savedata[i].layers[k].points , true)
				vsprites[i].layers[k].points_triangulated={}
			end
		else--]]
			for k=1,#savedata[i] do
				--savedata[i].layers[k].name=""
				add(vsprites[i].layers, savedata[i][k])
				if vsprites[i].layers[k].triangulation then
					--convert older 'triangulation' setting to layer type
					vsprites[i].layers[k].type=vsprites[i].layers[k].triangulation
					vsprites[i].layers[k]["triangulation"]=nil
				end
				vsprites[i].layers[k].points = convert_vec_lists(savedata[i][k].points , true)
				vsprites[i].layers[k].points_triangulated={}
			end
		--end
		--undo_checkpoint(vsprites[i])
	end
	
	trim_empty_sprites()
	select_vsprite(1)
end

function copy_vgfxlua()
	cp("./vgfx.lua", "/ram/cart/vgfx.lua")
end
function _init()
	
	window{
		tabbed = true,
		title = "0.vgfx",
		icon = userdata"[gfx]08087000000777000077077007700777077000777700707777077007700777077077[/gfx]"
	}
	-- [[
	menuitem {
		id = "veditorsettings",
		label = "Settings...",
		--shortcut = "x",
		action = show_settings
	}
	--]]
	menuitem {
		id = "showhelp",
		label = "Help...",
		shortcut = "F1",
		action = show_help
	}
	menuitem {
		id = "copyvgfx",
		label = "Copy vgfx.lua to RAM",
		--greyed = true,
		--shortcut = "F1",
		action = copy_vgfxlua
	}
	disp_w,disp_h = get_display():width(), get_display():height()


	generate_gui()
	generate_settings_gui()
	generate_help_gui()
	pick_tool("point")
	set_pivot_mode("Centroid")
	
	--need a null layer for when no layer is selected
	nulllayer = create_layer("No Layer", nil,nil,nil,nil,"Nope")
	--(name, ca, cb, fill, outline,type)

	--make our working vector sprite
	vspr = create_vsprite()
	
	--veditor logo
	vspr.layers[1].points={vec(40,-40),vec(-10,10),vec(0,40)}
	vspr.layers[1].col_a=1
	vspr.layers[1].col_b=16
	vspr.layers[1].fill=fills[9]
	add(vspr.layers, create_layer())
	vspr.layers[2].points={vec(-40,-40),vec(13,0),vec(0,40)}
	vspr.layers[2].col_a=8
	vspr.layers[2].col_b=2
	vspr.layers[2].fill=fills[16]
	
	select_vsprite(1)
	undo_checkpoint()
	
	currspr = get_sprite(vspr)
	--notify("SAVE/LOAD DISABLED!")
	-- [[
	mkdir("/ram/cart/vgfx/")
	wrangle_working_file(
		save_working_file,
		load_working_file,
		"/ram/cart/vgfx/0.vgfx" -- default
	)
	--]]
	--load_vgfx("./vgfx/0.vgfx")
	load_settings()
end






tdelta=1/60

function _update()
  
  
	update_input()
	
	
	if display_help then
		help_gui:update_all()
	elseif display_settings then
		settings_gui:update_all()
	else
		if showpanel then
			if ve.panelright then
				panel.x=disp_w-panel.width
				toolbar.x=0
			else
				panel.x=0
				toolbar.x=panel.width
			end
			gui:update_all()
		end
	end

	if not (display_help or display_settings) and not textinput.active
	and not (panning or draggingpoint>0 or moving or scaling or rotating) then
		if key("ctrl") and keyp("c") then
			copy_layers()
		end
		if key("ctrl") and keyp("x") then
			copy_layers()
			del_sel_layer()
		end
		if key("ctrl") and keyp("v") then
			paste_layers()
		end
		if key("ctrl") and keyp("d") then
			duplicate_layers()
		end
		if key("ctrl") and keyp("a") then
			if not key("shift") then
				select_all()
			else
				deselect_all()
			end
		end
		if keyp("delete") then
			--delete layers
			del_sel_layer()
		end
		if key("ctrl") and keyp("n") then
			add_new_layer()
		end
		if key("ctrl") and keyp("z") then
			undo()
		end
		if key("ctrl") and keyp("y") then
			redo()
		end
	end
end


function _draw()
	tdelta = 1/stat(7)
	
  
	
	
	if textinput.active then
		textinput.update()
		clear_inputs()--don't use any shortcuts while typing
	end
	
	if (kbp("Help")) show_help()
	cls(ve.clearcolor)
	if display_help then
		mouseonview=false
		clear_inputs()
		--help_gui:draw_all()
		--return
	end
	if display_settings then
		mouseonview=false
		clear_inputs()
		--settings_gui:draw_all()
	end
	
	
	if (showpanel) then
		gui:draw_all()--draw has some input logic to it, it happens BEFORE canvas update
		
		
	end
	
	if not (display_help or display_settings) then
		if kbp("Toggle Panel") then
			if key("shift") then
				ve.panelright = not ve.panelright
				showpanel = true
				save_settings()
			else
				showpanel= not showpanel
			end
		end
	
		
		
		if (kbp("Prev Sprite") and curr_sprite>1) select_vsprite(curr_sprite-1)
		if (kbp("Next Sprite")) select_vsprite(curr_sprite+1)
		
		--[[if kbp("To Lua") then
			copy_spr_as_lua(vspr)
		end]]
		
		update_canvas()
	end
	
	
	--get to drawing
	draw_canvas()
	
	clear_inputs()
	
	--display info
	draw_info()
	
	--multiple gui draws can screw with the cursor, so use the active UI's cursor gfx
	if not (display_help or display_settings) then
		if showpanel and not (mouseonview or panning or rotating or scaling or moving) then
			window{cursor=gui.mouse_cursor_gfx}
			setcursor(gui.mouse_cursor_gfx)
		end
		if mouseonview then
			cursors.current = mouse_cursor_gfx
		end
	elseif display_help then
		window{cursor=help_gui.mouse_cursor_gfx}
		setcursor(help_gui.mouse_cursor_gfx)
		help_gui:draw_all()
		
	elseif display_settings then
		window{cursor=settings_gui.mouse_cursor_gfx}
		setcursor(settings_gui.mouse_cursor_gfx)
		settings_gui:draw_all()
	end

	buttoninfo = ""
	
	
	window{cursor=cursors.current}
end

function setcursor(c)
	if c==nil then
		cursors.current=1
	else
		cursors.current=c
	end
end

cursors={}
cursors.current = 1
cursors.pointer = 1
--cursors.crosshair = 2
cursors.crosshair = userdata"[gfx]10100000000000000000000000000000000000000000000000000000000010000000000000017100000000000001710000000000000171000000000011100011100000017770007771000000111000111000000000017100000000000001710000000000000171000000000000001000000000000000000000000000000000000000[/gfx]"
cursors.pointover = userdata"[gfx]10100000000000000000000000000000000000000000000000000000000111000000000000177710000000000001110000000000100000001000000171000001710000017100000171000001710000017100000010000000100000000001110000000000001777100000000000011100000000000000000000000000000000000000[/gfx]"
cursors.hand = 3
cursors.grab = 4

cursors.diag_down = 8
cursors.diag_up = 9
cursors.rotate = userdata"[gfx]10100000000000000000000000000000000000000000000000000000000011000000000111117711000000017771117710000000117100171000000011710001710000017111011171000001710001711100000017100171100000001771117771000000011771111100000000011000000000000000000000000000000000000000[/gfx]"
cursors.move = userdata"[gfx]10100000000000000000000000000000000000000000100000000000000171000000000000177710000000000011111000000000110171011000000171117111710000177177777177100001711171117100000011017101100000000011111000000000001777100000000000017100000000000000100000000000000000000000[/gfx]"
cursors.horiz = userdata"[gfx]10100000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000100000000171000171000000171111111710000171177777117100001711111117100000017100017100000000100000100000000000000000000000000000000000000000000000000000000000000000000[/gfx]"
cursors.vert = userdata"[gfx]10100000000000000000000000000000000000000000100000000000000171000000000000171710000000000171117100000000001171100000000000017100000000000001710000000000000171000000000000117110000000000171117100000000001717100000000000017100000000000000100000000000000000000000[/gfx]"
		

function draw_info()
	if showinfo then
		if mouseonview and buttoninfo=="" then
			local infox, infoy = sub(tostr(view.mx_cursor),0,6), sub(tostr(view.my_cursor),0,6)
			
			if highlightpoint>0 then
				infox, infoy = sub(tostr(get_curr_layer().points[highlightpoint].x),0,6), sub(tostr(get_curr_layer().points[highlightpoint].y),0,6)
			elseif snapping then
				infox, infoy = tostr(math.tointeger(view.mx_cursor)), tostr(math.tointeger(view.my_cursor))
			end
			oprint(infox.."  "..infoy,view.left+10,view.bottom-20)
		else
			oprint(buttoninfo,view.left+10,view.bottom-20)
		end
		--oprint("Debug: "..tostr(debugvar),view.right-50,view.bottom-40)
		oprint("cpu "..sub(tostr(stat(1)),0,5),view.right-50,view.bottom-30)
		oprint("tris "..tostr(vgfx_trisdrawn),view.right-50,view.bottom-20)
		oprint("fps "..stat(7),view.right-50,view.bottom-10)
	end
end

--outlined print
function oprint(s,x,y,c,c2)
	if (c==nil) c=7
	if (c2==nil) c2=0
	print(s,x-1,y,c2)
	print(s,x+1,y,c2)
	print(s,x,y-1,c2)
	print(s,x,y+1,c2)
	print(s,x,y,c)
end

colors={
0,20,4,31,15,8,24,2,
21,5,22,6,7,23,14,30,
1,16,17,12,28,29,13,18,
19,3,27,11,26,10,9,25,}

fills={
0b0000000000000000,
0b1000000000000000,
0b1010000010000000,
0b1010000010100000,
0b1000000000100000,
0b1000001010000010,
0b1010010110100101,--checkdither
0b1100110000110011,
0b1010101010101010,
0b1100110011001100,
0b1111000011110000,
0b1111111100000000,
0b1000010000100001,
0b1001110001100011,
0b1000000100100100,
0b1001001101101100,

0b1000010100100101,
0b1001011101101101,
0b1000010100100000,
0b1000110101110010,

0b0011011100110111,
0b1111011100110001,
0b1000100000100010,
0b1010100010100010,
}

function stopandprint(s)
	camera()
	clip()
	cls(2)
	if type(s)=="table" then
		print(recursiveprint(s,1),50,10,6)
	else
		print(tostr(s),50,10,6)
	end
	stop()
end
function recursiveprint(t,depth)
	local 	sumstr = ""
	local prestr = ""
	for i=1,depth do
		prestr..="."
	end
	if t!=nil then
	for k,v in pairs(t) do
		--print(prestr.." "..k.." ___ "..tostr(v))
		sumstr..= prestr.." "..k.." ___ "..tostr(v) .."\n"
		if type(v)=="table" then
			sumstr..= recursiveprint(v,depth+1)
		end
	end
	end
	return sumstr
end

function get_drawspace()
	return {
		cam_x=peek4(0x5510),
		cam_y=peek4(0x5514),
		clip_l=peek2(0x5528),
		clip_t=peek2(0x552a),
		clip_r=peek2(0x552c),
		clip_b=peek2(0x552e),
	}
end
function set_drawspace(drawspace)
	poke4(0x5510,drawspace.cam_x)
	poke4(0x5514,drawspace.cam_y)
	poke2(0x5528,drawspace.clip_l)
	poke2(0x552a,drawspace.clip_t)
	poke2(0x552c,drawspace.clip_r)
	poke2(0x552e,drawspace.clip_b)
end
:: mathfuncs.lua
--[[pod_format="raw",created="2024-03-28 13:00:52",modified="2024-04-15 13:32:17",revision=3710]]
function lerp(a,b,t)
	return a+t*(b-a)
end
--clamped lerp
function clerp(a,b,t)
	t=max(min(t,1.0),0.0)
	return a+t*(b-a)
end
function invlerp(a,b,v)
	return (v-a)/(b-a)
end
function onedeesnap(v,increments)
	return round(v/increments)*increments
end
function snap(x,y,dosnap)
	if dosnap==false then
		return vec(x,y)
	end
	if snapmode=="Grid" then
	
		return vec(round(x/ve.grid_size.x)*ve.grid_size.x,round(y/ve.grid_size.y)*ve.grid_size.y)
	end
	if snapmode=="Point" then
		local snap_vert = nil
		
		--local snapradius = 6
		local closest_snap = ve.snap_range+1
		
		for l=1,#vspr.layers do
			for p=1,#vspr.layers[l].points do
				local point = vspr.layers[l].points[p]
				local pinview = canvtoscreen(point.x, point.y)
				
				if pinview.x>mx-ve.snap_range and pinview.x<mx+ve.snap_range 
				and pinview.y>my-ve.snap_range and pinview.y<my+ve.snap_range then
					--point is in snap range
					if p!=draggingpoint or l!=curr_layer then
						--point isn't the one we're dragging
						local dist = vec(point.x,point.y):distance(vec(x,y))
						if dist<closest_snap then
							--this is the closest vert we've found to snap to
							closest_snap = dist
							snap_vert = vec(point.x,point.y)
						end
					end
				end
			end
		end	

		if snap_vert==nil then
			return vec(x,y)
		else
			return vec(snap_vert.x,snap_vert.y)
		end
	end
	if snapmode=="Edge" then
		local snap_point = nil
		local edge_pa = nil
		local edge_pb = nil
		
		--local snapradius = 6
		local closest_snap = ve.snap_range+1
		
		for l=1,#vspr.layers do
		
			--local p,dist = get_closest_edge(vspr.layers[l].points, x,y)
			for p=1,#vspr.layers[l].points do
				
				local pa = p--vspr.layers[l].points[p]
				local pb = 1--vspr.layers[l].points[1]
				if (p<#vspr.layers[l].points) pb = p+1
				local ignore, point = sqrdist_to_line(vec(x,y),vspr.layers[l].points[pa],vspr.layers[l].points[pb])
				if point!=nil then
					local pinview = canvtoscreen(point.x, point.y)
					if pinview.x>mx-ve.snap_range and pinview.x<mx+ve.snap_range 
					and pinview.y>my-ve.snap_range and pinview.y<my+ve.snap_range then
						if (pa!=draggingpoint and pb!=draggingpoint) or l!=curr_layer then
							local dist = vec(point.x,point.y):distance(vec(x,y))
							if dist<closest_snap then
								closest_snap = dist
								snap_point = point
								edge_pa = vspr.layers[l].points[pa]
								edge_pb = vspr.layers[l].points[pb]
							end
						end
					end
				end
			end
		end	

		if snap_point==nil then
			return vec(x,y)
		else
			if key("shift") then
				--check if we snap to the edge's midpoint
				local midpoint = edge_pa + (edge_pb-edge_pa)*0.5
				local pinview = canvtoscreen(midpoint.x, midpoint.y)
				if pinview.x>mx-ve.snap_range and pinview.x<mx+ve.snap_range 
				and pinview.y>my-ve.snap_range and pinview.y<my+ve.snap_range then
					return midpoint
				end
			end
			--snap to point on the edge
			return vec(snap_point.x, snap_point.y)
		end
	end
	--default snap to whole numbers(pixels)
	return vec(round(x),round(y))
end
function round(v)
	return flr(v+0.5)
end

function sqr(x)
	return x*x
end
function sqrdist_to_line(p, v,w)
	local l2 = sqr(v.x - w.x) + sqr(v.y - w.y)
	if (l2==0) return sqr(v.x - p.x) + sqr(v.y - p.y)--line segment is only a point
	local t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2
	t = max(0, min(1, t))
	local tp = vec(v.x + t * (w.x - v.x), v.y + t * (w.y - v.y))
	return sqr(p.x - tp.x) + sqr(p.y - tp.y),tp
end
	
function dist_to_line(p, v,w)
	return sqrt(sqrdist_to_line(p,v,w))
end
function dist_to_offset(p, v,w)
	if (p:distance(v)>p:distance(w)) v,w=w,v
	local offset = v+normalize(w-v)
	return p:distance(offset)
end
function normalize(v)
	local mag=v:magnitude()
	v.x/=mag
	v.y/=mag
	return v
end
function get_centroid(pts)
	
	local pa,pb,l
	local c=vec(0,0)
	--if (true) return pts[1]
	local perim = 0.0
	for i=1,#pts do
		pa = pts[i]
		pb = pts[1]
		if (i<#pts) pb=pts[i+1]
		
		l = vec(pb.x-pa.x, pb.y-pa.y)
		perim+=l:magnitude()
		--return (pa+l*0.5)*l:magnitude()
		c += (pa+l*0.5)*l:magnitude()
	end
	if (#pts<1) return c
	return c/perim--/#pts
end
function xdp(num,dp)
	local scale = 10^dp
	local c = 2^52 + 2^51
	return ((num * scale + c ) - c) / scale
end
function mouse_over_point(points)
	local point_index = -1
	local highlightradius = 6
	local closest_dist = highlightradius+1
	for i=1, #points do
		local pinview = canvtoscreen(points[i].x, points[i].y)
		if pinview.x>mx-highlightradius and pinview.x<mx+highlightradius 
		and pinview.y>my-highlightradius and pinview.y<my+highlightradius then
			local dist = vec(pinview.x,pinview.y):distance(vec(mx,my))
			if dist<closest_dist then
				closest_dist = dist
				point_index = i
			end
		end
	end
	return point_index
end
function get_closest_edge(points,x,y)
	local edge_index=-1
	local minedgedist = 99999
	local minoffsetdist = 99999--used when two edges are the same dist (at a vert)
	for i=1,#points do
		local i_next = i+1
		if (i_next>#points) i_next=1
		local distfromline = dist_to_line(vec(x,y),
			vec(points[i].x,points[i].y),
			vec(points[i_next].x,points[i_next].y)
		)
		local offsetdist=dist_to_offset(vec(x,y),
			vec(points[i].x,points[i].y),
			vec(points[i_next].x,points[i_next].y)
		)
		if distfromline<minedgedist then
			minedgedist = distfromline
			minoffsetdist = offsetdist
			edge_index = i
		elseif distfromline==minedgedist then
			if offsetdist<minoffsetdist then
				minedgedist = distfromline
				minoffsetdist = offsetdist
				edge_index = i
			end
		end
	end
	return edge_index, minedgedist, minoffsetdist
end
:: profiler.lua
--[[pod_format="raw",created="2024-04-09 22:52:04",modified="2024-04-11 12:13:21",revision=888]]
local function do_nothing() end

-- The metatable here is to make profile() possible.
-- Why use a table at all? Because otherwise lua will try to cache the function call,
-- which by default is do_nothing.
local profile_meta = {__call = do_nothing}
profile = {draw = do_nothing}
setmetatable(profile,profile_meta)

local running = {} -- All incomplete profiles
 -- All complete profiles. Note that if the profiles haven't been drawn yet, it will
 -- not be cleared, and further profiles of the same name will add to the usage metric.
local profiles = {}
-- All completed lingering profiles. These are never automatically cleared.
local lingers = {}

-- start_profile, stop_profile, and stop_linger are all internal functions,
-- serving as paths for _profile to take. Lingers share start_profile.
local function start_profile(name,linger)
	local source = profiles[name]
	running[name] = {
		start = stat(1),
		linger = linger,
	}
end

local function stop_profile(name,active,delta)
	local profile = profiles[name]
	if profile then
		profile.time = delta+profile.time
	else
		profiles[name] = {
			time = delta,
			name = name,
			precedence = active.precedence,
		}
		add(profiles,profiles[name])
	end
end

local function stop_linger(name,active,delta)
	local profile = lingers[name]
	if profile then
		profile.time = profile.this_frame and delta+profile.time or delta
		profile.this_frame = true
	else
		lingers[name] = {
			time = delta,
			this_frame = true,
		}
	end
end

-- The main functionality lives here.
-- Takes in the name of what you're profiling, and whether or not to
-- make the profile linger.
local function _profile(_,name,linger)
	local t = stat(1)
	local active = running[name]
	if active then
		local delta = t-active.start
		
		if active.linger then stop_linger(name,active,delta)
		else stop_profile(name,active,delta) end
	
		running[name] = nil
	else
		start_profile(name,linger)
	end
end

-- Clears all lingering profiles.
function profile.clear_lingers()
	lingers = {}
end

local function draw_cpu()
	print("cpu:"..string.sub(stat(1)*100,1,5).."%",1,1,7)
end

-- This draws the profiles, and then resets everything for the next frame.
-- If it is not called, usage metrics will accumulate.
-- Lingering profiles are always displayed after persistent profiles.
local function display_profiles()
	local i = 1
	for prof in all(profiles) do
		local usage = string.sub(prof.time*100,1,5).."%"
		local to_print = prof.name..":"..usage
		print(to_print,1,1+i*9,7)
		i = i+1
	end
	for name,prof in pairs(lingers) do
		local usage = string.sub(prof.time*100,1,5).."%"
		local to_print = name..(prof.this_frame and "[X]:" or "[ ]:")..usage
		print(to_print,1,1+i*9,7)
		prof.this_frame = false
		i = i+1
	end
	profiles = {}
end

local function display_both()
	draw_cpu()
	display_profiles()
end

-- This swaps out function calls depending on whether or not you want to have
-- profiling. This is to make it as much as possible so that you don't have to
-- think about cleaning up profile calls for efficiency.
-- The first boolean is for detailed profiling, the second is for CPU usage.
function profile.enabled(detailed,cpu)
	profile_meta.__call = detailed and _profile or do_nothing
	profile.draw = detailed and (cpu and display_both or display_profiles)
		or (cpu and draw_cpu or do_nothing)
end
:: settings.lua
--[[pod_format="raw",created="2024-04-09 11:27:23",modified="2024-12-11 15:56:24",revision=2129]]
ve={}
ve.nightmode = true
ve.clearcolor = 0
ve.gridcolor = 21
ve.axiscolor = 6

ve.snap_range = 6
ve.subpixels = true

ve.grid_size={x=16,y=16}
ve.guide={show=true, w=480,h=270,align_h=0,align_v=0,x=0,y=0}

ve.passivesnapping=false

showinfo = true
showgrid = true

tool = "point"
snapmode="Grid"
pivot_place = "Centroid"

paneltopmode="cols"
showpanel=true
ve.panelright=true


display_settings = false
function show_settings()
	display_help = false
	display_settings = not display_settings
end
function load_settings()
	local loadsettings = fetch("/appdata/veditor/settings.pod")
	
	if (not loadsettings) return
	--stopandprint(loadsettings.nightmode)
	ve.nightmode = loadsettings.nightmode
	btn_nightmode.sprite = ve.nightmode and 23 or 31
	
	ve.clearcolor = loadsettings.clearcolor
	ve.gridcolor = loadsettings.gridcolor
	ve.axiscolor = loadsettings.axiscolor
	
	ve.snap_range = loadsettings.snap_range
	ve.subpixels = loadsettings.subpixels
	
	ve.grid_size={
		x=loadsettings.grid_size.x,
		y=loadsettings.grid_size.y
	}

	ve.guide={
		show=loadsettings.guide.show,
		w=loadsettings.guide.w,
		h=loadsettings.guide.h,
		align_h=loadsettings.guide.align_h,
		align_v=loadsettings.guide.align_v,
		x=loadsettings.guide.x,
		y=loadsettings.guide.y
	}
	
	ve.passivesnapping=loadsettings.passivesnapping
	ve.panelright=loadsettings.panelright
end
function save_settings()
	mkdir("/appdata/veditor")
	store("/appdata/veditor/settings.pod", ve)
end
function generate_settings_gui()
	settings_gui = create_gui()
	settingsmenu = { x=170, y=20, width=130, height=disp_h-40}
	settingsmenu.x = disp_w*0.5-settingsmenu.width*0.5
	settingsmenu = settings_gui:attach(settingsmenu)
	function settingsmenu:draw()
		draw_gui_box("Settings", self.width,self.height)
		
		print("_Grid Size",20,20,13)
		print("X:\nY:",20,30,7)
		
		print("_Guide Frame",20,55,13)
		print("Width:\nHeight:\nAlignment:",20,65,7)
		
		print("_Snapping",20,120,13)
		print("Range (px):",20,130,7)
		
		print("_VGFX",20,150,13)
		print("Subpixels:",20,160,7)
		
		--guide align axes:
		local cx,cy = 94,98
		rectfill(cx-14,cy-14,cx+14,cy+14,1)
		line(cx,cy-14,cx,cy+14,0)
		line(cx-14,cy,cx+14,cy,0)
		--guide align box:
		local bcx,bcy = cx+ve.guide.align_h*7,cy+ve.guide.align_v*7
		rect(bcx-6, bcy-6,bcx+6,bcy+6,7)

	end
	btn_closesettings = settingsmenu:attach_button({x=settingsmenu.width/2-20,y=settingsmenu.height-20,label="Close"})
	function btn_closesettings:tap(msg)
		display_settings=false
	end
	btn_resetsettings = settingsmenu:attach_button({x=settingsmenu.width/2-20,y=settingsmenu.height-40,label="Reset"})
	function btn_resetsettings:tap(msg)
		ve.grid_size.x=16
		ve.grid_size.y=16
		ve.guide.w=480
		ve.guide.h=270
		ve.guide.align_h=0
		ve.guide.align_v=0
		ve.snap_range = 6
		ve.subpixels = true
		save_settings()
	end
	
	fld_gridx = create_number_field(settingsmenu,{x=80,y=29})
	function fld_gridx:get() return ve.grid_size.x end
	function fld_gridx:set(v)
		ve.grid_size.x = numonly(v,ve.grid_size.x)
		save_settings()
	end
	fld_gridy = create_number_field(settingsmenu,{x=80,y=39})
	function fld_gridy:get() return ve.grid_size.y end
	function fld_gridy:set(v)
		ve.grid_size.y = numonly(v,ve.grid_size.y)
		save_settings()
	end
	
	fld_guidew = create_number_field(settingsmenu,{x=80,y=64})
	function fld_guidew:get() return ve.guide.w end
	function fld_guidew:set(v)
		ve.guide.w = numonly(v,ve.guide.w)
		save_settings()
	end
	fld_guideh = create_number_field(settingsmenu,{x=80,y=74})
	function fld_guideh:get() return ve.guide.h end
	function fld_guideh:set(v)
		ve.guide.h = numonly(v,ve.guide.h)
		save_settings()
	end
	
	local cx,cy = 94,98
	btn_guide_tl = create_align_button(settingsmenu, {x=cx-14,y=cy-14,h=-1,v=-1})
	btn_guide_t = create_align_button(settingsmenu, {x=cx-4,y=cy-14,h=0,v=-1})
	btn_guide_tr = create_align_button(settingsmenu, {x=cx+6,y=cy-14,h=1,v=-1})
	
	btn_guide_l = create_align_button(settingsmenu, {x=cx-14,y=cy-4,h=-1,v=0})
	btn_guide_c = create_align_button(settingsmenu, {x=cx-4,y=cy-4,h=0,v=0})
	btn_guide_r = create_align_button(settingsmenu, {x=cx+6,y=cy-4,h=1,v=0})
	
	btn_guide_bl = create_align_button(settingsmenu, {x=cx-14,y=cy+6,h=-1,v=1})
	btn_guide_b = create_align_button(settingsmenu, {x=cx-4,y=cy+6,h=0,v=1})
	btn_guide_br = create_align_button(settingsmenu, {x=cx+6,y=cy+6,h=1,v=1})
	

	fld_snaprange = create_number_field(settingsmenu,{x=80,y=129})
	function fld_snaprange:get() return ve.snap_range end
	function fld_snaprange:set(v)
		ve.snap_range = numonly(v,ve.snap_range)
		save_settings()
	end
	
	btn_subpixels = settingsmenu:attach_button({x=100,y=159,width=10,height=10})
	function btn_subpixels:draw(msg)
		local c=1
		if (msg.has_pointer) c=7
		rect(0,0,self.width-1,self.height-1,c)
		if ve.subpixels then
			rectfill(2,2,self.width-3,self.height-3,c)
		end
	end
	function btn_subpixels:tap(msg)
		ve.subpixels = not ve.subpixels
		save_settings()
	end
end
function create_align_button(parent,b)
	b.width=10
	b.height=10
	b.label=""
	btn_align = parent:attach_button(b)
	function btn_align:draw(msg)
		if (msg.has_pointer)circ(4,4,4.5,7)
	end
	function btn_align:tap(msg)
		ve.guide.align_h=b.h
		ve.guide.align_v=b.v
		save_settings()
	end
end

function numonly(s,default)
	local v = tonum(s)
	if (v) return v
	return default
end
function create_number_field(parent, fld)
	fld.width = fld.width or 30
	fld.height = fld.height or 9
	parent:attach_field(fld)
	return fld
end

function draw_gui_box(title,w,h)
	rectfill(0,0,w-1,h-1,5)
	rect(0,0,w-1,h-1,0)
	rect(1,1,w-2,h-2,7)
	--title = "___ "..title.." ___"
	local hw = (#title*5)/2+10
	rectfill(w/2-hw,2,w/2+hw,11,6)
	print(title,w/2-(#title*5)/2,3,5)
end
:: specs.txt
--[[pod_format="raw",created="2024-04-10 14:46:25",modified="2024-04-13 09:43:50",revision=93]]
==================================================
			Contents
==================================================
(A) File Format
- .vgfx files
 - vsprite
  - layer
   - show
   - name
   - points
   - col_a/col_b
   - fill
   - outline
   - type
   
(B) Render format
- vsprite
 - layer
  - col
  - ocol
  - pts
  - olpts
  - fill

==================================================
			(A) File Format
==================================================
.vgfx file {vsprite, vsprite, vsprite...}:
	A pod file containing vector sprites, 
	their layers, styling info, etc
--------------------------------------------------
vsprite {layer, layer, layer...}:
	A single vector sprite, is a list of layers
--------------------------------------------------
layer
{show, name, points,
col_a, col_b, fill, outline,
type}:
	A layer is a table with a list of points
	and how to render them
--------------------------------------------------
show (bool):
	Whether to render the layer or not
--------------------------------------------------
name (string):
	Name of the layer
--------------------------------------------------
points {vert, vert, vert...}:
	List of vertices for the layer
	these are currently each an array of two
	elements (x,y) but will be an array of userdata
	once that can be reliably saved/loaded
--------------------------------------------------
col_a (int), col_b (int):
	Fill colors, will use fill pattern to alternate
--------------------------------------------------
fill (number/fill pattern):
	A fill pattern to use when rendering the layer
--------------------------------------------------
outline= (int):
	Outline color, -1 for none
--------------------------------------------------
type (string)
	How to handle the layer's vertices
	Expects specific values:
		"ear" - Ear Clip triangulation
		"fan" - Fan Triangulation
		"strip" - Strip Triangulation
		
		"line" - a single line
		"line_closed" - a closed/looping line
--------------------------------------------------
vert:
	Ideally a vec(f64,f64) but there are bugs with
	saving/loading that at time of writing, so for
	now each is a table with x and y values.
	
	Hopefully this means they will be loaded the same
	in the future.


==================================================
			(B) Render Format
==================================================
vsprite {layer, layer, layer...}:
	Simple list of layers
--------------------------------------------------
layer {col,ocol,pts,olpts,fill}
	Points and how to draw them
--------------------------------------------------
col (int)
	Either a single color,
	or two colours with one bitshifted
--------------------------------------------------
ocol (int)
	Outline color
--------------------------------------------------
pts (1D f64 userdata)
	List of points (x0,y0,x1,y1,x2,y2,...)
	These are assumed to be triangulated
	Each three points in the list are drawn
	as a triangle in sequence
--------------------------------------------------
lpts (1D f64 userdata) or (nil)
	List of points (x0,y0,x1,y1,x2,y2,...)
	These are assumed to be a single line
	Lines are drawn between each successive point
	Lines are not closed by default, for closed lines
	Make the first and last points identical
--------------------------------------------------
fill (number/fill pattern)
	fill pattern for the triangles
--------------------------------------------------


If you're reading this you're a huge nerd.
:: spritelist.lua
--[[pod_format="raw",created="2024-04-03 08:42:07",modified="2024-04-15 13:36:31",revision=2720]]
vsprites={}--all sprites loaded for editing
curr_sprite = -1

function del_curr_vsprite()
	deli(vsprites, curr_sprite)
	if #vsprites<1 then
		--always need at least one sprite
		create_vsprite()
	end
	if curr_sprite>#vsprites then
		select_vsprite(#vsprites)
	else
		select_vsprite(curr_sprite)
	end
	
end

function select_vsprite(i)
	trim_empty_sprites(i)
	while i>#vsprites do
		--add sprites until there is a sprite here
		create_vsprite()
	end
	
	curr_sprite = i
	
	if i>0 then
		vspr = vsprites[i]
	
		--rebuild_gui_panel()	
	
		select_layer(#vspr.layers)
	else
		vspr = {}
	end
	
end

--sprite list can be arbitrarily long, trim it down before saves
trimming_sprites=false
function trim_empty_sprites(minimum_keep)
	if (trimming_sprites) return
	trimming_sprites = true
	minimum_keep = minimum_keep or 1
	
	--local last_sprite_with_points=minimum_keep or 1
	for s=minimum_keep+1,#vsprites do
		for l=1,#vsprites[s].layers do
			if (#vsprites[s].layers[l].points>0) minimum_keep = s
		end
	end
	for s=#vsprites,minimum_keep+1,-1 do
		deli(vsprites, s)
	end
	if curr_sprite>#vsprites then
		select_vsprite(#vsprites)
	end
	trimming_sprites = false
end
:: tablestuff.lua
--[[pod_format="raw",created="2024-03-31 11:18:54",modified="2024-04-15 20:07:16",revision=4241]]

--temporary hack while f64 userdata isn't saving/loading right
function convert_vec_lists(t, tovec)
	local l = {}
	if tovec and #t>0 and type(t[1])=="userdata" then
		--already vector format
		--this is what we'd expect ideally, but have to hack around
		--saving not storing them properly, hence the rest
		return t
	end
	for i=1,#t do
		if tovec then
			add(l, table_to_vec(t[i]) )
		else
			add(l, vec_to_table(t[i]) )
		end
	end
	return l
end
function vec_to_table(ud)
	return {ud.x,ud.y}
end
function table_to_vec(t)
	return vec(t[1],t[2])
end


--modified from http://lua-users.org/wiki/CopyTable
--used to make copies of layers for save, copy, & undo
function make_save_copy(orig)
	local orig_type = type(orig)
	local copy
	if orig_type == 'table' then
		copy = {}
		for orig_key, orig_value in next, orig, nil do
			if orig_key!="undo_stack"
			and orig_key!="sourcepoints"
			and orig_key!="points_triangulated"
			and orig_key!="selected"
			and orig_type!="function" then
				copy[make_save_copy(orig_key)] = make_save_copy(orig_value)
			end
		end
		setmetatable(copy, make_save_copy(getmetatable(orig)))
	else -- number, string, boolean, etc
		copy = orig
	end
	return copy
end

function copypoints(pts)
	local copy={}
	for i=1,#pts do
		add(copy, vec(pts[i].x,pts[i].y))
	end
	return copy
end
:: undo.lua
--[[pod_format="raw",created="2024-04-01 14:09:32",modified="2024-12-11 15:56:24",revision=847]]

function undo_save_state(spritem)
	-- don't store nils, to preserve order
	--if (true) return 0
	local saveitem = {#spritem.layers}
	for i=1,#spritem.layers do
		saveitem[i]={}
		
		add(saveitem[i], spritem.layers[i].show)
		add(saveitem[i], spritem.layers[i].name)
		add(saveitem[i], spritem.layers[i].col_a)
		add(saveitem[i], spritem.layers[i].col_b)
		add(saveitem[i], spritem.layers[i].fill)
		add(saveitem[i], spritem.layers[i].outline)
		add(saveitem[i], spritem.layers[i].type)
		add(saveitem[i], spritem.layers[i].selected)
		
		add(saveitem[i], convert_vec_lists(spritem.layers[i].points,false))
	end
	add(saveitem, curr_layer)
	--stopandprint(saveitem)
	return saveitem
end

function undo_load_state(s, spritem)
	--if (true) return
	
	spritem.layers={}
	
	for i=1,#s-1 do
		local loadstate = {
			show = s[i][1],
			name = s[i][2],
			col_a = s[i][3],
			col_b = s[i][4],
			fill = s[i][5],
			outline = s[i][6],
			type = s[i][7],
			selected = s[i][8],
			points = convert_vec_lists(s[i][9],true),
			points_triangulated={}
		}
		
		add(spritem.layers, loadstate)
	end
	curr_layer = s[#s]
	spritem.icon=nil
end

function undo_checkpoint(s)
	local spritem = s and s or vspr
	if not spritem.undo_stack then
		add_undo_stack(spritem)
	end
	
	spritem.undo_stack:checkpoint()
end


function undo(s)
	local spritem = s and s or vspr
	if not spritem.undo_stack then
		add_undo_stack(spritem)
	end
	
	--stopandprint(spritem.undo_stack)
	spritem.undo_stack:undo()
	
end

function redo(s)
	local spritem = s and s or vspr
	if not spritem.undo_stack then
		add_undo_stack(spritem)
	end
	
	spritem.undo_stack:redo()
end

function add_undo_stack(spritem)
	--stopandprint("I happen")
	spritem.undo_stack = create_undo_stack(undo_save_state, undo_load_state, 0x11, spritem)

end
:: vgfx.lua
--[[pod_format="raw",created="2024-03-22 09:38:38",modified="2024-12-11 15:56:24",revision=9585]]
--[[ vgfx.lua
0.3
vector graphics drawing

=== usage: ===
if loading vector sprite in a .vgfx file:
	load_vgfx("pathToMyFile.vgfx")
	sprv(index, x,y, [rotation, scale, color])
	
if generating vector sprites at runtime:
	my_vsprite = {
	make_polygon(vars),
	make_polygon(vars),
	make_polygon(vars),
	...	}
make sure vertices you pass to make_polygon() are triangulated
there are several functions included for this purpose

for simple triangle drawing, just call tri(x0,y0, x1,y1, x2,y2)
but make sure you call vgfx_vclip() ahead so it is properly clipped!

=== todo: ===
-polygon outline generation
-tween/interpolate between two vector sprites/polygons
-animation playback
-compression for vector data
-maybe try writing directly to graphics memory if it's faster
-reset color() to what it was before drawing a vector sprite
-fix outline drawing not matching triangle edges


=== docs: ===
"vector sprite": an array of polygons
"polygon": a table with the elements: 
 - col (color)
 - ocol (outline color)
 - pts (points/vertices for triangle drawing)
   - 1D f64 userdata numbers (x0,y0, y1,y2, ...etc)
   - SHOULD BE TRIANGULATED before being sent to sprv()
 - lpts (points/vertices for line drawing (happens after triangles))
   - same format expected as pts, or nil
 - fill (fill pattern)



=== changes: ===
0.2
- polygon vertices now use userdata
- wire rendering uses same colour rules as filled triangles
- basic polygon outlining
0.3
- polygons now have a single colour and specified fill pattern
- graphics fill pattern is returned to its state from before drawing a vector sprite
- doesn't crash for polygons with nil vertices anymore
- tri raster now follows clipping rect (vertically) for better performace when 
	polygons go beyond the screen edges
- support for loading .vgfx files and drawing their sprites
- replaced vgfx_precise with vgfx_subpixel
- 
]]

--enable for debug view of polygon triangles
vgfx_wire=false

--disable to make all tri point positions floored
--  Disabling subpixel positions adds to the render time and makes
--  animated transformations appear a little less smooth, but
--  it should prevent edge seams between polygon triangles
vgfx_subpixel=true


vgfx_vsprites={}
function load_vgfx(path)
	vgfx_vsprites={}
	local loadfile = fetch(path)
	for s=1,#loadfile do
		local vs={}
		for l=1,#loadfile[s] do
			local layer = loadfile[s][l]
			if layer.show then
				local ol = false
				if layer.triangulation=="line" or layer.triangulation=="line_closed" then
					--its a lines-only layer
					ol=true
					layer.points_triangulated = {}
				elseif layer.triangulation=="fan" then
					layer.points_triangulated = fan_triangulate(layer.points)
				elseif layer.triangulation=="strip" then
					layer.points_triangulated = strip_triangulate(layer.points)
				else
					layer.points_triangulated = earclip_triangulate(layer.points)
				end
				
				
				local olcol = layer.outline
				if (#layer.points>1 and (layer.outline!=-1 or ol)) then
					ol = convert_point_list(layer.points)
					if layer.triangulation!="line" and layer.triangulation!="strip" then
						--we close the outline
						add(ol,ol[1])
					end
				end
				if (olcol<0) olcol = layer.col_a
				
				add(vs, make_polygon(
					layer.points_triangulated,
					(layer.col_b<<8)+layer.col_a,
					layer.fill,
					ol,
					olcol
				) )
			end
	---
		end
		add(vgfx_vsprites, vs)
	end
end

function make_polygon(vertices, c1, pattern, outline, c2)
	local polygon={
		col=c1,
		ocol=c2,
		pts=userdata("f64",#vertices),
		lpts=nil,
		fill=0b0000000000000000,
	}
	
	for i=1,#vertices do
		set(polygon.pts, i-1, vertices[i])
	end
	
	if outline==true then
		--generate outline
		--this doesn't work yet!
		outline=nil
	elseif outline then
		--polygon.lpts = one_d_point_list(outline)
		polygon.lpts = one_d_point_list(convert_point_list(outline))
		
	end
	if pattern and pattern!=false then
		if pattern==true then
			--set pattern to checkered dither
			polygon.fill = 0b1010010110100101
		else
			--use specified pattern
			polygon.fill = pattern
		end
	end

	return polygon
end


vgfx_clipt=0
vgfx_clipb=0
--sets top/bottom clip 
function vgfx_vclip()
	vgfx_clipt = peek4(0x5514)
	vgfx_clipb = peek4(0x5514)+peek2(0x552e)
end
--draw a vector sprite
function sprv(v, x,y, rot,scale, col)
	if #vgfx_vsprites>=1 and type(v)!="table" then
		v = vgfx_vsprites[v+1]
	end
	vgfx_vclip()
	

	local oldfill = peek(0x5500,8)
	--local oldcol = peek(?????,?????)

	local s, cs = 0,0
	if rot and rot!=0 then
		s = sin(rot)
		cs = cos(rot)
	end
	
	local sinxy = vec(0,0,0,0,0,0)
	local cosxy = vec(0,0,0,0,0,0)
	local triv = userdata("f64",6)
	local tpos = vec(x,y,x,y,x,y)
	if (not scale) scale = 1
	
	if (col) color(col)
	local b=0
	local polys = 0
	for p=1,#v do
		b=0
		polys = 0
		if v[p].pts then
			polys=#v[p].pts
			if not col then
				fillp(v[p].fill)
				color(v[p].col)
			end
		end
		while b<polys do
			set(triv, 0, v[p].pts:get(b,6))
			b+=6
			
			triv *= scale
			
			if rot and rot!=0 then
				sinxy = triv*s
				cosxy = triv*cs
				
				set(triv, 0,
				cosxy[0]-sinxy[1], sinxy[0]+cosxy[1],
				cosxy[2]-sinxy[3], sinxy[2]+cosxy[3],
				cosxy[4]-sinxy[5], sinxy[4]+cosxy[5])
			end
			triv += tpos
			tri(triv[0],triv[1],triv[2],triv[3],triv[4],triv[5])
		end
		if (v[p].lpts) then
			local b=0
			local oline=vec(0,0,0,0)
			if (not col) color((v[p].ocol<<8)+v[p].ocol)
			while b<#v[p].lpts-2 do
				set(oline, 0, v[p].lpts:get(b,4))
				b+=2
				oline *= scale
				if rot and rot!=0 then
					sinxy = oline*s
					cosxy = oline*cs
					
					set(oline, 0,
					cosxy[0]-sinxy[1], sinxy[0]+cosxy[1],
					cosxy[2]-sinxy[3], sinxy[2]+cosxy[3])
				end
				oline += tpos
				line(oline[0],oline[1],oline[2],oline[3])
			end
		end
	end
	
	
	--this poke is weird???
	--poke4(0x5500,oldfill)
	--poke4(0x5504,oldfill>>4)
	poke8(0x5500,oldfill)
	--color(oldcol)
end


vgfx_trisdrawn=0
function tri(x0,y0, x1,y1, x2,y2)
	vgfx_trisdrawn += 1
	
	if (not vgfx_subpixel)	x0,y0,x1,y1,x2,y2 = flr(x0),flr(y0),flr(x1),flr(y1),flr(x2),flr(y2)

	if vgfx_wire then
		line(x0,y0, x1,y1)
		line(x1,y1, x2,y2)
		line(x2,y2, x0,y0)
		return
	end
	
	--order the vertices so they are descending from top to bottom
	--we need this since we are drawing it as two triangles:
	--one with a flat base, one with a flat top
	if (y1<y0) x0,x1=x1,x0; y0,y1=y1,y0
	if (y2<y1) x1,x2=x2,x1; y1,y2=y2,y1
	if (y1<y0) x0,x1=x1,x0; y0,y1=y1,y0
	
	--draw the top half
	local hh=y1-y0--height of the half
	local x3=x0+hh*(x2-x0)/(y2-y0)--slicing the tri in two makes another vertex
	if (y0!=y1) triraster(y0,y1, (x3-x0)/hh,(x1-x0)/hh, x0,x0)
	
	--draw the bottom half
	hh=y2-y1
	if (y1!=y2) triraster(y1,y2, (x2-x1)/hh,(x2-x3)/hh, x1,x3)
end

--draws a filled triangle line-by-line, top-to-bottom
--args: top, bottom, step left, step right, left pixel, right pixel
--requires clipping values be set first to work properly
function triraster(t,b, sl,sr, pl,pr)
	if t<vgfx_clipt then
		pl+=sl*(vgfx_clipt-t)
		pr+=sr*(vgfx_clipt-t)
		t=vgfx_clipt
	end
	b=min(b,vgfx_clipb)

	for y=t,b do
		rectfill(pl,y,pr,y)
		pl+=sl
		pr+=sr
	end
end

--triangulation stuff
function earclip_triangulate(points)
	points=convert_point_list(points)
	if (#points<3) return {}
	local pindices = {}
	for p=1,#points do
		add(pindices, p)
	end
	
	if clockwise(points) then
		points = reverselist(points)
	end

	local tris = {}
	while #pindices>3 do
		local earIndex = GetEarIndex(points,pindices)
		local earLeftIndex = wrapIndex(earIndex-1, #pindices)
		local earRightIndex = wrapIndex(earIndex+1, #pindices)

		add(tris, points[pindices[earLeftIndex]].x)
		add(tris, points[pindices[earLeftIndex]].y)
		add(tris, points[pindices[earIndex]].x)
		add(tris, points[pindices[earIndex]].y)
		add(tris, points[pindices[earRightIndex]].x)
		add(tris, points[pindices[earRightIndex]].y)
		
		deli(pindices, earIndex)
	end

	add(tris, points[pindices[1]].x)
	add(tris, points[pindices[1]].y)
	add(tris, points[pindices[2]].x)
	add(tris, points[pindices[2]].y)
	add(tris, points[pindices[3]].x)
	add(tris, points[pindices[3]].y)
	
	return tris
end
function clockwise(p)
	local sum=0.0
	local i_next = 0
	for i=1,#p do
		i_next=i+1
		if (i_next>#p) i_next=1
		sum += (p[i_next].x-p[i].x)*(p[i_next].y+p[i].y)
	end
	return sum>0
end
function reverselist(l)
	local r = {}
	for i=#l, 1, -1 do
		r[#r+1] = l[i]
	end
	return r
end
function wrapIndex(index, size)
	while (index<1) index+=size
	while (index>size) index-=size
	return index
end
function GetEarIndex(points,indices)
	local i=1
	local i_l
	local i_r
	
	while true do
		if i>=#indices then
			return 1-- #couldn't find an ear :/
		end
		
		i_l = wrapIndex(i-1, #indices)
		i_r = wrapIndex(i+1, #indices)
		
		if VertIsConvex(points[indices[i_l]],points[indices[i]],points[indices[i_r]]) then
			if NoVertsInTriangle(i_l,i,i_r, indices, points) then
				return i
			end
		end
		
		i+=1
	end
end
function VertIsConvex(prev, v, next)
	return CrossProd(prev-v, next-v) <= 0
end
function CrossProd(a,b)
	return a.x*b.y - a.y*b.x
end
function NoVertsInTriangle(a, b, c, polyIndices, P)
	
	for k=1,#polyIndices do
		if k!=a and k!=b and k!=c then
			--check if this point is within the tri
			if point_in_triangle(P[polyIndices[k]],P[polyIndices[a]],P[polyIndices[b]],P[polyIndices[c]]) then
				return false
			end
		end
	end
	return true
end
function orient(a,b,c)
	local ab=vec(b.x-a.x,b.y-a.y)
	local ac=vec(c.x-a.x,c.y-a.y)
	if CrossProd(ab,ac)>0 then
		return 1
	end
	return -1
end
function point_in_triangle(p, a,b,c)
	local turns = orient(a,b,p) + orient(b,c,p) + orient(c,a,p)
	return turns==3
end

function fan_triangulate(points)
	points=convert_point_list(points)
	local v,i={},3
	while i<=#points do
		add(v,points[i].x)
		add(v,points[i].y)
		add(v,points[i-1].x)
		add(v,points[i-1].y)
		add(v,points[1].x)
		add(v,points[1].y)
		i+=1
	end
	return v
end

function strip_triangulate(points)
	points=convert_point_list(points)
	if (#points<=3) then
		local v={}
		for i=1,#points do
			add(v,points[i].x)
			add(v,points[i].y)
		end
		return v
	end
	
	local v,i={},4
	add(v,points[1].x)
	add(v,points[1].y)
	add(v,points[2].x)
	add(v,points[2].y)
	add(v,points[3].x)
	add(v,points[3].y)
	while i<=#points do
		add(v,points[i].x)
		add(v,points[i].y)
		add(v,points[i-1].x)
		add(v,points[i-1].y)
		add(v,points[i-2].x)
		add(v,points[i-2].y)
		i+=1
	end
	return v
end

function convert_point_list(t)
	--converts a list of points from various formats to {vec,vec,vec...}
	--this is used for various operations when loading or making polygons
	--but not for storing/rendering the vector sprites themselves
	if #t>0 and type(t[1])=="userdata" then
		if t[1]:width()==2 then
			--already correct vector format
			return t
		end
	end
	local l = {}
	if type(t)=="userdata" then
		--assume its a userdata list of [x0,y0,x1,y1,...]
		for i=0,t:width()-1,2 do
			add(l, vec(t[i],t[i+1]) )
		end
		return l
	end
	
	if #t>0 
	and type(t[1])=="table" and #t[1]==2 then
		--assume it's a list of tables, each table describing a point
		for i=1,#t do
			if t[i].x then
				add(l, vec(t[i].x,t[i].y) )
			else
				add(l, vec(t[i][1],t[i][2]) )
			end
		end
	else
		--assume its a list of {x0,y0,x1,y1,...}
		for i=1,#t,2 do
			add(l, vec(t[i],t[i+1]) )
		end
	end
	return l
end
function one_d_point_list(t)
	--converts table {vec,vec,...} to userdata [x0,y0,x1,y1,...]
	local l = userdata("f64", #t*2)
	local udi=0
	for i=1,#t do
		l[udi]=t[i].x
		l[udi+1]=t[i].y
		udi+=2
	end
	return l
end
:: vsprite.lua
--[[pod_format="raw",created="2024-03-26 14:47:25",modified="2024-12-11 15:56:24",revision=9040]]
--a vector sprite is an array of layers (polygons)

vspr = {}--current working sprite
curr_layer = -1


function create_vsprite(empty)
	local new_vsprite = {
		layers={},
		icon=nil,
	}
	add_undo_stack(new_vsprite)
	

	if (not empty) add(new_vsprite.layers, create_layer())
	
	--undo_checkpoint(new_vsprite)

	add(vsprites, new_vsprite)
	return new_vsprite
end


function get_spr_icon(s)
	if s.icon!=nil then
		return s.icon
	end
	
	local pointcount = 0 
	
	
	
	local sprite = get_sprite(s)
	local bounds = {l=9999,r=-9999,t=9999,b=-9999}
	for l=1,#sprite do
		if sprite[l].pts then
			for i=0,#sprite[l].pts,2 do
				pointcount+=1
				bounds.l=min(bounds.l,sprite[l].pts[i])
				bounds.r=max(bounds.r,sprite[l].pts[i])
				bounds.t=min(bounds.t,sprite[l].pts[i+1])
				bounds.b=max(bounds.b,sprite[l].pts[i+1])
			end
		end
	end
	--also check points that aren't part of fills (outline/stroke)
	for l=1,#sprite do
		if sprite[l].lpts then
			for i=0,#sprite[l].lpts,2 do
				pointcount+=1
				bounds.l=min(bounds.l,sprite[l].lpts[i])
				bounds.r=max(bounds.r,sprite[l].lpts[i])
				bounds.t=min(bounds.t,sprite[l].lpts[i+1])
				bounds.b=max(bounds.b,sprite[l].lpts[i+1])
			end
		end
	end

	if pointcount==0 then
		--empty sprite
		return 9
	end

	local middle = vec(bounds.l+bounds.r,bounds.t+bounds.b)*0.5
	middle = vec(bounds.l,bounds.t)
	
	local rescale = 16/max(bounds.r-bounds.l,bounds.b-bounds.t)

	local drawspace = get_drawspace()
	camera(0,0)
	clip()

	s.icon = userdata("u8", 16, 16) -- width, height
	set_draw_target(s.icon)
	sprv(sprite, -middle.x*rescale*0.5+4,-middle.y*rescale*0.5+4, 0,rescale)
	set_draw_target()
	
	set_drawspace(drawspace)

	return s.icon
end



function get_sprite(v)
	local s = {}
	for i=1,#v.layers do
		if v.layers[i].show then
			local ol = false
			if #v.layers[i].points_triangulated==0 then
				if v.layers[i].type=="line" or v.layers[i].type=="line_closed" then
					--its a lines-only layer
					ol=true
				elseif v.layers[i].type=="fan" then
					v.layers[i].points_triangulated = fan_triangulate(v.layers[i].points)
				elseif v.layers[i].type=="strip" then
					v.layers[i].points_triangulated = strip_triangulate(v.layers[i].points)
				else
					v.layers[i].points_triangulated = earclip_triangulate(v.layers[i].points)
				end
			end
			
			
			local olcol = v.layers[i].outline-->=0 and v.layers[i].outline or v.layers[i].col_a
			if (#v.layers[i].points>1 and (v.layers[i].outline!=-1 or ol)) then
				ol={}
				for p=1,#v.layers[i].points do
					add(ol,vec(v.layers[i].points[p].x,v.layers[i].points[p].y))
				end
				if v.layers[i].type!="line" and v.layers[i].type!="strip" then
					--we close the outline
					add(ol,ol[1])
				end
			end
			if (olcol<0) olcol = v.layers[i].col_a
			
			add(s, make_polygon(
				v.layers[i].points_triangulated,
				(v.layers[i].col_b<<8)+v.layers[i].col_a,
				v.layers[i].fill,
				ol,
				olcol
			) )
			
		end
	end
	return s
end

function points_to_lua(pts,close)
	local point_str = ""
	for p=1, #pts do
		point_str..="vec("..tostr(pts[p].x)..","
		point_str..=tostr(pts[p].y)..")"
		if (p<#pts) point_str..=","
	end
	if close then
		point_str..=",vec("..tostr(pts[1].x)..","
		point_str..=tostr(pts[1].y)..")"
	end
	return point_str
end
function copy_spr_as_lua(s)
	local luastr = "myvectorsprite={\n"
	
	local polystr = ""
	for i=1,#s.layers do
		polystr ="make_polygon("
		--verts
		if s.layers[i].type=="fan" then
			polystr..="fan_triangulate({"
		elseif s.layers[i].type=="strip" then
			polystr..="strip_triangulate({"
		else
			polystr..="earclip_triangulate({"
		end
		polystr..=points_to_lua(s.layers[i].points)
		--[[
		for p=1, #s.layers[i].points do
			polystr..="vec("..tostr(s.layers[i].points[p].x)..","
			polystr..=tostr(s.layers[i].points[p].y)..")"
			if (p<#s.layers[i].points) polystr..=","
		end
		--]]
	
		polystr..="}),"
		
		--color
		polystr..="("..tostr(s.layers[i].col_b).."<<8)+"..tostr(s.layers[i].col_a)
		polystr..=","
		
		--pattern
		polystr..=tostr(s.layers[i].fill)
		polystr..=","
		
		--outline
		if s.layers[i].outline>=0
		or s.layers[i].type=="line"
		or s.layers[i].type=="line_closed" then
			polystr..="{"..points_to_lua(s.layers[i].points,true).."}"
			polystr..=","
		else
			polystr..="nil,"
		end
		
		--outlinecol
		polystr..=tostr(s.layers[i].outline)
		polystr..=")"--make_polygon

		luastr..=polystr
		if (i<#s.layers) luastr..=",\n"
	end
	
	luastr..="\n}"
	
	set_clipboard(luastr)
	notify("Sprite instantiation code copied to clipboard")
	
end
:: .info.pod
b64$LS1bW3BvZCx0aXRsZT0iViBFZGl0b3IiLGF1dGhvcj0iU29waGllIEgiLG1vZGlmaWVkPSIy
MDI0LTEyLTExIDE1OjU2OjUzIixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDAwMDAxMDEw
MTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMDAx
MDcwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMDAxMDcwZDBkMDcwZDBkMGQwZDBkMGQwNzBkMGQw
NzAxMDEwNzBkMGQwNzA3MGQwZDBkMGQwNzA3MGQwZDA3MDEwMTA3MGQwZDBkMDcwNzBkMGQwNzA3
MGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3MDcwZDA3MDcwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMDcw
NzA3MDcwZDBkMGQwZDA3MDEwMTA3MGQwZDA3MGQwNzA3MDcwNzBkMDcwZDBkMDcwMTAxMDcwZDBk
MDcwZDBkMDcwNzBkMGQwNzBkMGQwNzAxMDEwNzBkMGQwNzA3MGQwNzA3MGQwNzA3MGQwZDA3MDEw
MTA2MDcwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDYwMTAxMDYwNjA3MDcwNzA3MDcwNzA3MDcwNzA3
MDYwNjAxMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAwMDEwNjA2MDYwNjA2MDYw
NjA2MDYwNjAxMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwIiksY3JlYXRlZD0i
MjAyNC0wNC0xNiAxNzoxOTo0MiIsbm90ZXM9IkEgVmVjdG9yIEdyYXBoaWNzIGVkaXRvclxuZm9y
IHVzZSB3aXRoIHZnZngubHVhIixzdG9yZWQ9IjIwMjQtMDQtMTYgMTI6NTg6NTciLHJ1bnRpbWU9
MTIsdmVyc2lvbj0iMS4wMiIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMzOSIsd29y
a3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0idnNwcml0ZS5sdWEjMTAiLHdvcmtzcGFjZV9pbmRl
eD0xfSx7bG9jYXRpb249InVuZG8ubHVhIzQyIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9u
PSJjYW52YXMubHVhIzY0Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJsYXllci5sdWEj
MTMiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249Imd1aS5sdWEjNTM1Iix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJpbnB1dC5sdWEjMTAiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9j
YXRpb249InNldHRpbmdzLmx1YSMzOSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0idmdm
eC5sdWEjMTY0Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJoZWxwLmx1YSM2MiIsd29y
a3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn19
XV0=
:: [eoc]
