picotron cartridge // www.picotron.net
version 2

:: cards_api/
:: cards_api/button.lua
--[[pod_format="raw",created="2024-03-18 02:31:29",modified="2024-07-21 13:23:51",revision=11211]]

-- this could use more work
-- the purpose is to allow for animated sprite buttons

-- group 2 is drawn on top of group 1
-- and 3 on top of 2
buttons_all = {
	{},
	{},
	{},
}

function button_draw_all(group)
	local buttons = buttons_all[group]
	for b in all(buttons) do
		b:draw()
	end
end

function button_destroy(button)
	if button.on_destroy then
		button:on_destroy()
	end
	
	del(buttons_all[button.group], button)
end

function button_destroy_all()
	for buttons in all(buttons_all) do
		for b in all(buttons) do
			b:destroy()
		end
	end
end

-- checks what buttons are being highlighted
function button_check_highlight(mx, my, force_off)
	local allow = not force_off
	local layer_hit = force_off and 0 or nil
	
	--for buttons in all(buttons_all) do
		--for b in all(buttons) do
	for i = #buttons_all, 1, -1 do
		local buttons = buttons_all[i]
		
		for j = #buttons, 1, -1 do
			local b = buttons[j]
			b.hit = allow and point_box(mx, my, b.x, b.y, b.width, b.height)
			b.highlight = b.on_click and b.hit
			allow = allow and not b.hit
		end
		
		-- find the highest layer highlighted
		if not allow and not layer_hit then
			layer_hit = i
		end
	end
	
	return layer_hit or 0
end

-- checks what button to click
function button_check_click(group, interact)	
	local buttons = buttons_all[group]
	
	for j = #buttons, 1, -1 do
		local b = buttons[j]
		
		if b.enabled and b.hit
		and (b.always_active or interact) then
			if b.on_click then
				b:on_click()
			end
			return true
		end
	end
	
	return false
end

--[[
creates a new button

param is a table that can take the following values

x, y = top left position of the interactable space of the button, in pixels
width, height = size of the interactable space of the button, in pixels
draw = function called when it's time to draw the button
on_click = function called when the button is clicked
enabled = boolean for if the button can be clicked
always_active = if true, the button can always be clicked if it's highlighted
	if false, the button will not be clickable when the game is frozen or if there is an coroutine playing
	see cards_api_set_frozen and cards_api_coroutine_add in cards_base.lua
on_destroy = called when the button is destroyed
group = layer that the buttons will be drawn on, forcing partial draw and click order
	1 = base game
	2,3 = primarily reserved for ui
bottom = when true, adds the button to the start of the list of buttons instead of the end
	this can help with the draw order


the button has some extra properties

hit = is set true when the cursor is over the button
highlight = same as hit, but false the button has no on_click function
]]

function button_new(param)
	local b = {
		x = 0, y = 0,
		width = 16, height = 16,
		--draw = param.draw,
		--on_click = param.on_click,
		hit = false,
		highlight = false,
		enabled = true,
		always_active = false,
		destroy = button_destroy,
	}
	
	param.group = param.group or 1
	local buttons = buttons_all[param.group or 1]
	if param.bottom then
		add(buttons, b, 1)
	else
		add(buttons, b)
	end
	param.bottom = nil
	
	for k,v in pairs(param) do
		b[k] = v
	end
	
	return b
end

--[[
creates a simple animated button that fits a given string of text

s = text displayed on the button
x, y = position of the button
on_click = function called when the button is clicked
]]
function button_simple_text(s, x, y, on_click)
	local w, h = print_size(s)
	w += 9
	h += 4
	
	return button_new({
		x = x, y = y, 
		width = w, height = h, 
		draw = function(b)
			nine_slice(55, b.x, b.y+3, b.width, b.height)
			
			local click_y = sin(b.ct/2)*3
			nine_slice(b.highlight and 53 or 54, b.x, b.y-click_y, b.width, b.height)
			local x, y = b.x+5, b.y+3 - click_y
			print(s, x, y+1, 32)
			print(s, x, y, b.highlight and 3 or 19)
			b.ct = max(b.ct - 0.08)
		end, 
		on_click = function(b)
			b.ct = 1
			on_click(b)
		end,
		ct = 0
	})
end

function button_center(b, x)
	b.x = (x or 240) - b.width/2
end

:: cards_api/card.lua
--[[pod_format="raw",created="2024-03-16 12:26:44",modified="2024-07-21 13:23:51",revision=16415]]

cards_all = {}
card_shadows_on = true

cards_animated = {}
cards_occlusion = 4 -- extended pixels from the card's size

function get_all_cards()
	return cards_all
end


--[[
creates and returns a card

param is a table that can have the following key values

x, y = position of card, though this usually isn't needed
	if param.stack is provided, then 
a = starting angle of the 
	0 = face up
	0.5 = face down
width, height = size of the card, usually should match the size of the card sprite
sprite = front face sprite of card, can be a sprite id or userdata
sprite_back = back face sprite of card, can be a sprite id or userdata
stack = stack the card will be place in
on_destroy = called when the card is to be destroyed

additional parameters can be provided to give the stack more properties

x, y, a, x_offset, y_offset, should not be altered directly after creating the card
instead use x_to, y_to, a_to
x, y, a, x_offset, y_offset, are assigned smooth_val, which are allowed to be called like a function
	see util.lua

x_offset_to, y_offset_to = extra offsets for when drawing the card
]]
function card_new(param)
	local x = param.x or param.stack and param.stack.x_to or 0
	local y = param.y or param.stack and param.stack.y_to or 0
	local a = param.a or 0
	
	param.width = param.w or param.width or 45
	param.height = param.h or param.height or 60
	
-- todo??? make a card metatable with a weak reference to a stack
-- sometimes after a lot of testing, picotron runs out of memory
-- stacks/cards might not be garbage collected due to referencing eachother
-- I think this only occurs if exiting in the middle of a game

	-- expects sprite to be a number, userdata, or table with .sprite
	
--	!!! if x, y, a or their to values are changed, need to update stack_quick_swap
	local c = add(cards_all, {
		ty = "card",
		
		x = smooth_val(x, 0.7, 0.1), 
		y = smooth_val(y, 0.7, 0.1), 
		x_offset = smooth_val(0, 0.5, 0.3), 
		y_offset = smooth_val(0, 0.5, 0.3), 
		a = smooth_angle(a, 0.7, 0.12),
		
		x_to = x,
		y_to = y,
		x_offset_to = 0,
		y_offset_to = 0,
		a_to = a,
		
		--width = w,
		--height = h,
		wh_key = tostr(param.width) .. "," .. tostr(param.height),
		
		--sprite = param.sprite,
		--back_sprite = param.back_sprite,
		shadow = 0,
		
		destroy = card_destroy,
	})
	
		
	if param.stack then
		stack_add_card(param.stack, c)
		param.stack = nil
	end	
	
	-- clear values that shouldn't be copied from param
	param.x = nil
	param.y = nil
	param.a = nil
	param.x_offset = nil
	param.y_offset = nil
	
	for k,v in pairs(param) do
		c[k] = v
	end

	return c
end

-- removes a card from the game and the stack it belonged to
function card_destroy(c)
	if c.on_destroy then
		c:on_destroy()
	end
	
	if c.stack then
		del(c.stack, c)
	end
	c.stack = nil
	
	del(cards_all, s)
end

-- drawing function for cards
-- shifts vertical lines of pixels to give the illusion if the card turning
function card_draw(c)
	-- early exit for occlusion
	local ot = c._occlusion_type
	if(c._occlusion_type == "nodraw") return
	

	local facing_down = (c.a()-0.45) % 1 < 0.1 -- facing 45 degree limit for facing down
	local sprite = facing_down and c.back_sprite or c.sprite
	
	local x, y, width, height = c.x() + c.x_offset(), c.y() + c.y_offset(), c.width, c.height
	--local angle = (c.x"vel" + c.x_offset"vel") / -100 + c.a()
	local angle = c.a()
	local v = c.x"vel" + c.x_offset"vel"
	angle += sgn(v) * (0.25 / (abs(v)/10+1) - 0.25)
		
	local dx, dy = cos(angle), -sin(angle)*0.5
	if dx < 0 then
		sprite = c.back_sprite
		dx = -dx
		dy = -dy
	end
	
	if(type(sprite) == "table") sprite = sprite.sprite

	if card_shadows_on then
		card_shadow_draw(c, x, y, width, height, dx, dy)
	end

	if abs(dy*c.width) < 1 then
		-- draw normally
		if not ot then
			sspr(sprite, 0, 0, width, height, x, y)
			
		-- apply occlusion
		else
			local am = c._occlusion_amount
			local w = abs(c._occlusion_amount) + cards_occlusion
			if ot == "y" then
				w = min(height, w)
				if am > 0 then
					sspr(sprite, 0, height - w, width, w, x, y+height-w)
				else
					sspr(sprite, 0, 0, width, w, x, y)
				end
				
			elseif ot == "x" then
				w = min(width, w)
				if am > 0 then
					sspr(sprite, width-w, 0, w, height, x+width-w, y)
				else
					sspr(sprite, 0, 0, w, height, x, y)
				end
			end			
		end
	else
		local x = x - dx*width/2 + width/2
		local sx = 0
		y -= dy * width / 2
		y += 0.5
		
		local last_drawn = -999
		for x2 = 0,width - 1 do
			-- only draw one vertical slice at a time
			-- could do this mathmatically, but nah :)
			if x\1 ~= last_drawn then
				sspr(sprite, x2, 0, 1, height, x, y)
				last_drawn = x\1
			end
			x += dx
			y += dy
		end
	end
end


function card_shadow_draw(c, x, y, width, height, dx, dy)

	c.shadow = lerp(c.shadow, c.stack == held_stack and 1 or -0.1, 0.2 - mid((abs(c.x"vel") - abs(c.y"vel"))/15, 0.15))
	
	--subtle effect for cards that are moving around
	--local v = c.stack == held_stack and 1 or mid((abs(c.x"vel") + abs(c.y"vel"))/5-0.1, 1, -0.1)
	--c.shadow = lerp(c.shadow or 0, v, 0.2 - mid((abs(c.x"vel") + abs(c.y"vel"))/15, 0.15))		
	
	if c.shadow > 0 then
		
		local xx = x - dx*width/2 + width/2
		local x1, y1, x2, y2 = xx, y+7 + height/3, xx+width*dx-1, y+height+6 + abs(dy)*c.width/3 - (1-c.shadow) * 10
		local xmid = (x1+x2)/2
		x1 = min(x1, xmid-7)
		x2 = max(x2, xmid+7)
		poke(0x5509, 0xff) -- only shadow once on a pixel
		poke(0x550b, 0xff)
		-- poke 4/8 here?
		
		fillp(0xa5a5a5a5a5a5a5a5)
	
		local xmid = (x1+x2)/2
		local xc1, xc2 = x1+4,  x2-4
		rectfill(x1, y1, x2, y2-4, 32)
		rectfill(x1+4, y2-8, x2-4, y2)
		circfill(x1+4, y2-4, 4)
		circfill(x2-4, y2-4, 4)
		circfill(xmid, y1, 7)
		fillp()
		
		x1 += 3
		x2 -= 3
		y2 -= 3
		
		rectfill(x1, y1, x2, y2-4)
		rectfill(x1+4, y2-8, x2-4, y2)
		circfill(x1+4,y2-4,4)
		circfill(x2-4,y2-4,4)
		circfill(xmid,y1,4)
		
		poke(0x5509, 0x3f)
		poke(0x550b, 0x3f)
	end
end

-- card overlap optimization setup
-- currently expects all cards to have a stack and all cards in the stack to be the same size
-- done just before any card is drawn
function card_occlusion_update()
	if cards_occlusion then
		for s in all(stacks_all) do
			local cards = all(s.cards)
			if not s._occlusion_off and #s.cards > 1 then
				local lc = cards()
				
				-- find the first card that isn't changing the angle (tilted is a bit harder to occlude
				while lc and (lc.x"vel" ~= 0 or lc.a"vel" ~= 0) do
					lc._occlusion_type = nil
					lc = cards()
				end
			
				if lc then
					lc._occlusion_type = nil
					local lx, ly = (lc.x() + lc.x_offset())\1, (lc.y() + lc.y_offset())\1
				
					for c in cards do
						-- if the card is moving in any way, there should be no occlusion
						-- however, give the next card a try 
						if c.x"vel" ~= 0 or c.a"vel" ~= 0 then
							c._occlusion_type = nil
							lc._occlusion_type = nil
							
						else	
							local cx, cy = (c.x() + c.x_offset())\1, (c.y() + c.y_offset())\1
							
							-- calculate the type of occlusion and the amount
							if cx == lx then
								if cy == ly then
									lc._occlusion_type = "nodraw"
								else
									lc._occlusion_type = "y"
									lc._occlusion_amount = ly - cy
								end
							elseif cy == ly then
								lc._occlusion_type = "x"
								lc._occlusion_amount = lx - cx
							else
								lc._occlusion_type = nil
							end
							
							-- use current card in the next step
							lc, lx, ly = c, cx, cy
						end
					end
				end
			end
			lc = s.cards[#s.cards]
			-- reset occlusion values for the rest of the cards
			if lc then
				lc._occlusion_type = nil
			end
			for c in cards do
				c._occlusion_type = nil
			end
		end
		
	else
		for c in all(cards_all) do
			c._occlusion_type = nil
		end
	end
end

-- updates cards position and angle
function card_update(card)
	card.x(card.x_to)
	card.y(card.y_to)
	card.x_offset(card.x_offset_to)
	card.y_offset(card.y_offset_to)
	card.a(card.a_to - card.x"vel"/10000)
end

-- puts the given card above all other cards in drawing order
-- based on the card's stack's top_most value
-- should normally call AFTER changing the stack
-- 		if all stacks have the same priority, this won't matter
function card_to_top(card)
-- old method that just pushed the card to the top
--	add(cards_all, del(cards_all, card))

	del(cards_all, card)
	local tm = card.stack.top_most
	
	if #cards_all > 1 then
		for i = #cards_all, 1, -1 do
			local c2 = cards_all[i]
			if not c2.stack or c2.stack.top_most <= tm then
				add(cards_all, card, i+1)
				return
			end
		end
	end
	
	add(cards_all, card, 1)
end

function cards_into_stack_order(into_stack, held, i)
	local c_ins = into_stack.cards[i] 
	if c_ins then
		cards_to_insert(held, c_ins)
	else
		c_ins = into_stack.cards[i - 1] 
		if c_ins then
			cards_to_insert(held, c_ins, true)
		else
			stack_to_top(held)
		end
	end
end

-- puts the given stack of cards on top or below given card in drawing order
function cards_to_insert(stack, card, on_top)
	-- removes all cards first, to get correct insert position
	for c in all(stack.cards) do
		del(cards_all, c)
	end
	
	-- find position
	local c_ins = has(cards_all, card)
	if (on_top) c_ins += 1	
		
	-- reinsert cards
	for c in all(stack.cards) do
		add(cards_all, c, c_ins)
		c_ins += 1
	end
end

-- checks if the given card is on top of its stack
function card_is_top(card)
	return get_top_card(card.stack) == card
end

-- returns the top card of a stack
function get_top_card(stack)
	return stack.cards[#stack.cards]
end

-- makes a card back sprite that can be updated
function card_back_animated(data)

	local func = data.sprite
	
	data.gen = function(width, height)
		width = width or 45
		height = height or 60	

		local d2 = {}
		
		-- copy all values
		for k,v in pairs(data or {}) do
			d2[k] = v
		end
		
		-- unique param
		d2.param = {
			width = width, 
			height = height
		}
		for k,v in pairs(data.param or {}) do
			d2.param[k] = v
		end
		
		d2.sprite = userdata("u8", width, height)
		d2.param.target_sprite = d2.sprite
		
		d2.param.sprite = function(w, h)
			func(d2, w, h)
		end
		
		d2.update = function()			
			card_gen_back(d2.param)
		end
		
		d2.destroy = function()
			del(cards_animated, d2)
		end
						
		if type(data.init) == "function" then
			data.init(d2)
		end
		
		return add(cards_animated, d2)
	end
		
end

function card_back_animated_update()
	for c in all(cards_animated) do
		c.update()
	end
end

function card_position_reset_all()
	for s in all(stacks_all) do
		s:reposition()
	end
	foreach(cards_all, card_position_reset)
end

-- instantly places the card to it's target position
function card_position_reset(card)
	local s = card.stack
	if(not s) return
	
	card.x("pos", card.x_to)
	card.y("pos", card.y_to)
	card.x("vel", 0)
	card.y("vel", 0)

	card.a("pos", card.a_to)
	card.a("vel", 0)
end
:: cards_api/cards_base.lua
--[[pod_format="raw",created="2024-03-16 15:34:19",modified="2024-07-21 13:23:51",revision=26684]]

include"cards_api/util.lua"
include"cards_api/stack.lua"
include"cards_api/card.lua"
include"cards_api/button.lua"

--suite_save_folder = "/appdata/solitaire_suite"

mouse_last = 0
mouse_last_click = time() - 100
mouse_last_clicked = nil

hover_last = nil

local error_count = 0

local cards_coroutine = {}

-- main drawing function
-- wrapped in an error catcher
local function _cards_api_draw()
	card_back_animated_update()
	
	card_back_last = card_back
	
	if(game_draw) card_api_call_attempt(game_draw, 0)
	
	foreach(stacks_all, stack_draw)
	button_draw_all(1)
	
	if(game_draw) game_draw(1)
	
	card_occlusion_update()
	foreach(cards_all, card_draw)
	
	if(game_draw) game_draw(2)
	
	button_draw_all(2)
	
	if(game_draw) game_draw(3)
	
	button_draw_all(3)
	
	if(game_draw) game_draw(4)
end

function cards_api_draw()
	card_api_call_attempt(_cards_api_draw)
end

-- main update function
-- wrapped in an error catcher
local function _cards_api_update()
	
	-- don't accept mouse input when there is a coroutine
	-- though, coroutines are a bit annoying to debug
	if #cards_coroutine > 0 then
		local i = 1
		while i <= #cards_coroutine do
			local c = cards_coroutine[i]
			
			if(c[3] and i~=1) break -- wait if not first
			
			-- run coroutine
			local co = c[1]
			local ok, err = coresume(co)

			-- if error during coroutine
			if not ok then
				cards_api_display_error("*sub-game runtime error", co)
				cards_api_on_error()
				return
			end
			
			if not co or costatus(co) == "dead" then -- exit coroutine
				deli(cards_coroutine, i)
			end
			
			if(c[2]) break -- stop
			i += 1
		end

		cards_api_mouse_update(false)
		if #cards_coroutine == 0 then
			cards_api_action_resolved()
		end
		
		
	else
		cards_api_mouse_update(true)
	end

	for s in all(stacks_all) do
		s:reposition()
	end
	foreach(cards_all, card_update)	
	
	if(game_update) game_update()
	
	-- decreases error counter, can help track error loops
	error_count = max(error_count - 0.01)
end

function cards_api_update()
	card_api_call_attempt(_cards_api_update)
end


-- updates mouse interactions
-- not meant to be called outside
function cards_api_mouse_update(interact)
	local mx, my, md = mouse()
	local mouse_down = md & ~mouse_last
	local mouse_up = ~md & mouse_last
	local double_click = time() - mouse_last_click < 0.3	
	local clicked = false
	
	-- fix mouse interaction based on camera
	local cx, cy = camera()
	camera(cx, cy)
	mx += cx
	my += cy
		
	local layer_hit = button_check_highlight(mx, my, held_stack)
		
	if interact then
	
		-- check what is being hovered over this frame
		local hover_new = nil
		
		if not cards_frozen then 
			if held_stack then
				-- find closest card
				local dist = 99999
				for i = #cards_all, 1, -1 do
				
					local c = cards_all[i]
					if c.stack != held_stack then
					
						local d = card_overlaps_card(c, held_stack.cards[1]) 	
						if d and d < dist then
							dist, hover_new = d, c
						end
					end
				end
				
				-- if no closest card, find closest overlapping stack
				if not hover_new then
					for s in all(stacks_all) do
						if s != held_stack then
						
							local d = held_overlaps_stack(held_stack, s)
							if d and d < dist then
								dist, hover_new = d, s					
							end
						end
					end
				end


			else -- find what card the cursor is over
				for i = #cards_all, 1, -1 do
					local c = cards_all[i]
					if point_box(mx, my, c.x(), c.y(), c.width, c.height) then
						hover_new = c
						break
					end
				end
				
				-- check stacks instead
				if not hover_new then
					for s in all(stacks_all) do
						if point_box(mx, my, s.x_to, s.y_to, s.width, s.height) then
							hover_new = s
							break
						end
					end
				end
			end	
		end
		
		-- if a button is highlighted, then the cards below should not be hovered
		if layer_hit >= 2 then
			hover_new = nil
		end
		
		-- update on what has been hovered
		if hover_last != hover_new then
			--notify(tostr(hover_new) .. " " .. (hover_new and hover_new.ty or " "))
			
			if hover_last then -- if there was a element that the mouse is no longer hovering
				cards_api_hover_event(hover_last, false)
			end
			if hover_new then -- if there's a new element the mouse is hovering
				cards_api_hover_event(hover_new, true, true)
			end
						
		elseif hover_last then
			cards_api_hover_event(hover_last, true)
		end
		
		hover_last = hover_new
		
	
		-- on mouse press and no held stack
		if mouse_down&1 == 1 and not held_stack then
			-- first check button groups 3 and then 2 for a click
			if not clicked then
				clicked = button_check_click(3, interact)
			end
			
			if not clicked then
				clicked = button_check_click(2, interact)
			end	
			
			-- clicking a card, if possible
			if not clicked
			and not cards_frozen 
			and hover_last 
			and hover_last.ty == "card" then	
				
				if double_click 
				and mouse_last_clicked == hover_last
				and hover_last.stack.on_double then
					hover_last.stack.on_double(hover_last)
					mouse_last_clicked = nil
					
				else
					hover_last.stack.on_click(hover_last)
					mouse_last_clicked = hover_last
				end

				clicked = true
			end
			
			-- clicking a button in group 1
			if not clicked then
				clicked = button_check_click(1, interact)
			end
			
			-- clicking a stack, if possible
			if not clicked 
			and not cards_frozen 
			and hover_last
			and hover_last.ty == "stack" then
			
				if time() - mouse_last_click < 0.5 
				and mouse_last_clicked == hover_last 
				and hover_last.on_double then
					hover_last.on_double()
					mouse_last_clicked = nil
					
				else
					hover_last.on_click()
					mouse_last_clicked = hover_last
				end
				clicked = true
			end
			
			if clicked then
				cards_api_action_resolved()
			end
		end
		
		-- mouse release and holding stack
		if mouse_up&1 == 1 and held_stack then
			if hover_last then
				local s, c = nil
				if hover_last.ty == "stack" then
					s = hover_last
				elseif hover_last.ty == "card" then
					s, c = hover_last.stack, hover_last
				end
				
				if s and s:can_stack(held_stack, c) then
					s:resolve_stack(held_stack, c)
					held_stack = nil
				end
			end
			
			-- when a held stack hasn't been placed anywhere
			if held_stack then
				-- todo? allows for holding onto a stack that can't be returned
				-- will need to check if a stack is held when clicking
				-- which could just use the same release stack check
				
				-- if not func() then
				-- 		held_stack = nil
				-- end
				
				
				stack_apply_unresolved(held_stack)
				held_stack = nil
			end
			cards_api_action_resolved()
		end
		
		-- update stack's position
		if held_stack then
			--held_stack.x_to = mx - c.width/2
			--held_stack.y_to = my - c.height/2
			held_stack.x_to += mx - mlx
			held_stack.y_to += my - mly
		end
		
	else -- not interact, only check buttons that are always active
		if mouse_down&1 == 1 and not held_stack then
			if not clicked then
				clicked = button_check_click(3)
			end
			if not clicked then
				clicked = button_check_click(2)
			end
			if not clicked then
				clicked = button_check_click(1)
			end
		end
		
		highlighted_last = nil
	end

	if mouse_down&1 == 1 then
		mouse_last_click = time(s)
	end
	mouse_last = md
	mlx, mly = mx, my
end
mlx, mly = 0, 0

-- when an action is resolved, call the game's reaction function and check win condition
function cards_api_action_resolved()

	if(game_action_resolved) game_action_resolved()
	
	-- check if win condition is met
	if not cards_frozen and game_win_condition and game_win_condition() then
		if game_count_win then
			game_count_win()
			cards_api_set_frozen(true)
		end
	end
end

-- co is a coroutine to run
-- stop waits for this coroutine to finish before running the next one
-- wait prevents the coroutine from running unless it's the first
function cards_api_coroutine_add(co, stop, wait)
	if type(co) == "function" then
		co = cocreate(co)
	end
	assert(type(co) == "thread", "The first parameter must be a coroutine or function")
	add(cards_coroutine, {co, stop == nil or stop, wait})
end

function cards_api_coroutine_clear()
	cards_coroutine = {}
end


-- allows card interaction
-- may have more uses in the future
function cards_api_game_started()
	cards_api_set_frozen(false)
end

-- prevents interaction with cards and game specific buttons
function cards_api_set_frozen(freeze)
	cards_frozen = freeze
end

-- clears any objects being stored
function cards_api_clear(keep_func)
	-- removes recursive connection between cards to safely remove them from memory
	-- at least I believe this is needed
	for c in all(cards_all) do
		c.stack = nil
	end
	
	cards_all = {}
	stacks_all = {}
	button_destroy_all()
	
	cards_api_coroutine_clear()
	cards_api_set_frozen(false)
	
	-- TODO: remove or expand?
	if not keep_func then
		game_update = nil
		game_draw = nil
		game_action_resolved = nil
		game_win_condition = nil
	end
end

function cards_api_shadows_enable(enable, remap)
	
	cards_shadows_enabled = enable
	remap = remap or {0,1,21,19,20,21,22,6,24,25,9,27,16,18,13,31,1,16,2,1,21,1,5,14,2,4,11,3,12,13,2,4}

	if enable then
		poke(0x550b, 0x3f) -- target shapes
		
		-- shadow mask color
		for i, b in pairs(remap) do
			-- bit 0x40 is to change the table color to prevent writing onto shaded areas
			-- kinda like some of the old shadow techniques in 3d games
			poke(0x8000 + 32*64 + i-1, 0x40|b)
		end
		
	else
		poke(0x550b, 0x0) -- target shapes

		-- resets the colors
		for i, b in pairs(remap) do
			poke(0x8000 + 32*64 + i-1, 32)
		end
	end


	--[[ old version (no idea what is actually needed)
	if cards_shadows_enabled ~= enable then
		cards_shadows_enabled = enable
		
		if enable then
		--	poke(0x5508, 0xff) -- read
		--	poke(0x550a, 0xff) -- target sprite
			poke(0x550b, 0x3f) -- target shapes
			
			-- shadow mask color
			for i, b in pairs{0,1,21,19,20,21,22,6,24,25,9,27,16,18,13,31,1,16,2,1,21,1,5,14,2,4,11,3,12,13,2,4} do
				-- bit 0x40 is to change the table color to prevent writing onto shaded areas
				-- kinda like some of the old shadow techniques in 3d games
				poke(0x8000 + 32*64 + i-1, 0x40|b)
			end
			-- poke(0x5509, 0xff) -- enable writing new color table
			-- draw shadow
			-- poke(0x5509, 0x3f) -- disable
		
		else
		--	poke(0x5508, 0x3f) -- read
		--	poke(0x550a, 0x3f) -- target sprite
		--	poke(0x550b, 0x3f) -- target shapes
			-- todo, reset color table (probably not necessary
		end
	end
	]]
end

-- returns a distance to the stack if they overlap
function held_overlaps_stack(h, s)
	local y = stack_y_pos(s)
	local c = h.cards[1] -- expects there to be a card in the held stack
	
	if point_box(
		-- point
		h.x_to + c.width/2, 
		h.y_to + c.height/2,
		-- overlaps box (top left corner)
		s.x_to - s.width*0.25, 
		y - s.height*0.125, 
		-- box size (extended)
		s.width*1.5, s.height*1.25) then
		
		return abs(h.x_to - s.x_to) + abs(h.y_to - y)
	end
end

-- checks if two cards are overlapping, with a degree of inaccuracy allowed for better player use
function card_overlaps_card(a, b)
	if point_box(
		-- point
		a.x_to + a.width/2, 
		a.y_to + a.height/2,
		-- overlaps box (top left corner) 
		b.x_to - b.width * 0.25, 
		b.y_to - b.height * 0.125,
		-- box size (extended) 
		b.width * 1.5, b.height * 1.25) then
		
		return abs(a.x_to - b.x_to) + abs(a.y_to - b.y_to)
	end
end

-- st = stack or card being hovered
-- hovering = true if it's being hovered over
-- first_frame = true if it's the first frame being hovered
function cards_api_hover_event(st, hovering, first_frame)
	local c = nil	

	if st.ty == "card" then -- card is specifically being hovered over
		st, c = st.stack, st
	
	elseif st.ty == "stack" then -- stack is hovered over
		-- st already is the stack
	else
		return -- invalid object somehow
	end
	
	if st then
		if hovering then
			if st.on_hover then -- stack is hovered and has a response
				st:on_hover(c, held_stack)  -- stack, card, held stack
			end
		elseif st.off_hover then
			st:off_hover(c, held_stack)
		end
	end
end

-- calls a function, preventing an error from halting the entire program
-- calls cards_api_on_error to determine what to do after the error
function card_api_call_attempt(func, ...)
	local ok, err = pcall(func, ...)
	if not ok then
		cards_api_display_error("*runtime error", err)
		cards_api_on_error()
	end
	return ok
end

-- called when a major error occurs that would disrupt the game state
-- aims to allow the game to recover on its own
function cards_api_on_error()
	cards_coroutine = {}
	if not game_on_error or game_on_error() then
		exit()
	end
end


-- displays the error to the screen
function cards_api_display_error(message, err)
	--the * seems to be important
	--send_message(3, {event="report_error", content = "*syntax error"})
	--send_message(3, {event="report_error", content = "*runtime error"})
		
	send_message(3, {event="report_error", content = message})
	if type(err) == "thread" then
		send_message(3, {event="report_error", content = debug.traceback(err)})	
	else
		send_message(3, {event="report_error", content = tostr(err)})		
	end	
	
	-- prevents any error loops that occur
	error_count += 1
	if error_count > 30 then
		notify"continuous error detected"
		exit()
	end
end
:: cards_api/card_gen.lua
--[[pod_format="raw",created="2024-03-23 23:52:47",modified="2024-07-21 13:23:51",revision=2841]]

-- defaults were originally designed for Picotron Solitaire Suite

local default_suits = {
	--"Spades",
	--"Hearts",
	--"Clubs",
	--"Diamonds",
	--"Stars"
	"\|g\^:081c3e7f7f36081c",
	"\|g\^:00367f7f3e1c0800",
	"\|f\^:001c1c7f7f77081c",
	"\|g\^:081c3e7f3e1c0800",
	"\|g\^:081c7f7f3e362200"
}

local default_ranks = {
	"A",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"10",
	"J",
	"Q",
	"K",
	
-- just extra to reach rank 16, no reason for these
	"X",
	"Y",
	"Z",
}

-- [suit] = text, dark, medium, light
local default_suit_colors = {
	{16, 1,16,12},
	{8, 24,8,14},
	{27, 19,3,27},
	{25, 4,25,9},
--	{13, 12,26,10}
	{13, 18,13,29}
}

-- [rank] = {{x,y}, ...}
local default_suit_pos = {
	{{19, 28}},
	{{19, 17}, {19, 39}},
	{{19, 17}, {19, 28}, {19, 39}},
	{{9, 17}, {9, 39}, {29, 17}, {29, 39}},
	{{9, 17}, {9, 39}, {29, 17}, {29, 39}, {19, 28}},
	{{9, 17}, {9, 39}, {9, 28}, {29, 17}, {29, 39}, {29, 28}},
	{{19, 17},{19, 39},{19, 28}, {9, 23},{9, 34}, {29, 23},{29, 34}},
	{{9, 17},{9, 39},{9, 28}, {19, 23},{19, 34}, {29, 17},{29, 39},{29, 28}},
	{{19, 17},{19, 39},{19, 28}, {9, 23},{9, 34},{9, 45}, {29, 12},{29, 23},{29, 34}},
	{{9, 18},{9, 29},{9, 40}, {19, 13},{19, 24},{19, 35},{19, 46}, {29, 18},{29, 29},{29, 40}},	
}

-- [rank] = sprite OR {sprite, sprite, ...} (number of sprites equal to suits)
local default_face_sprites = {
-- ace
	[1] = {67,68,69,70,71},

-- face cards
	[11] = 66,
	[12] = 65,
	[13] = 64
}

--[[
generates and returns a table of tables of sprites based on a the given param table
type(sprites[suit][rank]) == "userdata"

param can take the following values
suit = number of suites
	defaults 4
ranks = number of ranks for all suits
	includes face cards
	defaults 13
suit_chars = table of strings that will be drawn on each sprite of that suit
	defaults to default_suits
rank_chars = table of strings that will be drawn on each sprite of that rank
	defaults to default_ranks
suit_colors = table of colors that will be used for what's drawn on the sprite based on the suit
	defaults to suit_colors
suit_pos = table of locations of the suit sprites from suit_chars, where the index is the rank of the card
	indicies can be empty
	defaults to default_suit_pos
suit_show = table of booleans for if the suit sprite should be drawn in the top left
	any missing booleans default to true
face_sprites = table of sprites to be drawn instead of suit sprites for given ranks
	for a single rank a table of sprites can be given to be used for each suit
	when provided, no suit sprites will be drawn
	indices can be skipped
	defaults to default_face_sprites
width = width of the sprites in pixels
	defaults to 45
height = height of the sprites in pixels
	defaults to 60
]]
function card_gen_standard(param)
	
	param = param or {}

	-- default values
	local suits = param.suits or 4
	local ranks = param.ranks or 13
	
	local suit_chars = param.suit_chars or default_suits
	local rank_chars = param.rank_chars or default_ranks
	local suit_colors = param.suit_colors or default_suit_colors
	local suit_pos = param.suit_pos or default_suit_pos
	local suit_show = param.suit_show or {}
	while #suit_show < ranks do
		add(suit_show, true)
	end
	
	local face_sprites = param.face_sprites or default_face_sprites
	
	local width = param.width or 45
	local height = param.height or 60
	
	local card_sprites = {}
	
	-- for each suit and rank
	for suit = 1,suits do
		local card_set = add(card_sprites, {})
		local col = suit_colors[suit]
		local suit_char = suit_chars[suit]
		
		for rank = 1,ranks do
			local rank_char = rank_chars[rank]
			
			-- prepare render
			local new_sprite = userdata("u8", width, height)
			set_draw_target(new_sprite)
			
			-- draw card base
			nine_slice(8, 0, 0, width, height)
			
			-- draw rank/suit
			print(rank_char .. (suit_show[rank] and suit_char or ""), 3, 3, col[1])
			
			local sp = face_sprites[rank]
			local pos = suit_pos[rank]
			
			-- draw sprite if it calls for it
			if sp then 
				pal(24, col[2], 0)
				pal(8, col[3], 0)
				pal(14, col[4], 0)
				spr(type(sp) == "table" and sp[suit] or sp)
				pal(24,24,0)
				pal(8,8,0)
				pal(14,14,0)
			
			 -- draws the icons at given positions
			elseif pos then
				 -- shadows
				for p in all(pos) do
					print(suit_char, p[1]+1, p[2]+2, 32)
				end
				-- base
				color(col[1])
				for p in all(pos) do
					print(suit_char, p[1], p[2])
				end	
			end
			
			add(card_set, new_sprite)
		end
	end
	
	-- important to reset the draw target for future draw operations.
	set_draw_target()
	
	return card_sprites
end

--[[
generates and returns a card back sprite based on the given param table

param can take the following values

sprite = sprite drawn in the center of the card back, behind the border
	defaults to sprite 112, but this should always be replaced
border = sprite to be used with nineslice to draw at the edge of the generated sprite
	defaults to sprite 25
width, height = size of generated sprite, defaults to 45 and 60
left, right, top, bottom = pixels to cut off param.sprite
	defaults to 2
target_sprite = sprite to drawn on, will 
]]
function card_gen_back(param)

	-- expects sprite to be 100x100 pixels at least
	-- width a default size of 45x60

	param = param or {}

	local sprite = param.sprite or 112
	local border = param.border or 25
	local width = param.width or 45
	local height = param.height or 60
	
	local left = param.left or 2
	local right = param.right or 2
	local top = param.top or 2
	local bottom = param.bottom or 2
	
	local new_sprite = param.target_sprite or userdata("u8", width, height)
	set_draw_target(new_sprite)
	
	local ty = type(sprite)
	if ty == "number" then
		sprite, ty = get_spr(sprite), "userdata"
	end
	
	local w2 = width - left - right
	local h2 = height - top - bottom	
	
	if ty == "function" then
		camera(-left,-right)
		clip(left, right, w2, h2)
		sprite(w2, h2)
		camera()
		clip()
		
	elseif ty == "userdata" then		
		sspr(sprite, 
			(sprite:width() - width)\2 + left,
			(sprite:height() - height)\2 + top, 
			w2,h2, 
			left,top)
	end
	
	nine_slice(border, 0, 0, width, height)
	
	set_draw_target()
	camera()
	
	return new_sprite
end


:: cards_api/LICENSE.txt
MIT License

Copyright (c) 2024 Werxzy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

:: cards_api/README.md
b64$DQojIyBEZWZpbmVhYmxlIEdhbWUgRnVuY3Rpb25zDQoNCmBgYGx1YQ0KLS0gY2FsZWQgZXZl
cnkgX2RyYXcsIGdpdmluZyBjb250cm9sIHdoZW4gdG8gZHJhdyB3aXRoIGxheWVyDQpmdW5jdGlv
biBnYW1lX2RyYXcobGF5ZXIpDQoJaWYgbGF5ZXIgPT0gMCB0aGVuDQoJCS0tIGJlZm9yZSBhbnl0
aGluZyBlbHNlIGlzIGRyYXduDQoJCS0tIG1ha2Ugc3VyZSB0byBjYWxsIGNscw0KCQ0KCWVsc2Vp
ZiBsYXllciA9PSAxIHRoZW4NCgkJLS0gYWZ0ZXIgc3RhY2sgc3ByaXRlcyBhbmQgZ3JvdXAgMSBi
dXR0b25zIGFyZSBkcmF3biwgYmVmb3JlIGNhcmRzDQoJDQoJZWxzZWlmIGxheWVyID09IDIgdGhl
bg0KCQktLSBhZnRlciBjYXJkcyBhcmUgZHJhd24NCg0KCWVsc2VpZiBsYXllciA9PSAzIHRoZW4N
CgllbHNlaWYgbGF5ZXIgPT0gNCB0aGVuDQoJCS0tIGxheWVycyAzIGFuZCA0IGFyZSBtb3N0bHkg
cmVzZXJ2ZWQgZm9yIHVpDQoJCS0tIGRyYXduIGFmdGVyIGJ1dHRvbiBncm91cHMgMiBhbmQgMw0K
CQ0KCWVuZA0KZW5kDQoNCi0tIGNhbGxlZCBldmVyeSBfdXBkYXRlLCBhZnRlciBjYXJkIGFuZCBt
b3VzZSB1cGRhdGVzDQpmdW5jdGlvbiBnYW1lX3VwZGF0ZSgpDQplbmQNCg0KLS0gY2FsbGVkIGFm
dGVyIGFueSBhY3Rpb24gaXMgdGFrZW4NCi0tIGNsaWNraW5nLCBwaWNraW5nIHVwIGEgc3RhY2ss
IGxldHRpbmcgZ28gb2YgYSBzdGFjaywgYW5pbWF0aW9uIGZpbmlzaGVkLCBldGMNCmZ1bmN0aW9u
IGdhbWVfYWN0aW9uX3Jlc29sdmVkKCkNCglpZiBub3QgaGVsZF9zdGFjayB0aGVuDQoJCS0tIGl0
J3Mgc29tZXRpbWVzIGEgZ29vZCBpZGVhIHRvIG5vdCB1cGRhdGUgYW4gb2JqZWN0IHdoZW4gdGhl
IHBsYXllciBpcyBob2xkaW5nIGEgc3RhY2sgb2YgY2FyZHMNCgllbmQNCmVuZA0KDQotLSByZXR1
cm5zIHRydWUgd2hlbiB0aGUgZ2FtZSBoYXMgcmVhY2hlZCBhIHdpbm5pbmcgc3RhdGUNCi0tIGNh
bGxlZCByaWdodCBhZnRlciBnYW1lX2FjdGlvbl9yZXNvbHZlZA0KLS0gd2hlbiByZXR1cm5pbmcg
dHJ1ZSwgd2lsbCBzZXQgY2FyZHNfZnJvemVuID0gdHJ1ZQ0KZnVuY3Rpb24gZ2FtZV93aW5fY29u
ZGl0aW9uKCkNCglyZXR1cm4gZmFsc2UNCmVuZA0KDQotLSBjYXJkc19mcm96ZW4gd2lsbCBwcmV2
ZW50IGFueSBtb3VzZSBpbnRlcmFjdGlvbiB3aXRoIGNhcmRzDQoNCi0tIGNhbGxlZCB3aGVuIGdh
bWVfd2luX2NvbmRpdGlvbiByZXR1cm5zIHRydWUNCmZ1bmN0aW9uIGdhbWVfY291bnRfd2luKCkN
CgktLSBjb3VudCBzY29yZSBhbmQvb3IgcGxheSBldmVudHMNCmVuZA0KYGBgDQoNCiMjIEFQSSBG
dW5jdGlvbnMgdG8gY2FsbA0KDQpgYGBsdWENCi0tIGNhbGxlZCB3aGVuIGEgZ2FtZSBoYXMgc3Rh
cnRlZCBhbmQgbW91c2UgaW50ZXJhY3Rpb24gc2hvdWxkIGJlIGFsbG93ZWQNCmNhcmRzX2FwaV9n
YW1lX3N0YXJ0ZWQoKQ0KDQotLSBjbGVhcnMgdGhlIHN0YWNrcywgYnV0dG9ucywgYW5kIGNhcmRz
IGZyb20gdGhlIHRhYmxlcyBhbmQgcmVzZXRzIHZhbHVlcyBvZiB0aGUgYXBpDQotLSB3aGVuIGtl
ZXBfZnVuYyBpcyBmYWxzZXksIGdhbWVfZHJhdywgZ2FtZV91cGRhdGUsIGdhbWVfYWN0aW9uX3Jl
c29sdmVkLCBhbmQgZ2FtZV93aW5fY29uZGl0aW9uIHdpbGwgYmUgc2V0IHRvIG5pbA0KLS0gY2Fy
ZHNfYXBpX2NsZWFyKGtlZXBfZnVuYykNCg0KLS0gZW5hYmxpbmcgd2lsbCBtYWtlIGNvbG9yIDMy
IGRyYXcgc2hhZG93cw0KY2FyZHNfYXBpX3NoYWRvd3NfZW5hYmxlKGVuYWJsZSkNCi0tIGN1c3Rv
bSByZW1hcGluZyBvZiBjb2xvcnMgKG1vc3RseSBmb3IgY3VzdG9tIGNvbG9yIHBhbGV0dGVzKSwg
Y29sb3IgMzIgaXMgc3RpbGwgcmVzZXJ2ZWQgZm9yIHNoYWRvd3MNCmNhcmRzX2FwaV9zaGFkb3dz
X2VuYWJsZShlbmFibGUsIHswLDQsMSwzLCAuLi59KQ0KYGBgDQoNCiMjIENhcmQgRnVuY3Rpb25z
DQoNCkEgY2FyZCBpcyBqdXN0IGEgdGFibGUgY29udGFpbmluZyBwb3NpdGlvbiBpbmZvcm1hdGlv
biwgYSBzcHJpdGUsIGFuZCB0aGUgc3RhY2sgaXQgYmVsb25ncyB0by4NCllvdSBjYW4gYXNzaWdu
IG90aGVyIHZhbHVlcyBsaWtlIHN1aXQgYW5kIHJhbmsgdG8gYWZmZWN0IGJlaGF2aW91cnMgdXNp
bmcgdGhlIGNhcmQuDQoNCmBgYGx1YQ0KLS0gY3JlYXRlcyBhbmQgcmV0dXJucyBhIGNhcmQNCmxv
Y2FsIGNhcmQgPSBjYXJkX25ldyh7IC4uLiB9KQ0KLS1bWw0KcGFyYW0gaXMgYSB0YWJsZSB0aGF0
IGNhbiBoYXZlIHRoZSBmb2xsb3dpbmcga2V5IHZhbHVlcw0KDQp4LCB5ID0gcG9zaXRpb24gb2Yg
Y2FyZCwgdGhvdWdoIHRoaXMgdXN1YWxseSBpc24ndCBuZWVkZWQNCglpZiBwYXJhbS5zdGFjayBp
cyBwcm92aWRlZCwgdGhlbiANCmEgPSBzdGFydGluZyBhbmdsZSBvZiB0aGUgDQoJMCA9IGZhY2Ug
dXANCgkwLjUgPSBmYWNlIGRvd24NCndpZHRoLCBoZWlnaHQgPSBzaXplIG9mIHRoZSBjYXJkLCB1
c3VhbGx5IHNob3VsZCBtYXRjaCB0aGUgc2l6ZSBvZiB0aGUgY2FyZCBzcHJpdGUNCnNwcml0ZSA9
IGZyb250IGZhY2Ugc3ByaXRlIG9mIGNhcmQsIGNhbiBiZSBhIHNwcml0ZSBpZCBvciB1c2VyZGF0
YQ0Kc3ByaXRlX2JhY2sgPSBiYWNrIGZhY2Ugc3ByaXRlIG9mIGNhcmQsIGNhbiBiZSBhIHNwcml0
ZSBpZCBvciB1c2VyZGF0YQ0Kc3RhY2sgPSBzdGFjayB0aGUgY2FyZCB3aWxsIGJlIHBsYWNlIGlu
DQpvbl9kZXN0cm95ID0gY2FsbGVkIHdoZW4gdGhlIGNhcmQgaXMgdG8gYmUgZGVzdHJveWVkDQoN
CmFkZGl0aW9uYWwgcGFyYW1ldGVycyBjYW4gYmUgcHJvdmlkZWQgdG8gZ2l2ZSB0aGUgc3RhY2sg
bW9yZSBwcm9wZXJ0aWVzDQpsaWtlIHN1aXQgYW5kIHJhbmsNCg0KDQp4LCB5LCBhLCB4X29mZnNl
dCwgeV9vZmZzZXQsIHNob3VsZCBub3QgYmUgYWx0ZXJlZCBkaXJlY3RseSBhZnRlciBjcmVhdGlu
ZyB0aGUgY2FyZA0KaW5zdGVhZCB1c2UgeF90bywgeV90bywgYV90bw0KeCwgeSwgYSwgeF9vZmZz
ZXQsIHlfb2Zmc2V0LCBhcmUgYXNzaWduZWQgc21vb3RoX3ZhbCwgd2hpY2ggYXJlIGFsbG93ZWQg
dG8gYmUgY2FsbGVkIGxpa2UgYSBmdW5jdGlvbg0KCXNlZSB1dGlsLmx1YQ0KDQp4X29mZnNldF90
bywgeV9vZmZzZXRfdG8gPSBleHRyYSBvZmZzZXRzIGZvciB3aGVuIGRyYXdpbmcgdGhlIGNhcmQN
Cl1dDQoNCi0tIHJldHVybnMgYSB0YWJsZSB3aXRoIGFsbCB0aGUgY2FyZHMNCmdldF9hbGxfY2Fy
ZHMoKQ0KDQotLSBwdXRzIHRoZSBjYXJkIGF0IHRoZSBlbmQgb2YgdGhlIGNhcmRzIHRhYmxlIHRv
IGRyYXcgdGhlIGNhcmQgb24gdG9wIG9mIGV2ZXJ5dGhpbmcgZWxzZQ0KY2FyZF90b190b3AoY2Fy
ZCkNCg0KLS0gcmV0dXJucyB0cnVlIGlmIHRoZSBjYXJkIGlzcyB0aGUgdG9wIGNhcmQgb2YgdGhl
IHN0YWNrIGl0IGlzIGluDQpjYXJkX2lzX3RvcChjYXJkKQ0KDQotLSBkZXN0cm95cyB0aGUgY2Fy
ZCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBzdGFjayBpdCdzIGluDQpjYXJkOmRlc3Ryb3koKQ0K
DQotLSByZXNldHMgdGhlIHBvc2l0aW9uIG9mIGFsbCBjYXJkcyB0byB0aGVpciBwcm9wZXIgcG9z
aXRpb24gb24gDQotLSB1c2VmdWwgZm9yIHRoZSBzdGFydCBvZiBsb2FkaW5nIGEgc2NlbmUsIHBy
ZXZlbmluZyBjYXJkcyBqdW1waW5nIGFyb3VuZA0KY2FyZF9wb3NpdGlvbl9yZXNldF9hbGwoKQ0K
YGBgDQoNCiMjIFN0YWNrIEZ1bmN0aW9ucw0KDQpNb3N0IG9mIHRoZSBtb3VzZSBpbnRlcmFjdGlv
bnMgd2l0aCBjYXJkcyBhcmUgYXV0b21hdGljYWxseSBoYW5kbGVkIHRocm91Z2ggc3RhY2tzLg0K
DQpgYGBsdWENCi0tIHJldHVybnMgYSB0YWJsZSB3aXRoIGFsbCB0aGUgc3RhY2tzDQpnZXRfYWxs
X3N0YWNrcygpDQoNCi0tIGdldHMgYW5kIHNldHMgdGhlIHN0YWNrIGN1cnJlbnRseSBoZWxkIGJ5
IHRoZSBtb3VzZQ0KLS0gdGhvdWdoIHJhcmVseSBuZWVkZWQsIGl0J3MgaW1wb3J0YW50IHRvIGZv
bGxvdyBpdHMgdXNhZ2UgaW4gZnVuY3Rpb25zIGxpa2Ugb25fY2xpY2sNCmdldF9oZWxkX3N0YWNr
KCkNCnNldF9oZWxkX3N0YWNrKHN0YWNrKQ0KDQotLSByZXR1cm5zIHRoZSB0b3AgY2FyZCBvZiB0
aGUgc3RhY2sNCmdldF90b3BfY2FyZChzdGFjaykNCg0KLS0gcmV0dXJucyBhIG5ldyBzdGFjayBh
bmQgYWRkcyBpdCB0byB0aGUgbWFpbiBzdGFjayB0YWJsZQ0KbG9jYWwgc3RhY2sgPSBzdGFja19u
ZXcoc3ByaXRlLCB4LCB5LCBwYXJhbSkNCi0tW1sNCnNwcml0ZXMgPSB0YWJsZSBvZiBzcHJpdGUg
aWRzIG9yIHVzZXJkYXRhIHRvIGJlIGRyYXduIHdpdGggc3ByDQp4LHkgPSB0b3AgbGVmdCBwb3Np
dGlvbiBvZiBzdGFjaw0KCXdpbGwgYmUgYXNzaWduZWQgdG8geF90byBhbmQgeV90bw0KDQpwYXJh
bSBpcyBhIHRhYmxlIHRoYXQgY2FuIGhhdmUgdGhlIGZvbGxvd2luZyBrZXkgdmFsdWVzDQoNCnhf
b2ZmLCB5X29mZiA9IGRyYXcgb2Zmc2V0cyBvZiB0aGUgc3RhY2sncyBzcHJpdGUocykNCnJlcG9z
aXRpb24gPSBmdW5jdGlvbiBjYWxsZWQgd2hlbiBjaGFuZ2luZyB0aGUgdGFyZ2V0IHBvc2l0aW9u
IG9mIHRoZSBjYXJkcw0KCXRoZSBmdW5jdGlvbiB1c3VhbGx5IGFzc2lnbnMgYWxsIGNhcmRzIC54
X3RvIGFuZCAueV90byB2YWx1ZXMgcmVsYXRpdmUgdG8gdGhlIHN0YWNrJ3MgcG9zaXRpb24NCglk
ZWZhdWx0cyB0byBzdGFja19yZXBvc2Vfbm9ybWFsDQpwZXJtID0gdGhlIHN0YWNrIGlzIGRlc3Ry
b3llZCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGNhcmRzIGlmIHRoaXMgaXMgbm90IHNldCB0cnVl
cw0KCWRlZmF1bHRzIHRvIHRydWUNCnRvcF9tb3N0ID0gY29udHJvbHMgdGhlIGRyYXcgb3JkZXIg
b2YgY2FyZHMgYmV0d2VlbiBzdGFja3MNCgl0aGUgaGlnaGVyIHRoZSBudW1iZXIsIHRoZSBoaWdo
ZXIgdGhlIHN0YWNrDQoJZGVmYXVsdHMgdG8gMA0KY2FuX3N0YWNrID0gZnVuY3Rpb24gY2FsbGVk
IHdoZW4gYW5vdGhlciBzdGFjayBvZiBjYXJkcyBpcyBwbGFjZWQgb24gdG9wICh3aXRoIHJlc3Ry
aWN0aW9ucykNCglmdW5jdGlvbihzZWxmLCBoZWxkKQ0KCXJldHVybnMgdHJ1ZSBpZiB0aGUgImhl
bGQiIGNhbiBiZSBwbGFjZWQgb24gdG9wIG9mICJzZWxmIg0Kb25fY2xpY2sgPSBmdW5jdGlvbiBj
YWxsZWQgd2hlbiBzdGFjayBiYXNlIG9yIGNhcmQgaW4gc3RhY2sgaXMgY2xpY2tlZA0KCXVzdWFs
bHkgc2V0IHRvIHN0YWNrX29uX2NsaWNrX3Vuc3RhY2soLi4uKQ0Kb25fZG91YmxlID0gZnVuY3Rp
b24gY2FsbGVkIHdoZW4gc3RhY2sgYmFzZSBvciBjYXJkIGluIHN0YWNrIGlzIGRvdWJsZSBjbGlj
a2VkDQpyZXNvbHZlX3N0YWNrID0gZnVuY3Rpb24gY2FsbGVkIHdoZW4gY2FuX3N0YWNrIHJldHVy
bnMgdHJ1ZQ0KCWRlZmF1bHRzIHRvIHN0YWNrX2NhcmRzDQp1bnJlc29sdmVkX3N0YWNrID0gZnVu
Y3Rpb24gY2FsbGVkIHdoZW4gYSBoZWxkIGNhcmQgaXMgcmVsZWFzZWQsIGJ1dCBpc24ndCBwbGFj
ZWQgb250byBhIHN0YWNrDQoJZGVmYXVsdHMgdG8gc3RhY2tfdW5yZXNvbHZlZF9yZXR1cm4NCm9u
X2hvdmVyID0gZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGN1cnNvciBvdmVyIHRoZSBzdGFjayBv
ciBjYXJkDQoJZnVuY3Rpb24oc2VsZiwgY2FyZCwgaGVsZCkNCglzZWxmID0gY3VycmVudCBzdGFj
aw0KCWNhcmQgPSB0aGUgaG92ZXJlZCBjYXJkDQoJaGVsZCA9IHN0YWNrIHRoYXQgaXMgYmVpbmcg
aGVsZCBieSB0aGUgcGxheWVyDQpvZmZfaG92ZXIgPSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUg
Y3Vyc29yIGlzIG5vIGxvbmdlciBvdmVyIHRoZSBzdGFjayBvciBjYXJkDQoJc2ltaWxhciBmdW5j
dGlvbiB0byBvbl9ob3ZlciwgY2FsbGVkIGJlZm9yZSB0aGUgbmV4dCBvbl9ob3ZlciBmdW5jdGlv
biBpcyBjYWxsZWQNCm9uX2Rlc3Ryb3kgPSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgc3RhY2sg
aXMgZGVzdHJveWVkDQoNCmFkZGl0aW9uYWwgcGFyYW1ldGVycyBjYW4gYmUgcHJvdmlkZWQgdG8g
Z2l2ZSB0aGUgc3RhY2sgbW9yZSBwcm9wZXJ0aWVzDQpdXQ0KDQotLSByZW1vdmVzIHRoZSBzdGFj
ayBmcm9tIHN0YWNrc19hbGwNCi0tIHRoZW4gY2FsbHMgc3RhY2s6b25fZGVzdHJveSgpIGlmIHBy
b3ZpZGVkDQotLSBpZiBjYXJkc190b28gaXMgdHJ1ZSwgdGhlbiB0aGUgc3RhY2sgZGVzdHJveXMg
YWxsIGNhcmRzIGluc2lkZSBpdA0KLS0gb3RoZXJ3aXNlLCBqdXN0IHNldHMgdGhlaXIgc3RhY2sg
dG8gbmlsDQpzdGFjazpkZXN0cm95KGNhcmRzX3RvbykNCg0KLS0gc3RhY2suY2FyZHNbMV0gaXMg
dGhlIGJvdHRvbSBjYXJkDQotLSBzdGFjay5jYXJkc1sjc3RhY2suY2FyZHNdIGlzIHRoZSB0b3Ag
Y2FyZA0KLS0gbGl0ZXJhbCBzdGFjaw0KDQotLSBwdXRzIGFsbCBjYXJkcyBmcm9tIHN0YWNrMiBv
biB0b3Agb2Ygc3RhY2sxDQotLSBpZ25vcmVzIHN0YWNrIHJ1bGUNCnN0YWNrX2NhcmRzKHN0YWNr
MSwgc3RhY2syKQ0KDQotLSB1bnN0YWNrcyBhIGNhcmQgYW5kIGFueSBjYXJkcyBvbiB0b3Agb2Yg
aXQgd2hlbiBjbGlja2VkIChpZiBhbGwgcnVsZXMgcmV0dXJuIHRydWUpDQotLSBvbmUgb2YgdGhl
IGZ1bmN0aW9ucyBhc3NpZ25lZCB0byBvbl9jbGljayBpbiBzdGFjaw0KLS0gY2FuIHRha2UgYW55
IG51bWJlciBvZiBydWxlIGZ1bmN0aW9ucw0Kc3RhY2tfb25fY2xpY2tfdW5zdGFjayguLi4pDQot
LSBydWxlIGZ1bmN0aW9ucyB0YWtlIGluIGEgc2luZ2xlIHBhcmFtZXRlciAoY2FyZCkgYW5kIHJl
dHVybiB0cnVlIGlmIHRoZSBjYXJkIGNhbiBiZSB1bnN0YWNrZWQNCi0tIHBvc3NpYmxlIHRvIGdp
dmUgbm8gcGFyYW1ldGVycyB0byBhbHdheXMgYWxsb3cgdW5zdGFja2luZw0KDQotLSB1bnN0YWNr
IHJ1bGUgZXhhbXBsZSAoZXhpc3RzIGluIHN0YWNrLmx1YSkNCi0tIGNhcmQgbXVzdCBiZSBmYWNl
IHVwIHRvIGJlIHBpY2tlZCB1cA0KZnVuY3Rpb24gdW5zdGFja19ydWxlX2ZhY2VfdXAoY2FyZCkN
CglyZXR1cm4gY2FyZC5hX3RvID09IDANCmVuZA0KDQotLSBjcmVhdGVzIGEgdGVtcG9yYXJ5IHN0
YWNrIHN0YXJ0aW5nIGZyb20gYSBnaXZlbiBjYXJkDQpsb2NhbCB0ZW1wX3N0YWNrID0gdW5zdGFj
a19jYXJkcyhjYXJkKQ0KDQotLSByZXR1cm5zIGEgY2FyZCByZXBvc2l0aW9uaW5nIGZ1bmN0aW9u
IChmb3IgcmVwb3MpDQotLSB1c2VkIHRvIGdpdmUgY2FyZHMgYSBtb3JlIGZsb2F0eSBmZWVsDQpz
dGFja19yZXBvc2Vfbm9ybWFsKHlfZGVsdGEsIGRlY2F5LCBsaW1pdCkgLS0gZGVmYXVsdHMgKDEy
LCAwLjcsIDIyMCkNCg0KLS0gcmV0dXJucyBhIGNhcmQgcmVwb3NpdGlvbmluZyBmdW5jdGlvbg0K
LS0gc3RpZmZlciB0aGFuIHRoZSB2ZXJzaW9uIGFib3ZlDQpzdGFja19yZXBvc2Vfc3RhdGljKHlf
ZGVsdGEpIC0tIGRlZmF1bHRzICgxMikNCg0KLS0gZXhhbXBsZSBvZiBhIGNhcmQgcmVwb3NpdGlv
bmluZyBmdW5jdGlvbg0KZnVuY3Rpb24gc3RhY2tfcmVwb3NlX3NpbXBsZShzdGFjaykNCglsb2Nh
bCB5ID0gc3RhY2sueV90bw0KCWZvciBjIGluIGFsbChzdGFjay5jYXJkcykgZG8NCgkJYy54X3Rv
ID0gc3RhY2sueF90bw0KCQljLnlfdG8gPSB5DQoJCXkgKz0gMTINCgllbmQNCmVuZA0KDQotLSBt
b3ZlcyBhIGNhcmQgZnJvbSBpdCdzIG9sZCBzdGFjayBvciB0YWJsZSB0byBhIG5ldyBvbmUNCnN0
YWNrX2FkZF9jYXJkKHN0YWNrLCBjYXJkLCBvbGRfc3RhY2spDQotLSBpZiBvbGRfc3RhY2sgaXMg
bm90IG5pbCBhbmQgYSB0YWJsZSwgY2FyZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGF0IHN0YWNr
DQotLSBpZiBvbGRfc3RhY2sgaXMgYSBudW1iZXIsIHRoZSBjYXJkIHdpbGwgaW5zdGVhZCBiZSBp
bnNlcnRlZCBpbnRvIHRoYXQgcG9zaXRpb24gaW4gdGhlIG5ldyBzdGFjaw0KLS0gKHRoaXMgc2hv
dWxkIHByb2JhYmx5IGJlIG1vcmUgcmVmaW5lZCkNCg0KLS0gbW92ZXMgY2FyZHMgaW4gYW4gYW5p
bWF0aW9uIChzZWUgQW5pbWF0aW9ucyBzZWN0aW9uIGJlbG93KSBmcm9tIGdpdmVuIGNhcmQgc3Rh
Y2tzIHRvICJzdGFja190byINCnN0YWNrX2NvbGxlY3RpbmdfYW5pbShzdGFja190bywgLi4uKQ0K
LS0gZXhhbXBsZSBzdGFja19jb2xsZWN0aW5nX2FuaW0oc3RhY2tfdG9fcmVjaWV2ZV9jYXJkcywg
c3RhY2tfZ29hbCwge3N0YWNrMSwgc3RhY2syLCBzdGFjazN9LCBhbm90aGVyX3N0YWNrKQ0KDQot
LSBkb2VzIGEgc2h1ZmZsaW5nIGFuaW1hdGlvbiBhbmQgcmFuZG9taXplcyBwb3NpdGlvbiBvZiBj
YXJkcw0Kc3RhY2tfc2h1ZmZsZV9hbmltKHN0YWNrKQ0KDQotLXJhbmRvbWl6ZXMgdGhlIHBvc2l0
aW9uIG9mIGFsbCB0aGUgY2FyZHMgaW4gdGhlIHN0YWNrDQpzdGFja19xdWlja19zaHVmZmxlKHN0
YWNrKQ0KDQotLSB1c2VzIHN0YWNrX3NodWZmbGVfYW5pbSAzIHRpbWVzLCBhbmQgdGhlbiBzdGFj
a19xdWlja19zaHVmZmxlLCBmb3IgYW4gZWFzaWVyIHNodWZmbGUNCnN0YWNrX3N0YW5kYXJkX3No
dWZmbGVfYW5pbShzdGFjaykNCg0KLS0gc3RhY2tfaGFuZF9uZXcgaXMgYSBzcGVjaWFsIHN0YWNr
IHdpdGggcHJlY3JlYXRlZCBwYXJhbWV0ZXJzDQotLSBjYXJkcyB3aWxsIGJlIHNwYWNlZCBob3Jp
em9udGFsbHkgaW5zdGVhZCBvZiB2ZXJ0aWNhbGx5LCBhbmQgd2lsbCBhbmltYXRlIHRoZWlyIHBv
c2l0aW9uIHdoZW4gaG92ZXJlZCBvdmVyIHdpdGggdGhlIG1vdXNlIGN1cnNvcg0KLS0gY2FyZHMg
Y2FuIGJlIHJlbW92ZWQgaW5kaXZpZHVhbGx5DQpzdGFja19oYW5kX25ldyhzcHJpdGVzLCB4LCB5
LCBwYXJhbSkNCi0tW1sNCnBhcmFtIGhhcyBzb21lIGFkZGl0aW9uYWwgdmFsdWVzIHRoYXQgY2Fu
IGJlIGdpdmVuDQoNCmhhbmRfd2lkdGggPSBtYXggcGl4ZWwgd2lkdGggdGhhdCB0aGUgY2FyZHMg
Y2FuIGJlIHN0cmV0Y2hlZCBvdXQNCmhhbmRfbWF4X2RlbHRhID0gYW1vdW50IG9mIHBpeGVscyBz
ZXBlcmF0aW5nIHRoZSBjYXJkcywgdW5sZXNzIHRoZSBnbyBiZXlvbmQgaGFuZF93aWR0aA0KXV0N
CmBgYA0KDQojIyBBbmltYXRpb25zDQoNCklmIHlvdSB3YW50IHRvIGhhdmUgYSBzZXQgb2YgYWN0
aW9ucyBvY2N1ciBvdmVyIHRpbWUNCldoZW4gYW4gYW5pbWF0aW9uIGlzIG9jY3VyaW5nLCBubyBj
YXJkcyBjYW4gYmUgaW50ZXJhY3RlZCB3aXRoLg0KDQpgYGBsdWENCi0tIGNhcmRzX2Nvcm91dGlu
ZSBjb250YWlucyB0aGUgY29yb3V0aW5lIG1hbmFnZWQgYnkgdGhlIGFwaQ0KDQotLWV4YW1wbGUg
aW5zaWRlIGdhbWVfc2V0dXANCmZ1bmN0aW9uIGdhbWVfc2V0dXAoKQ0KDQoJLS0gLi4uDQoNCgkt
LSBjcmVhdGVzIGEgY29yb3V0aW5lIHRvIGJlIGV4ZWN1dGVkIHBlciBmcmFtZQ0KCWNhcmRzX2Fw
aV9jb3JvdXRpbmVfYWRkKGdhbWVfc2V0dXBfYW5pbSkNCg0KCS0tIGNhcmRzX2FwaV9jb3JvdXRp
bmVfYWRkKGNvLCBzdG9wLCB3YWl0KQ0KCS0tIGV4dHJhIHBhcmFtZXRlcnMgc3RvcCBhbmQgd2Fp
dCBoZWxwIGNvbnRyb2wgbXVsdGlwbGUgY29yb3V0aW5lcyB0byBvY2N1ciBhdCB0aGUgc2FtZSB0
aW1lDQoJLS0gd2hlbiAic3RvcCIgaXMgbmlsIG9yIHRydWUsIHRoZSBuZXh0IGNvcm91dGluZXMg
d2lsbCBub3QgcnVuDQoJLS0gd2hlbiAid2FpdCIgaXMgdHJ1ZSwgdGhlIGNvcm91dGluZSB3aWxs
IHdhaXQgZm9yIHRoZSBwcmV2aW91cyBjb3JvdXRpbmVzIHRvIGJlIGRvbmUNCg0KCS0tIHdoZW4g
YWxsIGNvcm91dGluZXMgYXJlIGRvbmUsIGdhbWVfYWN0aW9uX3Jlc29sdmVkKCkgd2lsbCBiZSBj
YWxsZWQgaWYgaXQgZXhpc3RzDQplbmQNCg0KLS1leGFtcGxlIGZyb20gZ29sZiBzb2xpdGFpcmUN
CmZ1bmN0aW9uIGdhbWVfc2V0dXBfYW5pbSgpDQoJcGF1c2VfZnJhbWVzKDMwKSAtLSB3YWl0IDMw
IGZyYW1lcw0KCQ0KCWZvciBpID0gMSw1IGRvCQ0KCQlmb3IgcyBpbiBhbGwoc3RhY2tzX3N1cHBs
eSkgZG8NCgkJCS0tICB0cmFuc2ZlciBhIGNhcmQgZnJvbSB0aGUgc3RhY2sNCgkJCWxvY2FsIGMg
PSBnZXRfdG9wX2NhcmQoZGVja19zdGFjaykNCgkJCWlmKG5vdCBjKSBicmVhaw0KCQkJc3RhY2tf
YWRkX2NhcmQocywgYykNCgkJCWMuYV90byA9IDAgLS0gdHVybiBmYWNlIHVwDQoNCgkJCXBhdXNl
X2ZyYW1lcygzKSAtLSB3YWl0IDMgZnJhbWVzIHRvIGFsbG93IGl0IG5vdCB0byBiZSBpbnN0YW50
DQoJCWVuZA0KCQlwYXVzZV9mcmFtZXMoNSkgLS0gd2FpdCA1IGZyYW1lcyBmb3IgZXh0cmEgZWZm
ZWN0DQoJZW5kDQoJDQoJY2FyZHNfYXBpX2dhbWVfc3RhcnRlZCgpIC0tIGxldHMgdGhlIGdhbWUg
c3RhcnQNCmVuZA0KYGBgDQoNCiMjIENhcmQgU3ByaXRlIEdlbmVyYXRpb24NCg0KYGNhcmRfZ2Vu
Lmx1YWAgaXMgcHJvdmlkZWQgdG8gc2ltcGxpZnkgdGhlIGNyZWF0aW9uIG9mIG11bHRpcGxlIHNw
cml0ZXMgd2l0aCB0aGUgc2FtZSBzdHlsZS4NCg0KYGBgbHVhDQotLSBnZW5lcmF0ZXMgYW5kIHJl
dHVybnMgYSB0YWJsZSBvZiB0YWJsZXMgb2Ygc3ByaXRlcyBiYXNlZCBvbiBhIHRoZSBnaXZlbiBw
YXJhbSB0YWJsZQ0KLS0gdHlwZShzcHJpdGVzW3N1aXRdW3JhbmtdKSA9PSAidXNlcmRhdGEiDQoN
CmxvY2FsIHNwcml0ZXMgPSBjYXJkX2dlbl9zdGFuZGFyZChwYXJhbSkNCg0KLS1bWw0KcGFyYW0g
Y2FuIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXMNCg0Kc3VpdCA9IG51bWJlciBvZiBzdWl0ZXMN
CglkZWZhdWx0cyA0DQpyYW5rcyA9IG51bWJlciBvZiByYW5rcyBmb3IgYWxsIHN1aXRzDQoJaW5j
bHVkZXMgZmFjZSBjYXJkcw0KCWRlZmF1bHRzIDEzDQpzdWl0X2NoYXJzID0gdGFibGUgb2Ygc3Ry
aW5ncyB0aGF0IHdpbGwgYmUgZHJhd24gb24gZWFjaCBzcHJpdGUgb2YgdGhhdCBzdWl0DQoJZGVm
YXVsdHMgdG8gZGVmYXVsdF9zdWl0cw0KcmFua19jaGFycyA9IHRhYmxlIG9mIHN0cmluZ3MgdGhh
dCB3aWxsIGJlIGRyYXduIG9uIGVhY2ggc3ByaXRlIG9mIHRoYXQgcmFuaw0KCWRlZmF1bHRzIHRv
IGRlZmF1bHRfcmFua3MNCnN1aXRfY29sb3JzID0gdGFibGUgb2YgY29sb3JzIHRoYXQgd2lsbCBi
ZSB1c2VkIGZvciB3aGF0J3MgZHJhd24gb24gdGhlIHNwcml0ZSBiYXNlZCBvbiB0aGUgc3VpdA0K
CWRlZmF1bHRzIHRvIHN1aXRfY29sb3JzDQpzdWl0X3BvcyA9IHRhYmxlIG9mIGxvY2F0aW9ucyBv
ZiB0aGUgc3VpdCBzcHJpdGVzIGZyb20gc3VpdF9jaGFycywgd2hlcmUgdGhlIGluZGV4IGlzIHRo
ZSByYW5rIG9mIHRoZSBjYXJkDQoJaW5kaWNpZXMgY2FuIGJlIGVtcHR5DQoJZGVmYXVsdHMgdG8g
ZGVmYXVsdF9zdWl0X3Bvcw0Kc3VpdF9zaG93ID0gdGFibGUgb2YgYm9vbGVhbnMgZm9yIGlmIHRo
ZSBzdWl0IHNwcml0ZSBzaG91bGQgYmUgZHJhd24gaW4gdGhlIHRvcCBsZWZ0DQoJYW55IG1pc3Np
bmcgYm9vbGVhbnMgZGVmYXVsdCB0byB0cnVlDQpmYWNlX3Nwcml0ZXMgPSB0YWJsZSBvZiBzcHJp
dGVzIHRvIGJlIGRyYXduIGluc3RlYWQgb2Ygc3VpdCBzcHJpdGVzIGZvciBnaXZlbiByYW5rcw0K
CWZvciBhIHNpbmdsZSByYW5rIGEgdGFibGUgb2Ygc3ByaXRlcyBjYW4gYmUgZ2l2ZW4gdG8gYmUg
dXNlZCBmb3IgZWFjaCBzdWl0DQoJd2hlbiBwcm92aWRlZCwgbm8gc3VpdCBzcHJpdGVzIHdpbGwg
YmUgZHJhd24NCglpbmRpY2VzIGNhbiBiZSBza2lwcGVkDQoJZGVmYXVsdHMgdG8gZGVmYXVsdF9m
YWNlX3Nwcml0ZXMNCndpZHRoID0gd2lkdGggb2YgdGhlIHNwcml0ZXMgaW4gcGl4ZWxzDQoJZGVm
YXVsdHMgdG8gNDUNCmhlaWdodCA9IGhlaWdodCBvZiB0aGUgc3ByaXRlcyBpbiBwaXhlbHMNCglk
ZWZhdWx0cyB0byA2MA0KDQp0byBzZWUgdGhlIGRlZmF1bHQgdGFibGVzLCBsb29rIGluIGNhcmRf
Z2VuLmx1YQ0KXV0NCg0KLS0gZ2VuZXJhdGVzIGFuZCByZXR1cm5zIGEgY2FyZCBiYWNrIHNwcml0
ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gcGFyYW0gdGFibGUNCi0tIChUaGlzIHNob3VsZCB1c3VhbGx5
IG5vdCBiZSB1c2VkIGluIFBpY290cm9uIFNvbGl0YWlyZSBTdWl0ZSkNCmxvY2FsIGJhY2sgPSBj
YXJkX2dlbl9iYWNrKHBhcmFtKQ0KLS1bWw0KcGFyYW0gY2FuIHRha2UgdGhlIGZvbGxvd2luZyB2
YWx1ZXMNCg0Kc3ByaXRlID0gc3ByaXRlIGRyYXduIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhcmQg
YmFjaywgYmVoaW5kIHRoZSBib3JkZXINCglkZWZhdWx0cyB0byBzcHJpdGUgMTEyLCBidXQgdGhp
cyBzaG91bGQgYWx3YXlzIGJlIHJlcGxhY2VkDQpib3JkZXIgPSBzcHJpdGUgdG8gYmUgdXNlZCB3
aXRoIG5pbmVzbGljZSB0byBkcmF3IGF0IHRoZSBlZGdlIG9mIHRoZSBnZW5lcmF0ZWQgc3ByaXRl
DQoJZGVmYXVsdHMgdG8gc3ByaXRlIDI1DQp3aWR0aCwgaGVpZ2h0ID0gc2l6ZSBvZiBnZW5lcmF0
ZWQgc3ByaXRlLCBkZWZhdWx0cyB0byA0NSBhbmQgNjANCmxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRv
bSA9IHBpeGVscyB0byBjdXQgb2ZmIHBhcmFtLnNwcml0ZQ0KCWRlZmF1bHRzIHRvIDINCnRhcmdl
dF9zcHJpdGUgPSBzcHJpdGUgdG8gZHJhd24gb24sIHdpbGwgDQpdXQ0KYGBgDQoNCiMjIEJ1dHRv
bnMNCg0KQnV0dG9ucywgZnJvbSBgYnV0dG9uLmx1YWAgYXJlIGVsZW1lbnRzIHRoYXQgY2FuIGJl
IGludGVyYWN0ZWQgd2l0aCBieSB0aGUgbW91c2UuDQoNCmBgYGx1YQ0KLS0gY3JlYXRlcyBhIG5l
dyBidXR0b24NCmxvY2FsIGJ1dHRvbiA9IGJ1dHRvbl9uZXcocGFyYW0pDQotLVtbDQpwYXJhbSBp
cyBhIHRhYmxlIHRoYXQgY2FuIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXMNCg0KeCwgeSA9IHRv
cCBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBpbnRlcmFjdGFibGUgc3BhY2Ugb2YgdGhlIGJ1dHRvbiwg
aW4gcGl4ZWxzDQp3aWR0aCwgaGVpZ2h0ID0gc2l6ZSBvZiB0aGUgaW50ZXJhY3RhYmxlIHNwYWNl
IG9mIHRoZSBidXR0b24sIGluIHBpeGVscw0KZHJhdyA9IGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGl0
J3MgdGltZSB0byBkcmF3IHRoZSBidXR0b24NCm9uX2NsaWNrID0gZnVuY3Rpb24gY2FsbGVkIHdo
ZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkDQplbmFibGVkID0gYm9vbGVhbiBmb3IgaWYgdGhlIGJ1
dHRvbiBjYW4gYmUgY2xpY2tlZA0KYWx3YXlzX2FjdGl2ZSA9IGlmIHRydWUsIHRoZSBidXR0b24g
Y2FuIGFsd2F5cyBiZSBjbGlja2VkIGlmIGl0J3MgaGlnaGxpZ2h0ZWQNCglpZiBmYWxzZSwgdGhl
IGJ1dHRvbiB3aWxsIG5vdCBiZSBjbGlja2FibGUgd2hlbiB0aGUgZ2FtZSBpcyBmcm96ZW4gb3Ig
aWYgdGhlcmUgaXMgYW4gY29yb3V0aW5lIHBsYXlpbmcNCglzZWUgY2FyZHNfYXBpX3NldF9mcm96
ZW4gYW5kIGNhcmRzX2FwaV9jb3JvdXRpbmVfYWRkIGluIGNhcmRzX2Jhc2UubHVhDQpvbl9kZXN0
cm95ID0gY2FsbGVkIHdoZW4gdGhlIGJ1dHRvbiBpcyBkZXN0cm95ZWQNCmdyb3VwID0gbGF5ZXIg
dGhhdCB0aGUgYnV0dG9ucyB3aWxsIGJlIGRyYXduIG9uLCBmb3JjaW5nIHBhcnRpYWwgZHJhdyBh
bmQgY2xpY2sgb3JkZXINCgkxID0gYmFzZSBnYW1lDQoJMiwzID0gcHJpbWFyaWx5IHJlc2VydmVk
IGZvciB1aQ0KYm90dG9tID0gd2hlbiB0cnVlLCBhZGRzIHRoZSBidXR0b24gdG8gdGhlIHN0YXJ0
IG9mIHRoZSBsaXN0IG9mIGJ1dHRvbnMgaW5zdGVhZCBvZiB0aGUgZW5kDQoJdGhpcyBjYW4gaGVs
cCB3aXRoIHRoZSBkcmF3IG9yZGVyDQoNCg0KdGhlIGJ1dHRvbiBoYXMgc29tZSBleHRyYSBwcm9w
ZXJ0aWVzDQoNCmhpdCA9IGlzIHNldCB0cnVlIHdoZW4gdGhlIGN1cnNvciBpcyBvdmVyIHRoZSBi
dXR0b24NCmhpZ2hsaWdodCA9IHNhbWUgYXMgaGl0LCBidXQgZmFsc2UgdGhlIGJ1dHRvbiBoYXMg
bm8gb25fY2xpY2sgZnVuY3Rpb24NCl1dDQoNCi0tIGJ1dHRvbl9zaW1wbGVfdGV4dCBjcmVhdGVz
IGEgc2ltcGxlIGFuaW1hdGVkIGJ1dHRvbiB0aGF0IGZpdHMgYSBnaXZlbiBzdHJpbmcgb2YgdGV4
dA0KbG9jYWwgYnV0dG9uID0gYnV0dG9uX3NpbXBsZV90ZXh0KHMsIHgsIHksIG9uX2NsaWNrKQ0K
LS1bWw0KcyA9IHRleHQgZGlzcGxheWVkIG9uIHRoZSBidXR0b24NCngsIHkgPSBwb3NpdGlvbiBv
ZiB0aGUgYnV0dG9uDQpvbl9jbGljayA9IGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBidXR0b24g
aXMgY2xpY2tlZA0KXV0NCmBgYA0K
:: cards_api/stack.lua
--[[pod_format="raw",created="2024-03-16 15:18:21",modified="2024-07-21 13:23:51",revision=17316]]

stacks_all = {}

-- these three functions are primarily to help with env encapsulation
-- returns all stacks
function get_all_stacks()
	return stacks_all
end

-- returns currently held stack
function get_held_stack()
	return held_stack
end

-- sets the held stack
function set_held_stack(stack)
	held_stack = stack
end

--[[
Stacks are essentially tables containing cards.
Each stack has a set of rules for how cards interact with it.
stack_new() returns a table that has been added to stack_all.

sprites = table of sprite ids or userdata to be drawn with spr
x,y = top left position of stack
	will be assigned to x_to and y_to

param is a table that can have the following key values

x_off, y_off = draw offsets of the stack's sprite(s)
reposition = function called when changing the target position of the cards
	the function usually assigns all cards .x_to and .y_to values relative to the stack's position
	defaults to stack_repose_normal
perm = the stack is destroyed when there are no more cards if this is not set trues
	defaults to true
top_most = controls the draw order of cards between stacks
	the higher the number, the higher the stack
	defaults to 0
can_stack = function called when another stack of cards is placed on top (with restrictions)
	function(self, held)
	returns true if the "held" can be placed on top of "self"
on_click = function called when stack base or card in stack is clicked
	usually set to stack_on_click_unstack(...)
on_double = function called when stack base or card in stack is double clicked
resolve_stack = function called when can_stack returns true
	defaults to stack_cards
unresolved_stack = function called when a held card is released, but isn't placed onto a stack
	defaults to stack_unresolved_return
on_hover = function called when the cursor over the stack or card
	function(self, card, held)
	self = current stack
	card = the hovered card
	held = stack that is being held by the player
off_hover = function called when the cursor is no longer over the stack or card
	similar function to on_hover, called before the next on_hover function is called
on_destroy = function called when the stack is destroyed

additional parameters can be provided to give the stack more properties
]]

function stack_new(sprites, x, y, param)

	local s = {
		ty = "stack",
		sprites = type(sprites) == "table" and sprites or {sprites},
		x_to = x,
		y_to = y,
		x_off = param.offset or -3,
		y_off = param.offset or -3,
		width = 45,
		height = 60,
		cards = {},
		perm = true,
		top_most = 0,
		reposition = stack_repose_normal(),
		can_stack = stack_cant,
		on_click = stack_cant,
		on_double = on_double,
		resolve_stack = stack_cards,
		unresolved_stack = stack_unresolved_return,
		-- on_hover = ... function(self, card, held_stack)
		-- off_hover = ... function(self, card, held_stack)
		
		destroy = stack_destroy
		-- on_destroy = ...
	}	
	
	for k,v in pairs(param) do
		s[k] = v
	end
	
	return add(stacks_all, s)
end

-- removes a stack from the game
-- if cards_too is true, then all cards that were assigned to the stack are also removed from the game
function stack_destroy(s, cards_too)
	if s.on_destroy then
		s:on_destroy()
	end
	
	if cards_too then
		foreach(s.cards, card_destroy)
	
	-- stack no longer exists, so cards' stack must be unassigned
	else	
		for c in all(s.cards) do
			c.stack = nil
		end
	end
	
	s.cards = {} -- remove references justs in case
	del(stacks_all, s)
end

-- drawing function for stacks
-- always drawn below cards
function stack_draw(s)
	if s.perm then
		local x, y = s.x_to + s.x_off, s.y_to + s.y_off
		for sp in all(s.sprites) do
			spr(sp, x, y)
		end
	end
end

-- Places cards from stack2 to onto stack
function stack_cards(stack, stack2)
	for c in all(stack2.cards) do
		add(stack.cards, del(stack2.cards, c))
		c.stack = stack
		card_to_top(c)
	end
	stack2.old_stack = nil
	if not stack2.perm then
		stack2:destroy()
	end
end

-- pushes each of the cards in the given stack to the top of the card draw order
function stack_to_top(stack)
	foreach(stack.cards, card_to_top)
	--for c in all(stack2.cards) do
	--	card_to_top(c)
	--end
end

-- inserts cards from stack2 into stack, starting from position i
function insert_cards(stack, stack2, i)
	
	-- determines where the cards will be reordered inside cards_all
	cards_into_stack_order(stack, stack2, i)
		
	for c in all(stack2.cards) do		
		add(stack.cards, del(stack2.cards, c), i)
		i += 1
		c.stack = stack
	end
	
	stack2.old_stack = nil
	stack_delete_check(stack2)
end

-- on_click event that unstacks cards starting from the given card
-- if a given rule function returns true
function stack_on_click_unstack(...)
	local rules = {...}
	
	return function(card)
		if card then
			for r in all(rules) do
				if(not r(card))return
			end
			
			set_held_stack(unstack_cards(card))
		end
	end
end

-- version for the hand stack, picking out a single card
function stack_hand_on_click_unstack(...)
	local rules = {...}
	
	return function(card)
		if card then
			for r in all(rules) do
				if(not r(card))return
			end
			
			set_held_stack(unstack_hand_card(card, true))
		end
	end
end

function unstack_rule_face_up(card)
	return card.a_to == 0
end

-- creates a new stack by taking cards from the given card's stack.
-- cards starting from the given card to the top of the stack (stack[#stack])
function unstack_cards(card)
	local old_stack = card.stack
	local new_stack = stack_held_new(old_stack, card)
	new_stack._unresolved = old_stack:unresolved_stack(new_stack)

	local i = has(old_stack.cards, card)
	while #old_stack.cards >= i do
		local c = add(new_stack.cards, deli(old_stack.cards, i))
		c.stack = new_stack
		card_to_top(c) -- puts cards on top of all the others
	end
	
	stack_delete_check(old_stack)
	
	return new_stack
end

-- old_stack is where the cards are coming from
-- card is the base position of the stack
function stack_held_new(old_stack, card)
	local st = stack_new(
		nil,
		card.x_to, card.y_to,
--		old_stack.x_to, old_stack.y_to, 
--		0, 0, 
		{
			top_most = 999,
			reposition = stack_repose_normal(10), 
			perm = false,
			old_stack = old_stack
		})

	return st
end

-- reposition calculation for a stack that allows for more floaty cards
function stack_repose_normal(y_delta, decay, limit)
	y_delta = y_delta or 12
	decay = decay or 0.7
	limit = limit or 220
	
	return function(stack)
		local y, yd = stack.y_to, min(y_delta, limit / #stack.cards)
		local lasty, lastx = y, stack.x_to
		for i, c in pairs(stack.cards) do
			local t = decay / (i+1)
			c.x_to = lerp(lastx, stack.x_to, t)
			c.y_to = lerp(lasty, y, t)
			y += yd
			
			lastx = c.x()
			lasty = c.y() + yd
		end
	end
end

-- reposition calculation that has fixed positions
function stack_repose_static(y_delta)
	y_delta = y_delta or 12
	
	return function(stack)
		local y = stack.y_to
		for c in all(stack.cards) do
			c.x_to = stack.x_to
			c.y_to = y
			y += y_delta
		end
	end
end

-- returns the y position of the top of the stack
function stack_y_pos(stack)
	local top = stack.cards[#stack.cards]
	return top and top.y_to or stack.y_to
end

-- basically always returns false for
-- more just for nice naming
-- could still be used for other events like sound effects
function stack_cant()
end

-- deletes a stack if it has no cards and if it is not permanent
function stack_delete_check(stack)
	if #stack.cards == 0 and not stack.perm then
		stack:destroy()
	end	
end

-- adds a card to the top of a stack
-- if an old stack is given, the card is removed from that table/stack instead
function stack_add_card(stack, card, old_stack)
	if card then
		if type(old_stack) == "table" then
			del(old_stack, card)
		elseif card.stack then
			del(card.stack.cards, card)
		end
		
		if type(old_stack) == "number" then
			add(stack.cards, card, old_stack).stack = stack
		else
			add(stack.cards, card).stack = stack
		end
		
		card_to_top(card)
	end
end

-- move all cards from "..." (stacks or table of stacks) to "stack_to" 
function stack_collecting_anim(stack_to, ...)
	local facing = 0.5
	
	local function collect(s)
		if s == stack_to then
			return
		end
		while #s.cards > 0 do
			local c = get_top_card(s)
			stack_add_card(stack_to, c)
			c.a_to = facing
			--sfx(3)
			pause_frames(3)
		end
	end
	
	for a in all{...} do
		local ty = type(a)
		if ty == "number" then
			facing = a
			
		elseif ty == "table" then
			if a.cards then -- single stack	
				collect(a)
				
			else -- table of stacks	
				foreach(a, collect)	
			end
		end
	end
end
	
function stack_standard_shuffle_anim(stack)
	stack_shuffle_anim(stack)
	stack_shuffle_anim(stack)
	stack_shuffle_anim(stack)
	stack_quick_shuffle(stack)
end

-- animation for physically shuffle the cards
function stack_shuffle_anim(stack)
	local c = stack.cards[1]
	local w = c and c.width or 45
	local temp_stack = stack_new(
		nil, stack.x_to + w + 4, stack.y_to, 
		{
			reposition = stack_repose_static(-0.16), 
			perm = false
		})
		
	for i = 1, rnd(10)-5 + #stack.cards/2 do
		stack_add_card(temp_stack, get_top_card(stack))
	end
	
	--sfx(3)
	pause_frames(30)
	--sfx(3)	
	
	for c in all(temp_stack.cards) do
		stack_add_card(stack, c, rnd(#stack.cards+1)\1+1)
	end
	
	del(stacks_all, temp_stack)
	
	stack_to_top(stack)
	
	pause_frames(20)
end

-- randomizes the position of all the cards in the stack, while preventing any odd jumps in the cards
function stack_quick_shuffle(stack)
	local temp, cards = {}, stack.cards
	local temp_data = {}
	
	for c in all(cards) do
		local d = add(temp_data, {})
		for k in all{"x","x_to","y","y_to","a","a_to","shadow"} do
			d[k] = c[k]
		end
	end	
		
	while #cards > 0 do
		add(temp, deli(cards, rnd(#cards)\1 + 1))
	end
	
	for i, c in pairs(temp) do
		for k,v in pairs(temp_data[i]) do
			c[k] = v
		end
		add(cards, c)
	end
	
--[[
		-- secretly randomize cards a bit
	local c = #stack.cards
	if c > 1 then -- must have more than 1 card to swap
		for i = 1, rnd(2)+9 do
			local i, j = 1, 1
			while i == j do -- guarantee cards are different
				 i, j = rnd(c)\1 + 1, rnd(c)\1 + 1
			end
			stack_quick_swap(stack,i,j) 
		end
	end
]]
	
	stack_to_top(stack)
end

-- swaps two cards instantly with no animation
-- will need to call stack_to_top to fix the draw order
function stack_quick_swap(stack, i, j)
	local c1, c2 = stack.cards[i], stack.cards[j]
	if(not c1 or not c2) return -- not the same
	
	-- swap position in stack
	stack.cards[i], stack.cards[j] = c2, c1
	
	-- swap positional properties
	for k in all{"x","x_to","y","y_to","a","a_to","shadow"} do
		c1[k], c2[k] = c2[k], c1[k]
	end
end


-- creates a function for returning cards to the top of their old stack
function stack_unresolved_return(old_stack, held_stack)
	return function()
		stack_cards(old_stack, held_stack)
	end
end

-- if a stack was unstacked and it wasn't resolved, the _unresolved function will be called
function stack_apply_unresolved(stack)
	if stack._unresolved then
		stack._unresolved()
		stack._unresolved = nil
		stack.old_stack = nil
	end
end

-- hand specific event functions

-- creates a basic stack for holding cards in a hand
-- cards can be reordered without needing to check can_stack
function stack_hand_new(sprites, x, y, param)
	local param_base = {
		top_most = 100,
		reposition = stack_repose_hand(param.hand_max_delta, param.hand_width),
		
		--can_stack = function() return true end,
		on_click = stack_hand_on_click_unstack(),
		resolve_stack = stack_insert_cards,
		unresolved_stack = stack_unresolved_return_rel_x,
		
		on_hover = hand_on_hover,
		off_hover = hand_off_hover,
		
		width = param.hand_width,
	}
	
	for k,v in pairs(param) do
		param_base[k] = v
	end
	
	return stack_new(sprites, x, y, param_base)
end

function stack_insert_cards(self, held, card)
	local ins = hand_find_insert_x(self, held)
	insert_cards(self, held, ins)
	self.ins_offset = nil
end

function stack_unresolved_return_insert(old_stack, held_stack, old_pos)
	return function()
		insert_cards(old_stack, held_stack, old_pos)
	end
end

function stack_unresolved_return_rel_x(old_stack, held_stack)
	return function()
		stack_insert_cards(old_stack, held_stack)
		--[[
		local ins = hand_find_insert_x(old_stack, held_stack)
		insert_cards(old_stack, held_stack, ins)
		old_stack.ins_offset = nil
		]]
	end
end

-- find the i-th location to insert the held stack into the ins_stack
function hand_find_insert_x(ins_stack, held_stack)
	local cards, x2 = ins_stack.cards, held_stack.x_to
	for i = 1, #ins_stack.cards do
		if x2 < cards[i].x_to then
			return i
		end
	end
	
	return #ins_stack.cards + 1

--[[ another idea, but not needed
	local cards, x2 = ins_stack.cards, held_stack.x_to
	local min_dif, closest = 9999
	for i = 1, #ins_stack.cards do
		local d = abs(cards[i].x_to - x2)
		if d < min_dif then
			min_dif, closest = d, i
		end
	end
	-- missing check for being after the last card
	return closest
--]]
end


function stack_repose_hand(x_delta, limit)
	x_delta = x_delta or 25
	limit = limit or 200
	
	return function(stack, dx)
		local c = stack.cards[1]
		
		local lim = (limit - (c and c.width or 45)) / (#stack.cards + (stack.ins_offset and 1 or 0) - 1)
		
		--local x, xd = stack.x_to, min(x_delta, limit / (#stack.cards + (stack.ins_offset and 1 or 0)))
		local x, xd = stack.x_to, min(x_delta, lim)
		
		for i, c in pairs(stack.cards) do
		--	instead of applying an offset
		--	c.x_to = x
		--	c.x_offset_to = stack.ins_offset and stack.ins_offset <= i and xd or 0
		
			c.x_to = x + (stack.ins_offset and stack.ins_offset <= i and xd or 0)
		
			c.y_to = stack.y_to
			-- applies an additional offset to the card if hovered
			c.y_offset_to = c.hovered and -15 or 0
			x += xd
		end
	end
end

-- designed to pick up a single card
-- store_offset is primarily for the hand stack itself, for keeping the insert position when a card is picked up.
-- (normally it doesn't look right)
function unstack_hand_card(card, store_offset)
	if not card then
		return
	end
	
	-- resets the offset of the card
	card.x_offset_to = 0
	card.y_offset_to = 0
	card.hovered = false
	
	local old_stack = card.stack
	local new_stack = stack_held_new(old_stack, card)
	new_stack.old_pos = has(old_stack.cards, card)
	new_stack._unresolved = old_stack:unresolved_stack(new_stack, has(old_stack.cards, card))
	if store_offset then
		old_stack.ins_offset = new_stack.old_pos
	end
	
	-- moves card to new stack
	add(new_stack.cards, del(old_stack.cards, card))
	card.stack = new_stack
	stack_delete_check(old_stack)
	
	return new_stack
end

function hand_on_hover(self, card, held)
	
	if held then
		-- shift cards and insert held stack into cards_all order
		self.ins_offset = hand_find_insert_x(self, held)
		cards_into_stack_order(self, held, self.ins_offset)

	else
		self.ins_offset = nil
		if card then
			card.hovered = true
		end
	end
	
end

function hand_off_hover(self, card, held)
	self.ins_offset = nil
	if held then
		-- shift cards and back and put held cards back on top
		stack_to_top(held)
	end
	
	if card then
		card.hovered = nil
	end
end
:: cards_api/util.lua
--[[pod_format="raw",created="2024-03-26 04:14:49",modified="2024-07-21 13:23:51",revision=4049]]
-- returns the key of a searched value inside a table
-- such that tab[has(tab, val)] == val
function has(tab, val)
	for k,v in pairs(tab) do
		if v == val then
			return k
		end
	end
end

-- returns the key of a searched value inside a table
-- such that tab[has(tab, key, val)][key] == val
function has_key(tab, key, val)
	for k,v in pairs(tab) do
		if v[key] == val then
			return v, k 
		end
	end
end

-- aabb point to box collision
function point_box(x1, y1, x2, y2, w, h)
	x1 -= x2
	y1 -= y2
	return x1 >= 0 and y1 >= 0 and x1 < w and y1 < h 
end 

-- you know what this is
function lerp(a, b, t)
	return a + (b-a) * t
end


-- yields a certain number of times
-- may need to be updated in case low battery mode causes halved update rate
function pause_frames(n)
	for i = 1,n do
		yield()
	end
end

-- maybe stuff these into userdata to evaluate all at once?
-- Returns a function that tracks a value as a position connected to a spring
-- pos - initial position
-- damp - dampening value, 0-1, reduces velocity each use
-- acc - acc, 0-1, acceleration value
-- lim - limit distance, that if position reachest the target
--
-- x = smooth-val(0, 0.9, 0.2)
-- x() -- returns current value
-- x(1) -- moves the value towards the parameter
-- x("pos", 2) -- sets the value
-- x("vel") -- returns velocity
-- x("vel", 2) -- sets the velocity
function smooth_val(pos, damp, acc, lim)
	lim = lim or 0.1
	local vel = 0
	return function(to, set)
		if to == "vel" then
			if set then
				vel = set
				return
			end
			return vel
			
		elseif to == "pos" then
			if set then
				pos = set
				return
			end
			return pos -- not necessary, but for consistency
		end
		
		if to then
			local dif = (to - pos) * acc
			vel += dif
			vel *= damp
			pos += vel
			--if abs(vel) < lim and abs(dif) < lim then
			if vel < lim and vel > -lim and dif < lim and dif > -lim then
				pos, vel = to, 0
			end
		end
		return pos
	end
end

-- same as smooth_val, but isntead for angles
-- tries to approach the target angle from the closest direction
function smooth_angle(pos, damp, acc)
	local vel = 0
	return function(to, set)
		if to == "vel" then
			if set then
				vel = set
				return
			end
			return vel
			
		elseif to == "pos" then
			if set then
				pos = set
				return
			end
			return pos -- not necessary, but for consistency
		end
		
		if to then
			local dif = ((to - pos + 0.5) % 1 - 0.5) * acc
			vel += dif
			vel *= damp
			pos += vel
			if abs(vel) < 0.0006 and abs(dif) < 0.007 then
				pos, vel = to, 0
			end
		end
		return pos
	end
end

-- sorts the table (in place), with a given key
function quicksort(tab, key)
	local function qs(a, lo, hi)
		if lo >= hi or lo < 1 then
			return
		end
			    
		-- find pivot
		local lo2, hi2 = lo, hi
		local pivot, p = a[hi2], lo2-1
		for j = lo2,hi2-1 do
			if a[j][key] <= pivot[key] then
				p += 1
				a[j], a[p] = a[p], a[j]
			end
		end
		p += 1
		a[hi2], a[p] = a[p], a[hi2]
		    
		-- quicksort next step
		qs(a, lo, p-1)
		qs(a, p+1, hi)
	end
    qs(tab, 1, #tab)
end

local empty_target = userdata("u8", 1, 1)

-- returns the size of the text
-- safe to use anywhere, even during init()
function print_size(s)
	local old = get_draw_target()
	set_draw_target(empty_target)
	
	local w, h = print(s, 0, 0)
	
	set_draw_target(old)	

	return w, h
end

-- cuts off the text and adds "..." so that the text is limited to a given pixel width
function print_cutoff(s, lim)
	local old = get_draw_target()
	set_draw_target(empty_target)
	
	local w = print(s, 0, 0)
	while w > lim do
		s = sub(s, 1, #s-4) .. "..."
		w = print(s, 0, 0)
	end

	set_draw_target(old)	

	return s, w
end

-- THE NORMAL PRINT WRAPPING CANNOT BE TRUSTED
-- wraps text to be limited to a given pixel width
function print_wrap_prep(s, width)
	local words = split(s, " ", false)
	local lines = {}
	local current_line = ""
	local final_w = 0
	
	for w in all(words) do
		local c2 = current_line == "" and w or current_line .. " " .. w
		local x = print_size(c2)
		if x > width then
			current_line = current_line .. "\n" .. w
		else
			current_line = c2
			final_w = max(final_w, x)
		end
	end
	local _, final_h = print_size(current_line)
	
	return current_line, final_w, final_h
end

-- prints the string with a shadow
function double_print(s, x, y, c)
	print(s, x+1, y+1, 6)
	print(s, x, y, c)
end

-- traverses all folders inside a starting folder
-- does not include itself
function folder_traversal(start_dir)

	local current_dir = start_dir
	local prev_folder = nil
	
	function exit_dir()
		current_dir, prev_folder = current_dir:dirname(), current_dir:basename()
	end
	
	return function(cmd, a)
		if cmd then
			if cmd == "exit" then -- exits current directory early
				exit_dir()
			elseif cmd == "find" then -- returns true if a specific file is found
				local l = ls(current_dir)
				if(l) return has(l, a)
			end
			
			return 
		end
		
		if not prev_folder then
			prev_folder = ""
			return current_dir
		end
		
		while #current_dir >= #start_dir do			
			local list = ls(current_dir)
			if list then
				for i, f in next, list, has(list, prev_folder) do
					if not f:ext() then -- folder
						current_dir ..= "/" .. f
						return current_dir
					end
				end
			end
			
			exit_dir()
		end
	end
end


-- draws a sprite with nineslice style
-- if fillcol is a number, then rectfill will be called instead (cheaper)
-- if fillcol is false, then nothing will be drawn in the center 
function nine_slice(sprite, x, y, w, h, fillcol)
	sprite = type(sprite) == "number" and get_spr(sprite) or sprite
	local sp_w, sp_h = sprite:width(), sprite:height()
	local s_max_w, s_max_h = sp_w\2, sp_h\2 -- size \ 2
	
	-- calculate width for each component
	local w1 = min(s_max_w, w\2)
	local w3 = min(s_max_w, w - w1)\1
	local w2 = w - w3 - w1
	
	-- calculate height of each component
	local h1 = min(s_max_h, h\2)
	local h3 = min(s_max_h, h - h1)\1
	local h2 = h - h3 - h1
	
	-- top (then left, middle, right)
	sspr(sprite, 0,0, w1,h1, x,y)
	if(w2 >= 1) sspr(sprite, s_max_w,0, 1,h1, x+w1,y, w2,h1)
	sspr(sprite, sp_w-w3,0, w3,h1, x+w1+w2,y)

	-- middle
	if h2 >= 1 then
		sspr(sprite, 0,s_max_h, w1,1, x,y+h1, w1,h2) -- top left corner
		
		if w2 >= 1 then 
			if fillcol then
				rectfill(x+w1,y+h1, x+w1+w2-1,y+h1+h2-1, fillcol)
			elseif fillcol ~= false then
				sspr(sprite, s_max_w,s_max_h, 1,1, x+w1,y+h1, w2,h2)
			end
		end
		
		sspr(sprite, sp_w-w3,s_max_h, w3,1, x+w1+w2,y+h1, w3,h2)
	end	

	-- bottom
	sspr(sprite, 0,sp_h-h3, w1,h3, x,y+h1+h2) -- top left corner
	if(w2 >= 1) sspr(sprite, s_max_w,sp_h-h3, 1,h3, x+w1,y+h1+h2, w2,h3)
	sspr(sprite, sp_w-w3,sp_h-h3, w3,h3, x+w1+w2,y+h1+h2)
end

:: cards_api/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI3IDIzOjM3OjQ2Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTI3IDIzOjM3OjQ2Il1d
:: card_backs/
:: card_backs/card_backs_fletch.lua
--[[pod_format="raw",created="2024-03-29 08:45:43",modified="2024-07-21 13:23:51",revision=550]]
function get_info()
    return {
        {
            sprite = card_back_art, artist = "Fletch",
            lore = "This duck has somewhere to be!",
            -- animation table
            step=0,
            steps_per_frame=6,
            current_frame=1,
            frames={
                unpod("b64:bHo0ADQAAAAyAAAA8CNweHUAQyANDgSQB4AngDeAFwAXcIcgRyCXMAcAZzAXAEdQFyAXYEeAF4AXEAdwBzAXMA=="),
                unpod("b64:bHo0ADMAAAAxAAAA8CJweHUAQyANDgTwBweAJ4A3gBcAF3CHIEcglzAHAGcwFwBHUBcgF2BHgAcAB4AHEBdA"),
                unpod("b64:bHo0AC8AAAAtAAAA8B5weHUAQyANDgTwBDdwN4AXABdwhyBHIJcwBwBnMBcAR1AXIBdgR4AXoBewF1A="),
                unpod("b64:bHo0ADQAAAAyAAAA8CNweHUAQyANDgSQB4AngDeAFwAXcIcgRyCXMAcAZzAXAEdQFyAXYEeABwAHkAcAF4AXYA=="),
            }
        }
    }
end

function card_back_art(data, width, height)
	local anim_width, anim_height = 13,14

    -- check if we're updating the displayed frame on this call
    data.step += 1
    data.step %= data.steps_per_frame
    if data.step == 0 then
        -- advance the animation, looping back to beginning if we go off the end
        data.current_frame %= #data.frames
        data.current_frame += 1
    end

    -- center the animation inside of the card
    local draw_x = width \ 2 - anim_width \ 2
    local draw_y = height \ 2 - anim_height \ 2

    -- draw a blue background... should this be cls(1) instead?
    rectfill(0,0,width,height,19)
	
    -- draw the animation frame
    spr(data.frames[data.current_frame], draw_x, draw_y)
end
:: card_backs/card_backs_louie_chapman.lua
--[[pod_format="raw",created="2024-03-26 07:03:01",modified="2024-07-21 13:23:51",revision=603]]

function get_info()
	return {
		{ 
			sprite = 
--[[pod_type="gfx"]]unpod("b64:bHo0ALYBAADlAQAAwHB4dQBDIGRkBP8V-wEA8Rc2jxj-FUjvGP8VQ-8YA-8VP-8YB-8VPP8YAD8VTxj-FTr-GABCDwsAUjj-GABiCwDwXzb-GAFiDxVfGP8VNP8YAmIPFW8Y-xUy-xgEUg8Vfxj-FTH-GAVCjv8VMP4HEr79L-4V-S7_Ew0u-S0uAv4PAi79Lf4X-SwuAi49-g79K14NMg3_Df0rAj5iDf4M-SsSLmINLj3_Bf0rAg4CHnIeHwDwCAT9KxIOAh5SHg1SDf4D-SsiDgIeMi5iDABELCKeYhQA8AyeUv4E-S0SvjLeHU79LAINEv4GLS4NEg0u-S4NAPAdBA0iDR4iDS79MCL_AzINLhIuAv0vAg0CDgL_AkJ_-TFCDgIN7iJ_Av0yIg4VAKAK-TQiDgL_C-01BwBiCAL9NQINGgAxBf05CQACAgBTrgIO-TkbAAsCAGUi-T1SDgICAPIGQv0-Ag0CDXIOUv1CAg0CLaL9SAINAgAxEv1NCQAQ-ZgB8iE5Gv1RAhkC-VAKFAr9TwIJFwkC-U4KBBcECv1NAgkHEgcJAv1NBAYVBgT9TgIFHQU2AHD-------_1"),
			artist = "LouieChapm",
			lore = "Kalikan, from Kalikan"
		}
	}
end
:: card_backs/card_backs_main.lua
--[[pod_format="raw",created="2024-03-20 14:39:52",modified="2024-07-21 13:23:51",revision=3511]]


-- !!! NOTE, make your own .lua file along side this one instead of modifying this one.
-- this file is ignored when loading it as a Mod inside Picotron Solitaire Suite

-- sprite can be a number or userdata

-- id can be a number or string, just make sure it doesn't match any other card's
-- used to save card back selected
function get_info()
	return {
		{ 
			-- either a number for the sprite id in the spritesheet, or userdata
			sprite = 113, 
			-- obviously the artist
			artist = "Werxzy",
			-- extra info about the card art
			lore = "Picotron Icon"
		},
		{ 
			sprite = 119, artist = "Werxzy",
			lore = "(And technically Zep) \nZep's Jelpi from Pico-8"
		},
		{ 
			sprite = 114, artist = "Werxzy",
			lore = "Box from SokoCode by Werxzy"
		},
		{ 
			sprite = 112, artist = "Werxzy",
			lore = "The first card back!"
		},
		{ 
			sprite = 116, artist = "Werxzy",
			lore = "Card back created from there being too many blue card backs."
		},
		{ 
			sprite = 120, artist = "Werxzy",
			lore = "Referenced from Window's original solitaire card back."
		},
		{ 
			sprite = 118, artist = "Werxzy",
			lore = "Referenced from Window's original solitaire card back."
		},
		{ 
			sprite = 115, artist = "Werxzy",
			lore = "Pico-8 Icon"
		},
		{
			sprite = camera_card_back, artist = "You",
			lore = "Ever feel like you're being watched?"
		},
		{ 
			sprite = 117, artist = "Werxzy",
			lore = "Voxatron Icon"
		},
		{ 
			sprite = 121, artist = "Werxzy",
			lore = "Falling Solitaire"
		},
		-- don't just add to the end of this list, as the cardback won't be added to your mode
		-- instead, create your own lua file next to this one.
	}
end

-- when init is true, the card art will need to be recreated reguardless
-- card_art_width and card_art_height are given to help know the art's bounds
-- camera and clip are used around this function, so be careful
-- data is the card back sprite info
function camera_card_back(data, width, height)
	-- get mouse position
	local mx, my = mouse()
	mx = mid(mx - width\2+1, 480-width) -- technically also use - left or -top
	my = mid(my - height\2+2, 270-height)
	
	rectfill(0, 0, width-1, height-1, 1) -- base (prevent transparent pixels
	sspr(get_display(), mx, my, width, height, 0, 0) -- screen
	rectfill(0, 0, width-1, height-1, 32) -- darken
	if(time() % 1.5 < 0.75) circfill(5, 5, 2, 8) circ(5, 5, 2, 32) -- red dot
	
	-- scanlines
	fillp(0xf0f0f0f0f0f0f0f0)	
	rectfill(0, 0, width-1, height-1, 32)
	fillp()
	
	-- returns if the art has been updated (here is always true)
	return true
end

function random_card_back(data, width, height)
	if init then
		rectfill(0, 0, width-1, height-1, 5)
		color(32)
	--[[
		for i = 1,40 do
			line(rnd(width)/2, rnd(height)/2)
		end
		local w, h = width\2, height\2
		sspr(data.sprite, 0, 0, w, h+3, w-1, -2, w, h+3, true, false)
		sspr(data.sprite, 0, 0, width, h, -2, h-1, height, h, false, true)
	]]
		local w, h = width/2, height/2
		local r = w * 0.6
		local ph = rnd(10)+2
		for i = 1,140 do
			local r2 = sin(i/ph)*6
			line(sin(i/20) * (r + r2) + w, cos(i/20) * (r+r2) + h)
		end

		return true	
	end
end


--[[

function get_info()
    return {
        {
            sprite = card_back_art, -- sprite_id, userdata, or function
            artist = "Artist", -- who made the art
            id = 14141414232, -- consistent, but unique id
            lore = "info about the art or whatever you want"
        }
    }
end

function card_back_art(data, width, height)
  -- if you only need to generate the art once, use init
  -- data has the table returned by get_info(), just in case you need to get the sprite itself or if you want to store extra data
  
  -- camera, clip, and set_render_target() are used outside of this function to help simplify the process
  
  -- width and height are created to help you know the exact size of your art
  circfill(width/2, height/2, width/2, 10)
  
  -- color 32 is special, and can be used for darkening colors (for stuff like shadows)

  -- return true if the card art has been updated (this adds the card border or makes cuts to the art)
  return true
end

]]

:: card_backs/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTIxIDIwOjM2OjA3Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTIxIDIwOjM2OjA3Il1d
:: card_games/
:: card_games/falling_cards/
:: card_games/falling_cards/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTI0IDE5OjUzOjAyIixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1NjozNyIscmV2aXNpb249NTQ5OF1dbHo0ADMeAADvcAAA8Cl7WzBdPXtibXA9cHh1
AEMgQkMEAIYPFvAclgAGbgYOBQ72GQ4FFo4GfhX_HAYOBW4FBo4FLvUV3ggA8GAeBf4WBh4FjgUG
fhU_9hUuFX4FBm4V-h4VbgUGXhX_IBVeBRY_Ff4iFS4GDgUGDgUeFX72FH4VLhUORX4G-h1VDjV_
Bh4-FR4dHg0_DT49Dg0eDR4dLgV_NQ0OBZ4GLjUODRUNDgU_BT41DgUNDgUPAOAuBZ4FDQWeBj4F
PgUeBR0AYE4VHhUNBZoA9ACOBQ0FBh4FTgZOBR0eBR0eAKA1DgUOHU4FTgUeIACDDgVOBl4lHjUd
AMIFDhUOBQ4VXgUuBS4fAFgOBi4GXl4AAQoAIB4FIwA_DgYOJQAQLQMAAaoAAA4AHx0pAAYRNQIA
MAUeBSABCyMAL-4eEgAPMB4dLikBzD0OPR4dHj0OLR49DiMAAYcAAYsAMj41Dj8BMDUOJQUABCoA
FAAqAAO9ADFOFS7iABMe6AATPikAFRAoACctDikAER0pAABbASwdHioAFzUpAHw1HhUeJR4lJAA8
PgUOdgAvJQ11AAARLUkBA1gBA5sAAdcAAK4BKy0OLwARHnIAIw41KQACiAAcNSYAKf4eEQA5PvUf
IAAo9SAPACj_Jg0ANxSGjg8AaH72DI4FfhEAeQb_DGgeBW4TACUOCwIAEyoCAEwoISgOJgBDDxoO
DAIAEycCAE0vDiEpKAAdDCcAHykmABIOdAAPmgABFogkAB8uvAAIEY4iAJMeBo4GDg8bDgQCAEEv
CQ4jAgDwGC8YISIOBX4GHgUQBr4G-gxiHgWuBQBGnvULjhV_Zr71F24GHgYeBpkB9hH_EqVuBj4V
Bl4F-iIGXgUGbgX_IAZuBQZ_BT71FU4Gfl4EIAaODAAAXgTwAQaOBX4GDgX_HBZ_BY71HS6zALKV
DfUbDpUOlQ1FPQIAEWUOAFc1DTUNJQQAoVUOhQ0OlQ0lDXUCABq1DwAo9QYOAFulDZUNpQ4AEzUO
ABGVDgAg9RoHACr9HAwA8Q8FnfAcBZ0sZmxhZ3M9MCxwYW5feD0yLjU5NTIzODAGABE2FgB1eT0y
My4wMBgApzUsem9vbT0xfSyHBf8PM0MEIPUdQPUfIBX-FR0VAA4FDvUdDgUu9R8u9SEeAwCacA4A
DvUfDiDAAGtADvUbDiAkARMwFgESMAgBHzIIAR5IVY71EgUAOC71GAUAgm71FB5VfvUTHgDyAKUO
9RUexS4lLvULHqUOBQkAL1VeCQAGAysAKcWOBQDwDfUDHvUMHvUDDhVO9QYe9QVu9QUe9QSO9QQe
9QQxAAAIACEeNQgAIAk_BgAgB04iAEQHPvUGDABBCS71BSYAQA4VTuU3AOBFbtUe9QReBY7FHvUF
Tn8AgMUe9QY_BR41CQDwFxA_xR71Dz7VHvUOPuUe9Q0_9QAe9Qw_9QEe9Qs_VS6FHvULLlU_BwAx
XhVOBwAmBV4HADASHgUjAB8VBQAKOBKOVQUAD7kBK9A1RQQ28B1GHxYF9h4elwf-Bf4dBh4FDiX_
HjUG-iEVAAb_IQUQBQD-D1MANv4dRjwBQAYe9R5DAX-1IA5l8B01jQELGjNGAx9aRgMP8Qxl-hNl
HlUO9RMOVR5FDvUVDkUeRQ4lHvULHiULAAAsCSH1CTEJAQ8AEA7EAgDUCQwpAC-1FQcAmg-jACYD
LAEBOAEv9SEDAAKfDvUjDiUPFiUNAgABEAUeAD8FDSUCAAMCHQAPAgAcDzUAIw_EAAYApQAPAgAa
P0UNJQIAAj9FDQUCABoPeAAdDjIAD2IAoi8tBQIAAg9KAB9PFR0FLQIAAk8dFQ0FAgAcPxX9ITUA
Iy8tBQIAAwNSAB8tAgAEX-0jBf0hBgAAD30GGfElOQwEIPYjQAb-FiQgBv4lBQAG-icFBj5PFQ5d
Hj0eTS49Lk0OXT4FBi4NRQ5VDg01DQ5FDQcAABAAABgAUAV_FS4FrgwEBAAQXuYOQy4FPT4YABM9
BADCHi0OBR1uBQY_NQ0uGwAAGQRRBR4lDiXPChQuSAAiDQ4IACEFDkoAEU0aACY9BRYAAAwAo00_
BT5FPhU_NR4XAFseNR5VTvoAVjI1LjgzAQADCAFXLTAuMTYBABI3GAEZNhgB8AkpDQQQ9hUgBv8V
FQUABh5FHkUuNR5FHmVdBlJPFgUOTYgAcE0FHk0uBQaWDxcOBAA0Li0_FQATNRUAUzUNPg1OFQAT
TQYARCUOJR4oACI_BSgAh24dBR0uBQ0eOQBxDg1_LT4VHjYA-wMePR4Njg1OJf4VFQD1FyD1FRDu
AQsP1gAEERbWACBPFeIBQB5NHm2HABVF3AFARQ0eRdYAA1sBBAQAIC4l1gAFgwECCAAzPgVOFQAT
RQYAMC0OLU8ACc0BQG4VDRU4EAY4AJIOBX4lPhUeRR68AT8FjgXVACXPMU4EDx32Hw4G9x8WAwCj
8RUGDgY3Fg79Dw4WNwYODU8SDQ429wk2Dg1MHQwN-hsNDB0M-h0FAB09AwASLRsAAycAAQcAXw0M
-R8MQQELCkINYDZBBCD2IAQEkCEgBv4iBQAGLhoCAAAEQR5djibLAhBF8QMCHAIxDlV_3gEQBuoR
ALIRAtMBEL5yCSEGBfsBED0bAAToASEdnk8PAGwQIAYusRISXigCYCWeBgUOBokQIQZuOAQEMQIg
3gaBECAGHmQDJU0ONAIhTY6AAjBFLkUwAqI_BQ5V-gAFBv4kBAA3HlEOAgAfHhEAEo8PEAEcAQwO
DAYADwAuAG8MAQwRDA4GABABLQAgEQw8AA8GAA8CWgAFaQAPhwALD9cAETcuUQ4CAPMBHhX_JCX_
IhUG9SUGDvUiDjEBERUrACAGLuUBAGYEAAcEAhMAEx7oAQCDBBQFEQQDGwACpAEyFR0VkQEsPgWc
AAPFAQAQCgW4AQsZASQFXjwAAjAECwsBBh8ABDwEDGMABxICEj0EAAKeAAUXAgCqBQITAATnAA8g
AgMnXA4CAB8eIgABKlEOEQAq-iQ-AUEeDV5dpQVDXQ4NXhMAMQVeVZ0ANlUOBRMAAycDPF4FXs4A
QV4FHT4cAE0dPgVeKwERJRwAECUbAA0nARJeogEPVQABQU0OBU2CFAEKAAO9AL8eVQ5VLhUuVQ5V
Dh4BIAxWAgsxAP8CJf4iRf4gJQD1JCD1IkD1ICB0DRr1FgoE8SUfGTEOIR4hHhEOEQ4BPhEeET4R
HiEeIQkRCREZEQkRCQEEAFYxCREJMRAA4Q8QCh0KDQoNCk0KPQoNDAAzPQptCgAQHQYALxotHAAF
8AAaDQotCj0KLRodOg0qHSoKACAtKjQAcy0KLQpdCj02AAAQABAdDAAAcQAAkwACgwAChQACEgAB
GgAwHhE_uwDrQQ4BLiEeIQ4xHiEe8SUKAWYtMTcuMjWLCBQ21hIZOBQB0BgEBFhaW1FeV18aXxAK
AAAEAA9VAQsKQQCwJw4E8AyGEPYMjxbVCXUMYR4FBg4BAgATIQIAEIFvGEMPEA4NAgAULQIAICEt
GgAfDRkAFy_BDmEAAQ8XACABrACvDvULjvUZ8AulAM4KGQz1AD9oHgWjFQYBUhYTDQIAFidSFhos
3wAEGgAfLBkABQNNAA8rFgEPfQAKMxsOCQIAQS8JDiQCAEEvGCEjAQEfYwEBKfAEAgYgBkCGEPYC
DxYGAA8VDxZGjg0BUQFPFQVOEQExAQ4IAgCFAQ4oDhFCDiiTAEEQDg8O3ACGDxAOLQ4cTxXwAREM
GAC-DQ4MDi0ODBIrAQUaAANkGwQBGwUtUQAIaQCNARQrBAUoDogYADZbBSgwAPAGDxgOCg4KDgEO
Kg4BMg4LBSoOKiEqEwFQASsFbmoWAf8HABsFC2WO9QELBSsVC-UA8AAFIAULQCYBG-sHFAEEBwoJ
DxkIDxgCDxUPEg0PHQYHYEIAky0yLjQyODU3MQYAA1EARS0xLjAUADIyODZgAC8xNJMKvn-2H-4h
Hf4fAwAF-wUNDxL9HwwA-B8QDf4dDRAM-R0MAHUKGXAHBwQfFiYuAAoCOQoDJQoDFAoAAwovJR5R
AAsZNVEAwQkJBC8WJk4GLgUuBqEaAgYAEQVeABIeXwAQLp0IAyIAP04lLl8AGfALDxEEQEaABl8W
YAZuBUAGjgUgBj4mPgUABj5JHTIFBi7GACEuBQscEQ68GRI_zQAwLhVOMQv-ByU_JT5FjiUAJW4l
ICVOJUCFYGWARUDUBRnwAAYVBEAGMAYPFiAGHhAGLnwAGU4CAP8ErgVOFT4lLgAlHhAlDiAVBjAF
BmAAGv4CFAQPFgUwHgUgLgUQPgUATgUCAO8_FS4lHiUADiUQJSAVMF4AGPsJKBYBAABDAAAABBD-
GA1Q-g1QTvADTlD_CwBiIA74DQ4wBQCPSA7wAQ5IDjATAAliAA74Dw4QBQB-aA7gDmgOEBIABzQe
_A8NAFR4DsAOeA0ADywADFSIDqAOiA0ADywADFSYDoAOmA0ADywADFSoDmAOqA0ADywAAzMODgIO
AFC4DkAOuBYABhMABS4AAxMAoB5o-gcSEA5o-gEWAFDIDiAOyCYACBUABDMABhUAUB5oDvIIGQAR
4hkAMdgu2CcACBQABTUABhYACzYAA48ACBMADzUAOS0HIDUABxMABzUAJgcgNQAnBjAiABToIgAv
BjA4AAElBjA4ACbwChkAMh7IHiEACBUABQgABBUACzUAaw4CDqgOAiQAAQ0AH_A5AAxbEg6IDhIk
AAENAB-gOQAMEyIEACsQDhkAH_A5AAxbMg5IDjIkAAENAB7gOQA2YO4wRgIANwgUQkoCFzAxABfg
FQACXgJkXyAO6A4guQFUAEIuQgC2AgCuATrtDmjLAhEgygJWDk0O_AHwASEQogYABA8ACzUAABUA
DzUAADYggiAgAA81ABVWDSBiIA0iAA83ABVWHSBCIB0iAA83ABVWLSAiIC0iAA83AAhGAg74ACcA
Nz1gPfsDD0YBABICBgBhDmgOTRKOHAAEuwE4TUBNAwQLOwACFgAw_AK_iQIjTZIcAAQxAzldIF2g
Aws8AAMWAHyoDrIOaA5APQAZ7SUAAjMABIcFAxYATx6oDqI7ABUElgUEFgAAdwMAOAAvUII9AAUl
ByA9AASnBQQWAFASDqgOcvcBL2ByPgAFJAYwPgCWAg6YDmAOmA4CGABlIg6oDlIdXwAGCAAd7V4D
lRIOmA5ADpgOEhcAVzIOqA5tNAAPPAAHlSIOmA4gDpgOIhcAV0IOqA5dNAAECAA9AM0APgB1Mg6Y
LpgOMhUAEAA9ABdNNQAECAA9EK0QPQBlQg74BQ5CFAAQEDwAFz00AAQIAD0gjSAYBIUNQg74Aw5C
DRYAECA_ABYtlAIEPQA3MG0wHAQBHgAgHUIxAyRCHRUAIA4wPAAUHQkDBCQBVEBNQA5oIAMABQCE
LUIO6A5CLRApABBNNwAcDTcAOlAtUDcAhD1CDsgOQj0QKQBbXUIOqB41AAKuAAUzAAFaACNCTRIA
b2gObUIOmDMADHNdQg6IDkJdEgBvaA59Qg6IMwAMEG1vBSNCbRIAb2gOjUIOeDMADHN9Qg5IDkJ9
EgBBaA6dQicDsfgNDgIQAg5IDgLtBgACDAAU4AwAJvgNBwARjegFFo0WAEBIDgKtVgCxIv4NEhAS
ThLtEk4IABHgCAAj-g0FABGN5wUTjRIA8ANOEr1CTvITEILtghCC4IIQ8hEDAFCNEKIQjQkAQYLN
8hwYAAccADIggiAcAEu9EPIbHQBSnSBiIJ05ANcQgg3yDw0QDWIN4A1iCAAx8g8gGQBSrSBCIK0P
APcDYg0AzRBiAB3yDR0QHUId4B1CCAAx8g0wGQBSvSAiIL0PAKZCHRDNEEIQjeCNBACg8AqN4I0g
vWC9IAsAPiDNcB4AUDC9QL0wCwA_MM1gHgBQQL0gvUALAD5AzVAeAEBQ-QlQCgA_UM1AHQBAYP0H
YAoAOGDNMB0AIP0PDwBAcP0FcAoAVnDNIP0RHAD4ABAg-RGA-QOA-RAgjYDNEBsAgBEQ-RGQ-QGQ
FAA8kM0AGwAwoO2gEwA6oP0eGAAwsM2wGAA6sP0dGAAwwK3AGAA6wP0cGAAw0I3QGAA60P0bGAAw
4G3gGACi4I0A-Q8wbfABbQUAo-0PMP0P8AFN8AEXAIIg-Q1QTfADTQUAo-0NUP0N8AMt8AMXAB8Q
cw4Z8AIvEwQg9hlABv8WGiAGLvAVLuoYIPAXaxg-8BkeBgAaQAXwFwVtFvwJ8BUFLhU_9RU_Jf4b
FQAV-hkVIPUbQPUZABUaLfUTLzg39RMC8XMtPATw-2wuQA4wHvAOLkAOIC7wDi4wHhAu8BYeAC4Q
LvARXiAu8BFOMC7wES8YXvATPT7wFC0QHvAVLfAaHfAbHfAU2PAO_ADwDPgC8Ao4LsjwCEgu2PAG
WC7o8AW4vfAFqM3wBZjd8AWI7fAFeP0A8AVo-QHwBVjNCA0IDQjwBVi9CQAfDRMAFhBtCABwaPAF
DyBIXQsAgQgNSAzwBRw4GABjSBzwBSwoGABhKCzwBTwYGABjKDzwBUwIGAD7DQhM8AX8CPAG-Abw
CPwE8Ar8AvAM-ADwDtzw-8NEAUYzLjMxexEFkBE2Ni41kBEfOWAWAQFXAfATaMgPGPAOyC7wDMhO
8ArIbvAIyI7wBjgvDliu8AU4LUiuCAcA-6c4HyCOGPAFmDxuKPAFiFxOOPAFeHwuSPAFaJwOWPAF
-AFo8AWsECx48AWcMAyI8AWMQJjwBXxAqPAFbEC48BDI8A-IDPAOyBzwDcgs8AzIPPALyEzwC7hc
8AyYXPAOeFzwDwxYXPAPLDhc8A9MGFzwELzwEjwNCDzwFBwdGBzwFi0o8BY9OPAUTUjwE0hO8BQ4
PvAWKC7wFwwYHgzwFiwIDizwFJzwE5zwFHzwFlzwGDzwGhzw5ykBNfEIUA8EED8UQB5APjA_IA4w
DhBeID4gXiAOAGA6DiAOGg4IAPEAEA46DgAOCg4QDgoeWg4ADgACCAAVEAwAgyoOEA5aHloeJgAF
AgBQCj8ZCh4pAOAKLRoeCj0KHgo_Ch4KTQMAIk0KEQDxAj0KHgc_Bx4dFw4QDg0eFw0eBQDgVx5H
DgAORw4QPhceDTcQAPASBw4fIA4HDgAeFw4gHhcNDhAODA4XDgAOVx5XHlcOLA4XHBBgNw4ADg1H
ZgDwAg4AHhoeAAwOGg0eDA4KHh0KcQACdABADhwOGsAUAAsANQAOPbAAMQ4MTgwAACAAIQ4c0ABD
DToNHggAcQ5MDgoeSg0LACEADCIAIg06DwCQDA49DgwOXR5dTwCQDgBMDg0eTQ4cFQBREA4dDhwV
AAAkAPAaLD4cAF4QXgAcPnwOHE48PhwQDB4cABw_HAAMPvwSAPwHEDwQ-CBA-AMIAEAAAFwABQCG
UJwQXCA8IFwGAN5wDBBMMDxAHEA8MDwQeQQlNjcBACc4MsYUcTk2MDMxNzQGAA8OAgFwCA8EoB8U
QPYBADsBAVkBQh8ZGh1KAf8AHyAOHQ5MHqwAXCA8QBygCRIYgyBKDwQATxQwZQJEMD4wTgwAWgAO
Sg4QYwIDEAANGAABhwEAYQIzAA4adQIHEgACaQIEUAIwCh4aDQIgCi0qACoKPRkAAC8Ccx4HPg0e
Nw1yAgNFAgMUADIADkdvAiEvIFECIhwQbgIDFgASLBUABlcAANECQx0aDgxsAh4AGgAhDloMAFZa
HgoeDbwABhMAAFYCAJUCEApNAiAeCmIXEwonAA8aAAAgHk0HAAB_AgN4AgIMACAADn4CDxwAA4AM
TiwOPA4sPgYAOCBeEA8A8QsA-BAAfAD8GxDcADwAfACsENwArAAsECwAXAYAN3wAbA4AcUwgDDAM
IDwGACdcIA4ADAoWTy05LjCKIwA3Mi40iiMPhQICkT4PBAAPFGBeEI8EMBAOcAgAME4wHgYCJkAO
YQQzCg5QGAIAKgIvGh4eAAUARQECHgAzCk8ZIAAnCk0hAAIFBPIBGh4HDkAOJy4ADgcOEA4HHgoA
E1AOAFJXDgAOFyIAABYCAyMAJw4sIwAhRw0kANEKTgAOCh0uDA4aHhoeCQBACk4QDusBhwo9DgwA
Dh0eVgQDBwIQHH8AAA8AMQwODZgEAhsAAvIBEEwdAABaBBAcSgQCZAQE2wHgTAAOHQ4MXgAMXgAs
HjwIAPIBEBw_LA5MEAwe-BkA3CD8BEMEQaxQ-ARSBNAQXAAsUDwAXBBcMBwwBgBcPCAMcBy9AU8y
My41gCMJEUijAQMuBlEOMA4gPs8DNU4gXqsDAyYGAQ4ABSoGAs0DN0oOAKkBCAoAAgIAACwBAHYE
AaYBEj6tASY9CgQAEE2OAUAeFx4AgwEDJwYAugMARAYhRw25ARBXKgYzFw4cIgAjDUe3AxEHEwAR
V7oBAPcBNAweGhwGAQ8AFA61AxM_bAABwAElPgqYABdaCgAClwMCzAEGowMEBAAFHgAAgAMqHl2O
AyEOPR0GFhwUAAEiAEA8DgwAHAYRLAoAUQw_PD48DADzABxeAPw7EPwGEPwOENwQrIwDMFwQXM8B
gxCsAAwwDBBclgNBPDA8MAoAABwADRoGGTEGJwPjAQkzJy8zM0AbAaIODwQAHxQgHiAefQUBBAAf
HgoAAQCRBwEEAAcKADAfGQ6pAgD9Ag8zAAEUHR4AcQ4PIB4MAAwEABFMjgQCBACPPAAcIBwgHABz
BhkBAwpCnZjwESALsA1ILnjwDFguiPALBQDwDAn4BPAHKA8Y_ALwBvgH8AY4DfgC8AX4CPAFSAoA
cQP4CvABKA0MAGEA_A3wADgMAFzg_A7gSAoA8AS4DfgADyDgSA1YDfgADOC4HdgcDQBwPZg84Li9
XAsAhL1c4FgNWJ1sBgDhHVh9fOBYPUhNnOBYvbwEAEIMWJ3MBQD-FBxYfdzgPEhN-ADg-A7g-A7w
APwM8AH8DPAC-ArwBfwG8P_SBwELHTKYHIIW_R8OCfofGQMAn0pH_hUZOmf6FAUAEQEtAA81ACUP
AwBb8AwJDgk6GQ7-GQ8OGToJDg1EDQ45_gk5Dg1EHQQlJ1EEHQT_HQUAHT0DABItGwADJwABBwBf
DQT9HwRrDg4PHDpWQR72IB4cOqwuBv4iVQ41PgZeHDowbgU_xSU-bgZeHDoBdV4FbgUNBX6ZOQYc
OjKOBW4cOj4_Bl4cOgIwAA8cOv---8oNIzoB-jkOJDoPFToNDyM6HgMHAB79HjoP3QcQXxAQBPDw
MQD----w8AAtEATwH-8SGSAOLV8d-RBBDKEGBxYHFgcGDAYcAgDyAQwdAQ0MDSEtUR0eDQZ3FgcC
ALpcTQwdAR0hDR4NFi8AYT0BDUENIRoAMQENDGUxMQENEQIAFUEaABkRAgAPGAAJH3EuAAcUHVgA
AQIAMB0hLaQA3y79GR4C-hsCAPIb8EsJASMR-WkNHAF1AD8dUR25AAUPGAAODwEBUQKkAGANDhIO
-Rh0HI-_GAIw8hjwTQUBNgNiAQ8FASYPBgKRKC9M7BoS9uwaMQb_FVkzCvo1ER4SAAz_NQIWAAGb
MAoCNgcZAAoGNgYZABhFCjYHMAAD0jEDDjZHHgUGTkMAARE2AV4AGQUWNgETAJ8V-hUVHgU_9Rdu
GwIQUOoAYP4aIAb_G5EpSPYVPgXtAB9N7ACZID4FuAAP5gAQEfXmADL1Fy4fASIFBk8ABu0AAxEA
C_0AAxYAAYkACe0ACBkACe0ABxkACO0ACDAACe0ABBkABkUAAe8ABy8BAu4Anz4GLhU_BQ72E_kA
BgW4AhP9ywGgHUUdRS01HUUdZd0yABEAgE4FDU4FDQU_BwAzHU4tFgBHDj0ODQQAOC0uPRkAEzUZ
AFc1Dj0OTRkAE04GAEglDSUdMAAiPQUwAABAAgFiACcuHUQAMw0OfV8AIQUdQgBTHT4dDo1ZAC4V
-bgCDyYeBxUwaRU0MjIuGDIfNBgHHR85MQCR8QkFXxaADl8VDmAODVQNDkAODXQNDiAODZSEGQIG
ADEkPSQIAPAEFA00DRQNDhAeDQQNNA0EDR4QLqAR8QYdLiAuHRQdLkAeDTQNHmAODTQNDoCyEV_g
DRQNUJEAGfACEhIE8BoEDxUUDgSgBA8WBAbyEbCABAYNDhQODQYEYBEA8RE_BA0GBEAEHQQONA4E
HQQwDgQeBA0WDQQeBA4wBAYEDg0AYA4EBgQwBAgAED0SAAImADIOFA4mAJEdHgQdBB4dBEAiABEd
IgBzYBQONA4UgBAAEKC9EY8OwA4UDuAecJ4uDA_EAR4PMQD-----------------------------
------------------87UG09OX19
:: card_games/falling_cards/falling_cards.lua
--[[pod_format="raw",created="2024-03-22 19:08:40",modified="2024-07-21 13:23:51",revision=15186]]

-- built-in card sprite generation script
include "cards_api/card_gen.lua"

-- including or fetching files next to the main file should include
-- "/game/" or "game/" at the start of the path
include "game/stack_rules.lua"
include "game/particles.lua"

--[[
maybe later?

? bonus suit that awards x2 points, multiple cards with the bonus suit increases the bonus exponentially
]]

-- some variables used for consistency
card_width = 45
card_height = 60
card_gap = 4

bonus_card_ranks = {"wild", "bomb", "shuffle"}

function game_values_reset()
	dealout_flip_count = 1
	game_score = 0
	game_combo = 1
	game_combo_decay = 0
	game_level = 1
	game_levelup = 0
	game_overload_check = false
	game_card_limit = 10
	game_over = false
	game_prepare_bonus = false
	game_super_bonus = false
	new_highscore_found = false
	
	game_exploded_meters = {}
end
game_values_reset()

-- function called after the game is selected and started from the main menu
-- name must match
function game_setup()

	-- save data is based on lua file's name
	game_save = suite_load_save() or {
		highscore = 0 -- default save data, can store game settings here
	}	
			
	-- stack that will contain all the cards
	deck_stack = stack_new(
		{1+256},
		28, 16,
		{
			reposition = stack_repose_static(-0.16),
			y_off = -5,
		})
		
	-- stack that will contain all the cards
	stack_discard = stack_new(
		{2+256},
		28, 86,
		{
			reposition = stack_repose_static(-0.16),
			y_off = -5,
		})
	
	-- get the card back sprite that the player wants to use
	local card_back = suite_card_back()

	-- generates sprites with given parameters
	card_sprites = card_gen_standard{
		suits = 1, 
		ranks = 8,
		rank_chars = {"1","2","3","4","5","\^:10081e3d3f3f3f1e","?", "S"},
		suit_show = {true, true, true, true, true, false, false, false},
		face_sprites = {[6] = 24+256, [7] = 25+256, [8] = 32+256}
	}
	
	for i = 1,12 do
		for rank = 1,5 do
			card_new({
				sprite = card_sprites[1][rank],
				back_sprite = card_back,
				stack = deck_stack,
				a = 0.5,
				
				-- assign the card it's rank and suit
				suit = 1,
				rank = rank,
			})
		end
	end
	
	
	stacks_supply = {}
	for i = 1,5 do
		local s = add(stacks_supply, stack_new(
			{4+256},
			(i-1) * (card_width + 9) + 109, 90, 
			{
				reposition = stack_repose_normal(nil, nil, 140),				
				can_stack = stack_can_rule, 				
				on_click = stack_on_click_unstack(unstack_rule_decending, unstack_rule_face_up),
				y_off = -5,
			}))
			
		wrap_stack_resolve(s, true)
	end
	
	stacks_prepare = {}
	for i = 1,5 do
		add(stacks_prepare, stack_new(
			{3+256},
			(i-1) * (card_width + 9) + 109, 6, 
			{
				reposition = stack_repose_normal(),	
				offset = -4,						
			}))
			
	end
	
	-- creates 3 stack for storing extra cards
	stack_storage = {}
	for i = 1,3 do
		local s = add(stack_storage, stack_new(
			{1+256},
			406,
			(i-1)*(70) + 35,
			{
				on_click = stack_on_click_unstack(),
				can_stack = can_stack_only_one,
				y_off = -5,
			}))
			
		wrap_stack_resolve(s)
	end
	
	stack_off_frame = stack_new(
		{},
		-card_width*2,
		-card_height*2,
		{
			reposition = stack_repose_normal(0)
		})

	init_menus()
	
	button_new({ 
		x = 30, y = 163,
		width = 41, height = 13,
		on_click = function(b)
			if not game_over then
				apply_combo_decay()
				cards_api_coroutine_add(reveal_next_card)
				b.t = 1
					
				-- sparks
				for i = 1,5 do
					new_particles(b.x+rnd(b.width), b.y+rnd(b.height), 1, 0.5)
				end
				new_particles(b.x, b.y + b.height/2, 5, 0.8)
				new_particles(b.x+b.width, b.y + b.height/2, 5, 0.8)
			end
		end,
		draw = function(b)
			b.t = max(b.t - 0.07)
			
			local click_y = ((b.t*2-1)^2 * 2.5 - 2.5) \ 1
			rectfill(b.x, b.y, b.x+b.width, b.y+b.height, 5)
			spr(b.highlight and not game_over and 262 or 263, b.x, b.y-click_y)
			spr(279, b.x-3, b.y-2)
		end,
		t = 0
	})
	
	
		
	-- adds a coroutine that sets up the game and prevents interaction with any of the cards
	cards_api_coroutine_add(game_setup_anim)
	
	-- resets the position of all cards
	card_position_reset_all()
end

function init_menus()
	-- initializes the menu bar
	-- will currently contain the click, exit game, and settings buttons
	suite_menuitem_init()
	
	-- new game button the resets how the game plays
	suite_menuitem({
		text = "New Game",
		colors = {12, 16, 1}, 
		on_click = function()
			-- when clicked, create a new coroutine that will control the game
			cards_api_coroutine_add(game_reset_anim)
		end
	})
	
	-- adds a button for the built in rules text box
	suite_menuitem_rules()
	
	-- adds a label for the number of wins in the game
	highscore_button = suite_menuitem({
		text = "Highscore", -- name
		value = "0000000" -- default value
		-- no on_click attribute means it will not do anything when clicked
	})
	
	-- function used to update the text value
	highscore_button.update_val = function(b)
		local s = tostr(game_save.highscore)
		while(#s < 7) s = "0".. s
		b:set_value("\fc"..s)
	end	
	-- updates the value on setup
	highscore_button:update_val()
end

-- deals the cards out
function game_setup_anim()
	game_values_reset()

	-- wait for a bit
	pause_frames(30)
	
	stack_quick_shuffle(deck_stack)

	-- deal 7 cards out
	for i = 1,4 do	
		-- for each stack
		for j, s in pairs(stacks_supply) do
			-- take the top card
			local c = get_top_card(deck_stack)
			if(not c) break
			
			c.a_to = 0
			stack_add_card(s, c)
			pause_frames(3)
		end
		-- extra pause between every row of cards dealt
		pause_frames(5)
	end
	
	game_dealout_anim()

	-- notify the api that a new game has started
	-- this is important for re-enabling card interaction
	cards_api_game_started()
end

function game_dealout_anim()
	local adding = nil
	
	-- 3% chance that all dealt cards are bonus cards 
	-- only once per game
	if game_prepare_bonus 
	and not game_super_bonus 
	and rnd() < 0.03 
	and game_level >= 11 then
		game_super_bonus = true
		game_prepare_bonus = false
		
		adding = {}
		for i = 1,5 do
			add(adding, rnd(bonus_card_ranks))
		end
	 
	elseif game_prepare_bonus then
		game_prepare_bonus = false
		
		local rank = rnd(bonus_card_ranks)
		if rank == "wild" then -- two wild cards seem more balanced
			adding = random_least(3)
			add(adding, rank)
			add(adding, rank)
		else
			adding = random_least(4)
			add(adding, rank)
		end
	
	else
		adding = random_least(5)
	end

	for i, s in pairs(stacks_prepare) do
		local c = get_top_card(deck_stack)
		
		if not c then
			game_shuffle_discard()
			c = get_top_card(deck_stack)
			
			if not c then
				-- TODO: make sure this isn't possible
				-- ensure there's enough cards by constantly adding
				-- or by having a decent count added
				break
			end
		end
		
		-- assign new rank
		local new_rank = del(adding, rnd(adding))
		c.rank = new_rank
		
		if type(new_rank) == "number" then
			c.sprite = card_sprites[1][new_rank]
		
		elseif new_rank == "bomb" then
			c.sprite = card_sprites[1][6]
			
		elseif new_rank == "wild" then
			c.sprite = card_sprites[1][7]
			
		elseif new_rank == "shuffle" then
			c.sprite = card_sprites[1][8]
			
		end
		
		c.a_to = 0.5
		stack_add_card(s, c)
		
		pause_frames(5)
	end
	
	pause_frames(10)
	-- reveals the first card
	for i = 1,dealout_flip_count do
		stacks_prepare[i].cards[1].a_to = 0
	end
end

function game_card_drop_anim()
	for i, s in pairs(stacks_prepare) do
		local c = get_top_card(s)
		
		c.a_to = 0
		stack_add_card(stacks_supply[i], c)	
	
		pause_frames(3)
	end
	game_overload_check = true
	
	game_dealout_anim()
end

function game_shuffle_discard()
	stack_collecting_anim(deck_stack, stack_discard)
	pause_frames(35)
	stack_shuffle_anim(deck_stack)
end

-- coroutine that places all the cards back onto the main deck
function game_reset_anim()
	stack_collecting_anim(deck_stack, stacks_prepare, stacks_supply, stack_storage, stack_discard)
	pause_frames(35)
	stack_standard_shuffle_anim(deck_stack)

	game_prepare_start_cards_anim()
	
	game_setup_anim()
end

-- while all cards are inside deck_stack, put them into the starting state
-- for now, all cards are the same suit and go from 1 to 5
function game_prepare_start_cards_anim()
	-- get rid of extra cards
	--[[
	while #deck_stack.cards > 60 do
		local c = get_top_card(deck_stack)
		c.a_to = 0.5
		stack_add_card(stack_off_frame, c)
		
		pause_frames(5)
	end
	]]
	
	local i = 0
	
	for c in all(deck_stack.cards) do
		c.rank = (i % 5) + 1
		c.suit = 1
		c.sprite = card_sprites[c.suit][c.rank]
		
		i += 1
	end
end

-- called any time a game action is done
function game_action_resolved()
	-- if no cards are being held
	if not get_held_stack() then
		-- check all stacks
		local m = 0
		local scored = false
		for s in all(stacks_supply) do
			
			local r = 1
			for i = 1, 5, 1 do
				local c = s.cards[#s.cards-i+1]
				
				if c and (c.rank == r or c.rank == "wild") then
					r += 1
				else
					break
				end
			end
			
			m = max(m, r)
			
			if r == 6 then
				-- SCORING
				local s2 = s
				cards_api_coroutine_add(function()
					pause_frames(15)
					for i = 1,5 do
						stack_cards(stack_discard, unstack_cards(s2.cards[#s2.cards]))
						pause_frames(3)
					end
					
					local b = game_combo
					local sx, sy = s2.x_to + s2.width\2, s2.y_to + s2.height\2
					local points = game_combo + game_level-1
				
					if game_combo_decay == 7 then
						new_text_particle(sx, sy - 13, 284)
						game_add_score(points * 2, sx, sy)
					else
						game_add_score(points, sx, sy)
					end
					
					game_combo = min(game_combo + 1, 99)
					game_combo_decay = 7
					
					sparks_on_change(71, 218, b, game_combo)
					
					inc_levelup(2)
					
					
				end)
				scored = true
			end
		end		
		
		local effect_wait = false
		if action_effect_check then
			local c = get_top_card(action_effect_check)
			local stack = action_effect_check
			
			if c.rank == "bomb" then
				cards_api_coroutine_add(function()
					pause_frames(5)
					local sx, sy = c.x_to + c.width\2, c.y_to + c.height\2
					new_explode_particle(sx, sy)
					new_particles(sx, sy, 35, 2.5)
					pause_frames(30)
					stack_collecting_anim(stack_discard, 0, stack)
					pause_frames(15)
				end)
				effect_wait = true
			end
			
			if c.rank == "shuffle" then
				cards_api_coroutine_add(function()
					
					stack_collecting_anim(stack, 0, stacks_supply)
					pause_frames(15)
					stack_add_card(stack_discard, c)
					pause_frames(15)
					
					local lowest = true
					while lowest do
						lowest = nil
						local l = #stack.cards
						for s in all(stacks_supply) do
							local l2 = #s.cards
							if s != stack and l2 < l then
								lowest = s
								l = l2
							end
						end
						if lowest then
							stack_add_card(lowest, rnd(stack.cards))
						end
						pause_frames(3)
					end
					
					pause_frames(15)
					
					for s in all(stacks_prepare) do
						local c = get_top_card(s)
						if c.a_to == 0 then
							c.a_to = 0.5
							reveal_spark(s)
							pause_frames(15)
						end
					end	
			
				end)
				effect_wait = true
			end
			
			action_effect_check = false
		end
		
		-- if a bonus card is needing to take effect, the wait until after the animations
		if not effect_wait then
			if action_count_up then
				action_count_up = false
				
				if not scored then
					apply_combo_decay()
				end
				
				reveal_next_card()
			end
			
			if game_overload_check and not scored then
				game_overload_check = false
				
				local overloaded = {}
				for i, s in pairs(stacks_supply) do
					if #s.cards > game_card_limit then
						add(overloaded, {i, s})
					end
				end
				if #overloaded > 0 then
					game_over_anim(overloaded)
				end
			end
		end
	end
end

function game_over_anim(stacks)
	cards_api_coroutine_add(function()

		cards_api_set_frozen(true)
		game_over = true
		
		for s in all(stacks) do
			game_exploded_meters[s[1]] = true
			
			local s = s[2]
			local sx, sy = s.x_to + s.width\2, s.y_to - 17
			new_explode_particle(sx, sy)
			new_particles(sx, sy, 35, 2.5)
			pause_frames(40)
		end
		
		new_text_particle(240, 180, 278, 120)
	end)
end

function apply_combo_decay()
	if game_combo_decay > 0 then
		game_combo_decay -= 1
		if game_combo_decay <= 0 then
			sparks_on_change(71, 218, game_combo, 1)
			game_combo = 1
		end
	end
end

function reveal_next_card(spark)
	for i = 1,6 do
		if i == 6 then
			cards_api_coroutine_add(function()
				if spark then
					foreach(stacks_prepare, reveal_spark)
				end
				game_card_drop_anim()
			end)
			break
		end
		
		local s = stacks_prepare[i]
		local c = s.cards[1]
		if c.a_to == 0.5 then
			c.a_to = 0
			
			if spark then
				reveal_spark(s)
			end
			break
		end
	end
end

function reveal_spark(s)
	local sx, sy = s.x_to + s.width\2, s.y_to + s.height\2
	new_text_particle(sx, sy, 287)
	new_particles(sx, sy, 10, 1)
end

-- primary draw function, called multiple times with layers being from 0 to 3
-- don't forget to check layer number
-- name must match
function game_draw(layer)
	-- layer 0 is below everything, screen needs to be reset here
	if layer == 0 then
		-- clear function needs to be called during layer 0
		-- or at least drawing over the entire screen
		cls(22)		

	-- layer 1 is above all layer 1 buttons and stack sprites		
	elseif layer == 1 then
	
		-- center meters
		local w = {[0]=1, 2,4,6,8,10, 14,18,22,26, 36}
		for i, s in pairs(stacks_supply) do
			local x, y = s.x_to + 3, s.y_to - 20
			
			if game_exploded_meters[i] then
				spr(270, x, y)
				
			else
				local wi = mid(#s.cards, 0, 10)
				if wi == 10 and time()%1 < 0.333 then -- flash the last light
					wi -= 1
				end
				local w = w[wi]+1
				
				sspr(269, 0,0, w+1,14, x,y)
				sspr(268, w,0, 39-w,14, x+w,y)
			end
		end	
		
		-- center edges
		rectfill(101, 0, 101, 269, 6)
		spr(276, 96, 69)	
		rectfill(377, 0, 377, 269, 5)
		spr(277, 377, 69)

		-- screws
		for i = 0,5 do
			spr(274, 100 + 54*i, 74)
		end
		
		-- stack boxes
		ui_boxes(14,2,2)
		ui_boxes(392,21,3)
		spr(261,400,9)
		
		-- scoring
		spr(265, 23, 185)
		ui_numbers(68, 198, min(game_score, 9999999))
		ui_numbers(68, 213, min(game_combo, 99))
		ui_numbers(68, 230, min(game_level, 99))
		
		ui_bar_levels(26, 224, game_combo_decay)
		ui_bar_levels(26, 241, game_levelup)

	-- layer 2 is drawn above all cards
	elseif layer == 2 then
		particles_draw()
	
	end
	
	-- layer 3 and 4 are mostly reserved and are drawn above everything else 
end

-- just to simplify the drawing calls
function ui_left_edge(x, y)
	sspr(275, 0,3, 3,11, x,y)
end
function ui_right_edge(x, y)
	sspr(275, 12,3, 3,11, x,y)
end
function ui_top_edge(x, y)
	sspr(275, 2,0, 11,4, x,y)
end
function ui_bottom_edge(x, y)
	sspr(275, 2,11, 11,10, x,y)
end

function ui_boxes(x, y, n)
	ui_top_edge(x+2, y)
	ui_top_edge(x+60, y)
	rectfill(x+14, y+3, x+60, y+3, 6) 

	for i = 0,n do
		local yi = y+i*70
		ui_left_edge(x, yi+3)
		ui_right_edge(x+70, yi+3)
		spr(273, x+4, yi+4)
		spr(273, x+62, yi+4)
	
		if i > 0 then
			rectfill(x+3, yi-58, x+3, yi+2, 6)
			rectfill(x+69, yi-58, x+69, yi+2, 5)
		end
	end
	
	local yn = y+n*70
	ui_bottom_edge(x+2, yn+11)
	ui_bottom_edge(x+60, yn+11)
	rectfill(x+13, yn+11, x+60, yn+13, 5) 
end

function ui_numbers(x, y, n)
	assert(n >= 0 and n%1 == 0, "invalid number")
	
	repeat
		local v = n%10
		n \= 10
		
		sspr(266, v*5,0, 6,10, x,y)
		
		x -= 7
	until n == 0
end

-- currently out of 7
function ui_bar_levels(x, y, n)
	local sp_x = n < 3 and 0
		or n < 5 and 6 
		or 12
	
	for i = 0,n-1 do
		sspr(267, sp_x,0, 6,4, x, y)
		x += 7
	end
end



-- primay update function
-- name must match
function game_update()
--[[
	local mx, my, mb = mouse()
	if mb&1 == 1 and lastmb&1 == 0 then
		new_particles(mx, my, 3, 0.5)
	end
	lastmb = mb
]]
	particles_update()
end
--local lastmb = 0


function inc_levelup(n)
	game_levelup += n
	if game_levelup >= 8 then
		local a = game_level
		game_level = min(game_level+1, 99)
		game_levelup -= 8
		
		new_text_particle(50, 215, 285)
		sparks_on_change(71, 235, a, game_level)
		
		if game_level % 2 == 0 then
			game_prepare_bonus = true
		end
		
		-- increase difficulty by increasing the starting amount of revealed cards
		--[[ seems a bit unbalanced, difficulty skyrockets
		if game_level == 15 
		or game_level == 30
		or game_level == 45
		or game_level == 60 then
			dealout_flip_count += 1
		end
		--]]
		
		-- reveal cards on level up, half the previous level rounded up
		local flip_n = game_level\2 + 1
		local function add_next()
			if flip_n > 0 then
				flip_n -= 1
				cards_api_coroutine_add(function()
					reveal_next_card(true)
					pause_frames(5)
					add_next()
				end)
			end
		end
				
		add_next()
	end
end

function game_add_score(n, x, y)
	local a = game_score
	game_score += n
	
	new_text_particle(x, y, tostr(n))
	new_particles(x, y, 15, 1.5)
	
	-- store highest score
	if game_score > game_save.highscore then
		if not new_highscore_found then
			new_highscore_found = true
			new_text_particle(50, 200, 286)
		end
		game_save.highscore = game_score
		highscore_button:update_val()
		suite_store_save(game_save)	
	end
	
	sparks_on_change(71, 203, a, game_score)
end
:: card_games/falling_cards/game_info.lua
--[[pod_format="raw",created="2024-03-25 02:12:03",modified="2024-07-21 13:23:51",revision=5161]]

function game_info()
	return {
--		sprite = can be userdata
		name = "Falling Solitaire",
		author = "Werxzy",
		description = "A point based solitaire game, where if a stack gets too tall, it's gameover",
		rules = {
			"Score points by creating stacks of cards going from 5 to 1. Build your combo meter to score more points.",
			"Cards can only be placed on an empty space or another card that's 1 rank higher. Up to 3 individual cards can be placed in storage on ther right side.",
			"Moving a card or pressing the 'DROP' button will reveal a card on the top row. When a card is moved while all 5 cards are revealed, all cards will drop to the stacks below them and 5 new cards will be dealt.",
			"Every 4 stacks will increase the level and will reveal a number of cards equal to the current level plus 1, rounded down.",
			"If a card is placed on a stack, during a card reveal, when there are 10 or more cards on that stack, then it will be gameover.",
			"Three bonus cards can be placed onto another stack to activate their ability or placed in storage to use later. Every level, one of the next cards will be replaced with a bonus card.",
			"Bomb - Clears an entire stack.\nWild - Acts as any number card.\nShuffle - Shuffles and evenly distributes all cards, then hides all revealed cards."
		},
		desc_score = {
			format = "Highscore : %i",
			param = {"highscore"}
		},
		api_version = 2,
		order = 9999
	}
end

:: card_games/falling_cards/particles.lua
--[[pod_format="raw",created="2024-07-12 05:05:08",modified="2024-07-21 13:23:51",revision=2636]]

-- x, y, z, dx, dy, dz, drx, dry, lx, ly
local particles = {}
local colors = {32,20,4,25,9,10,7}

-- {x, y, time_left, {{sp, sx, sy, sw, sh, x2, y2}, ...}, extra_time}
local text_particles = {}
local total_life = 150

-- {x, y, start_t}
local explode_particles = {}

local dither = {
	0b1111111111111111,
	0b1111111111110111,
	0b1111110111110111,
	0b1111110111110101,
	0b1111010111110101,
	0b1111010110110101,
	0b1110010110110101,
	0b1110010110100101,
	0b1010010110100101,
	0b1010010110100001,
	0b1010010010100001,
	0b1010010010100000,	
	0b1010000010100000,
	0b1010000000100000,
	0b1000000000100000,
	0b1000000000000000,
	0b0000000000000000,
}

function particles_draw()
	for p in all(particles) do	
		--local c = abs(p[6])*7+1
		local c = p[11]/15
		c = colors[mid(c, 1, 7)\1]
		
		line(p[7], p[8], p[9], p[10], c)
		
		if p[11] > 122 then
			circfill(p[7], p[8], 2, c)
		elseif p[11] > 90 then
			circfill(p[7], p[8], 1, c)
		end
		
	end
	
	for p in all(explode_particles) do
		local t2 = time() - p[3]
		draw_explosion(p[1], p[2], t2)
		if t2 > 2 then
			del(explode_particles, p)
		end
	end

--	local mx, my = mouse()
--	draw_explosion(mx, my, (time() - 5))

	local oldp = peek(0x5f33)
	poke(0x5f33, 2)
	for p in all(text_particles) do
		local x, y = p[1], p[2]
		
		local pat1 = mid((1-p[3]/total_life)*17*5\1, 1, 17)	
		local pat2 = mid(((p[3]+p[5])/total_life)*17*4\1, 1, 17)	
		
		fillp(dither[min(pat1, pat2)])
		for s in all(p[4]) do
			sspr(s[1], s[2],s[3], s[4],s[5], x+s[6], y+s[7])
		end
		
	end
	poke(0x5f33, oldp)
	fillp()
end

function particles_update()
	for p in all(particles) do		
		
		local x,y,z = p[1], p[2], p[3]
		
		p[6] -= 0.1 -- gravity
		
		-- move
		x += p[4]
		y += p[5]
		z += p[6]
		
		-- hit ground
		if z < 0 and p[6] < 0 then
			p[4] *= 0.8
			p[5] *= 0.8
			p[6] *= -0.7	
			z = 0
		end
		
		p[7], p[8], p[9], p[10] = x, y-z*4, p[7], p[8]
		
		p[1], p[2], p[3] = x,y,z
		
		p[11] -= 1
		if p[11] <= 0 then
			del(particles, p)
		end
		
	end
	
	for p in all(text_particles) do
		p[2] -= 0.1 + ((max(p[3]) / total_life) ^ 2) * 0.7
		p[3] -= 1
		if p[3] + p[5] <= 0 then
			del(text_particles, p)
		end
	end
end


function new_particles(x, y, n, v)
	v = v or 1.5
	for i = 1,n do
		add(particles, {
			x+rnd(4)-2,y+rnd(4)-2,0, 
			rnd(v*2)-v,rnd(v*2)-v,1+rnd(0.5) * v/1.5, 
			x,y,x,y, 
			100+rnd(40)
		})
	end
end

function sparks_on_change(x, y, old, new)
	old = tostr(old)
	new = tostr(new)
	for i = 1, max(#old, #new) do
		if sub(old,i,i) ~= sub(new,i,i) then
			new_particles(x-(i-1)*7, y, 7, 0.8)
		end
	end
end

-- value can be a number or a sprite
function new_text_particle(x, y, val, extra_time)
	
	local ty = type(val)
	if ty == "number" then
		val, ty = get_spr(val), "userdata"
	end
	
	if ty == "userdata" then
		x -= val:width()\2
		y -= val:height()\2
		
		add(text_particles, {
			x, y, total_life,
			{{val, 0, 0, val:width(), val:height(), 0, 0}},
			extra_time or 20
		})
		
	elseif ty == "string" then -- only accepts number characters here
		local p = add(text_particles, {
			x - #val*4 - 4, y - 7, total_life,
			{},
			extra_time or 20
		})[4]
		
		-- + sign
		add(p,{
			283,
			0,0, 8,15,
			0,0
		})
			
		for i = 1,#val do
			local n = tonum(sub(val, i, i))
			add(p,{
				282,
				n*8,0, 8,15,
				i*8, 0
			})
		end
		
	end
end


-- colors to be used for the smoke
local exp_cols = {get_spr(15+256):get(0,0,13)}

-- generate extra puffs of smoke
local old_rand = rnd()
srand(2)-- set seed
local exp_pufs = {}
for i = 1,30 do
	local a = rnd()
	local am = rnd(60) + 20
	add(exp_pufs, {sin(a)*am, cos(a)*am * 0.7})
end
srand(old_rand*0xffffffff)

function draw_explosion(x, y, t)
	if(t < 0) return
	t *= 5
	local sp = userdata("u8", 41, 41)
	
	-- draw to the new sprite
	set_draw_target(sp)
	
	-- base circle
	local r = min((t^0.5)*15, 20)
	circfill(20, 20, r, 2)
	
	-- dithering color overlapping the upper color
	poke(0x8040, 0)
	fillp(0xf5f5)
	circfill(20, 30, r, 1)
	fillp(0xa5a5)
	circfill(20, 35, r, 1)
	fillp(0xa0a0)
	circfill(20, 35, r-6, 1)
	fillp()
	circfill(20, 35, r-12, 1)
	poke(0x8040, 1)
	
	-- clear inside circle
	local old = peek(0x550b)
	poke(0x550b, 0)
	circfill(20, 30, (t - 2)*10, 0)
	poke(0x550b, old)
	
	set_draw_target()
	
	-- prepare colors for the puffs
	local c = mid(t*4 - 2, 2, 13)\1
	pal(2, exp_cols[c])
	pal(1, exp_cols[c-1])
	
	local t2 = 1 + (t^0.6) * 0.7 - 0.8
	local y2 = (t^2) * 2
	
	-- extra puffs of smoke shoot out
	local r = 5-t
	for p in all(exp_pufs) do
		circfill(x + p[1]*t2+20, y + p[2]*t2+30 - y2*0.5, r, 2)
	end
	--circfill(x + 70*t2, y + 70*t2, 3, 2)

	-- main puffs of smoke
	spr(sp, x+5*t2, y - 20*t2 - y2*1.15)
	spr(sp, x - 20*t2, y - 15*t2 - y2*1.15)
	spr(sp, x + 20*t2, y - 10*t2 - y2*1.15)
	spr(sp, x, y - y2*1.3)
	spr(sp, x - 25*t2, y + 10*t2 - y2)
	spr(sp, x + 20*t2, y + 15*t2 - y2)
	spr(sp, x-5*t2, y + 20*t2 - y2)
	
	-- reset palette
	pal(2, 2)
	pal(1, 1)
end

function new_explode_particle(x, y)
	add(explode_particles, {x-20, y - 20, time()})
end


:: card_games/falling_cards/stack_rules.lua
--[[pod_format="raw",created="2024-06-28 02:31:21",modified="2024-07-21 13:23:51",revision=4154]]

-- if the cards are connected by rank or one is wild
-- r1 on top of r2
local function is_stackable_rank(r1, r2)
	return r1 == "wild" 
		or r2 == "wild" 
		or type(r1) == "number" and type(r2) == "number" and r1 - 1 == r2
end

-- for solitaire rules like decending ranks
function stack_can_rule(stack, stack2)
	-- empty stack can always have cards placed on it
	if #stack.cards == 0 then
		return true
	end
	
	-- get's the top card of stack and bottom/first card of stack2
	local c1 = stack.cards[#stack.cards].rank
	local c2 = stack2.cards[1].rank
	
	-- 1 rank below or wild, or placed card is bomb
	return is_stackable_rank(c1, c2) or c2 == "bomb" or c2 == "shuffle"
end


-- checks if the cards are decending in rank
function unstack_rule_decending(card)
	local s = card.stack.cards
	local i = has(s, card)
	
	-- goes through each card above clicked card to see if the rank decends
	-- assumes that the suit alternates
	for j = i+1, #s do
		local next_card = s[j]
		
		-- not decending by 1 or connected by wild
		if not is_stackable_rank(card.rank, next_card.rank) then
			return false
		end
	
		card = next_card -- current card becomes previous card
	end
	
	return true
end

-- wraps the resolve function
function wrap_stack_resolve(stack, check_effect)
	local old_resolve_stack = stack.resolve_stack
	
	stack.resolve_stack = function(s, held)
		local changed = s ~= held.old_stack
		
		old_resolve_stack(s, held)
		
		if changed then
			if check_effect then
				action_effect_check = s
			end
	
			action_count_up = true
		end
	end
end

-- checks if the card placement has changed

function can_stack_only_one(stack, held)
	return #stack.cards == 0 and #held.cards == 1
end


function count_cards()
	local cards = {0,0,0,0,0}
	-- cards.wild = 0
	-- cards.bomb = 0
	-- ...
	
	for s in all(stack_storage) do
		for c in all(s.cards) do
			local n = cards[c.rank]
			if n then
				cards[c.rank] += 1
			end
		end
	end
	
	for s in all(stacks_supply) do
		for c in all(s.cards) do
			local n = cards[c.rank]
			if n then
				cards[c.rank] += 1
			end
		end
	end
	return cards
end

function random_least(n)
	local counts = count_cards()
	local added = {}
	
	for _ = 1,n do
		-- finds the lowest current value
		local lowest = 999
		for i = 1,5 do
			lowest = min(lowest, counts[i])
		end
		
		-- if there's a card that doesn't exist, then require it to be added
		lowest += lowest == 0 and 1 or 2	
	
		-- accumulate cards below a threshold
		local lt2 = {}
		for i = 1,5 do
			if counts[i] < lowest then
				add(lt2, i)
			end
		end
		
		-- pick a random one
		local c = rnd(lt2)
		counts[c] += 1
		add(added, c)
	end
	
	return added
end

:: card_games/falling_cards/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTAxIDIxOjEwOjIxIixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyJdXQ==
:: card_games/golf_solitaire/
:: card_games/golf_solitaire/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTI0IDE4OjMwOjU5Iixtb2RpZmllZD0iMjAyNC0w
Ni0yNCAxOTo1MjoyNiIscmV2aXNpb249ODddXWx6NAB3BgAAvDgAAPFBe1swXT17Ym1wPXB4dQBD
IDFOBAP-Gx8DDvsfHvsAHiteCz4LTgtOCw4LHvsEXgteGx4LTgseCx4rDxp3HYseC35bHgsuCx4r
lx3bHnseCz4LAED7Bz4bJADxACc7JwsNJx0XHRsNNx07TikA4icdW0cLFx0bRx1rDgs_EQAwFwsX
EwBjF1saCTtOEwASDRMAYR07GQ8Za00AEQ1MAAIYAFE3HSsHqxQAJ0cLEwCkCDsYOx4rJxseJxYA
oBdrBxgPGAsYCwzDADErlwtsALAbHhcdLhsHGBwIWxQAEEdGAHAdHisHGxxLJgDwBQ13LScdRw0X
HQ47B3seCx77EwdrvADwBQ0XSwcLB6sNGw0rDRsHDRsNax4rBwDzAwcNCweLDQutCwcLPVseOw0H
CwIA0EvtDgYOKy07HisXDQsnABANFgDxMSsNC90OTQsNOx77BQ0L-QJbHvsHLQs9C10LDWse_wYO
_wge_wAOOw4bDhsOOw5LDgsOGw4rHssOCx4bDgsOCy4CABAOlQEBFgABCgCQC14LTgsuWx57EAAR
PhQAkC4LHgteCw5rHtQAQQsuCz4QABE_CAHwFA5LHlv_BAt_ux47Dhv_CQsOyx4LDhseC-4HCw7r
Hjv_CvsBbQAg-goPAAEhABAbCQBxHgv_CHsOiwkA8Q0FBjcGew5bHhv_BgZ3BhsOGx5bHgv_BgaX
Bl5bHwBwdwYHBgcGXqYAgAsOC-4DtxZ_fAAADABxAganFgcGbg8AgP4ElwYXJm4rCgBQtxYHBg5l
ApQb-gMHBkcGJ0YOAKAnBkcGFxYHBi4LWwKS-gQGNwY3Ro4bWgCDFkdGBwYOA24PAFAGByYHJnwA
QCMOA04uAFUCCy4GBwIAFjMWABIDEwAiJiM9ACD_ADUBMRMGDhEAABEBAAQBoAELPgMOAw4TDgNU
AQMVAPEAAwvuC04bHis_C-4UKx4ryQASEusAECtaAFILngsuS3oBET6KAQC_ARFeuAEQDicAQhsO
Sw7OARCLCABBHisuKxYA8i37AQ5bDvsDHvsADisO_wMOWx77Hw4DDjseA-8TDwMeOw4DBUEFAz77
CT4DBUEVAQXzGwUBFQEDBRNFEyUEAFBjDwUCIxQAUhUjBSNFBADwBTNOBBITNbMFowVjDgNeBA4j
NSMO1ABQcw8EAwACABBT4QCDXgQeEzUTDgMCABAzGgAUQBAAgxN_EzUDDgNODgAUYBgAglM_IzUT
LgYuDgARgwYAV0MAAwBzLgAKAgAiIwB0AFQjBSMlAUcADycABIIwEyUTARUBBScAArUABAIAc2NQ
EzUDBQEFAfMEBQH1HwEsZmxhZ3M9MCxwYW5feAgAx3k9MCx6b29tPTN9LOoEYTNCBPD-nosAQ-Ac
AwACAPQB8BojLxsjYAPwEhMOGx4TIBcAERAPACYAAwIAS-AOE04RACAjLrUA9RqDAAPwDAMAsx4b
DjPwDgMuAw4LDhMuCw4rDhMAA-ALExsOAw4rTksOAw4AEBvVAzUOSyMdADlbDhMbADADHis8ABIJ
HwBGLmMOCw8AAEYCF4MQACArHrkBKRMOIgABTQEiAENVACoeG7gAABUARmMAA0AOAAEvAMCAA-AN
ExsOExAD8BkIAC-wHAYAPqAj8BojCx5j8BRDxQDwIPARUwseIw8TU-APYy4DDQMNY-AOMw0DDQMO
A00DDTPwDUMtDgMObUPwDDM9I30zBwAwAw0DCQBCQw0DHQIA-wxD8AxjDQMtAw2D8A3zBfAQ8wHw
FMPwGyPw-6EdAh7xPP--aqPwFfMB8BFTHxsrHlPwDzMeSx4bHjPwDTMOux4z8Aszyz4z8AkzCw5L
HnseM-AHMwsO_wAuM-AGIw7LDisOGx4j8AUjDksOi8wFsAsOI-AEIw47Dus_CQBw_wROI-AEE_YD
ORs_EwoAIfsHBwBACx77AUIEEB4NAHEOmw5rDhtOCwAQS0AEUB4rHgsuDwCRHisOGw5bDjsuDwAR
I2IEYIsOGz4LLmcA8BMuax47jiPwBRNeKw47TgtOE-AGIy4bPis_G04j8AYzvgt_uQBQPhsuG37M
ACD_AdgAEO7kANDOM-APU25T8BLj8BeDDwEfnkMBGV8QEATw8DEACx84MQD-----------------
----------------------------------------------9WUG09OH19
:: card_games/golf_solitaire/game_info.lua
--[[pod_format="raw",created="2024-03-25 02:11:53",modified="2024-07-21 13:23:51",revision=376]]

function game_info()
	return {
		name = "Golf Solitaire",
		author = "Werxzy",
		description = "Return all cards to the goal stack. Neighboring ranks only.",
		rules = {
			"\tTo win, place all cards on the goal stack at the bottom, which starts empty",
			"\tCards can only be moved to the goal stack, The goal stack can have any card placed on it while empty.",
			"\tWhen cards occupy the goal stack, only cards 1 rank higher or lower can be placed on top.",
			"\tKings and Aces can be placed on top of each other on the goal stack.",
			"\tClick the supply stack on the left to replace the top card.",
			"\tIf you cannot place a card from anywhere onto the goal stack, you cannot win and must start a new game."
		},
		desc_score = {
			format = "Wins : %i",
			param = {"wins"}
		},
		api_version = 2,
		order = 3
	}
end

:: card_games/golf_solitaire/golf_solitaire.lua
--[[pod_format="raw",created="2024-03-21 00:44:11",modified="2024-07-21 13:23:51",revision=3295]]


include "suite_scripts/confetti.lua"
include "cards_api/card_gen.lua"

-- updates card size if it changed
card_width = 45
card_height = 60

rank_count = 13 -- adjustable


function game_setup()

	-- save data is based on lua file's name
	game_save = suite_load_save() or {
		wins = 0
	}	
	
	local card_gap = 4
	
	deck_stack = stack_new(
		{5,257},
		240-card_width-card_gap*2, 160,
		{
			reposition = stack_repose_static(-0.16),
			on_click = stack_on_click_reveal
		})
	
	local card_back = suite_card_back()
	
	local card_sprites = card_gen_standard({
		suits = 4, 
		ranks = rank_count
	})
	
	for suit = 1,4 do
		for rank = 1,rank_count do		
			card_new({
				sprite = card_sprites[suit][rank], 
				back_sprite = card_back,
				stack = deck_stack,
				a = 0.5,
				suit = suit,
				rank = rank,
			})
		end
	end
	
	stack_quick_shuffle(deck_stack)	
	
	stacks_supply = {}
	for i = 1,7 do
		add(stacks_supply, stack_new(
			5,	
			i*(card_width + card_gap*2) + card_gap, card_gap, 
			{
				reposition = stack_repose_normal(),
				on_click = stack_on_click_unstack(card_is_top),
				on_double = stack_on_double_goal
			}))
			
	end
	
	
	deck_goal = stack_new(
		{5,258},
		240+card_gap*2, 160,
		{
			reposition = stack_repose_static(-0.16),
			can_stack = stack_can_goal
		})
			
	suite_menuitem_init()
	suite_menuitem({
		text = "New Game",
		colors = {12, 16, 1}, 
		on_click = function()
			cards_api_coroutine_add(game_reset_anim)
		end
	})
	
	suite_menuitem_rules()
	
	wins_button = suite_menuitem({
		text = "Wins", 
		value = "0000"
	})
	wins_button.update_val = function(b)
		local s = "\fc"..tostr(game_save.wins)
		while(#s < 6) s = "0".. s
		b:set_value(s)
	end	
	wins_button:update_val()	
	
	cards_api_coroutine_add(game_setup_anim)
	card_position_reset_all()
end

-- deals the cards out
function game_setup_anim()
	pause_frames(30)
	
	for i = 1,5 do	
		for s in all(stacks_supply) do
		
			local c = get_top_card(deck_stack)
			if(not c) break
			stack_add_card(s, c)
			c.a_to = 0
			pause_frames(3)
		end
		pause_frames(5)
	end
	
	cards_api_game_started()
end

-- places all the cards back onto the main deck
function game_reset_anim()
	stack_collecting_anim(deck_stack, stacks_supply, deck_goal)
	pause_frames(35)
	stack_standard_shuffle_anim(deck_stack)

	game_setup_anim()
end

function game_win_anim()
	confetti_new(130,135, 100, 10)
	pause_frames(25)
	confetti_new(350,135, 100, 10)
end

function game_win_condition()
	local cards_all = get_all_cards()
	return #deck_goal.cards == #cards_all
end

function game_count_win()
	game_save.wins += 1
	wins_button:update_val()
	suite_store_save(game_save)
	cards_api_coroutine_add(game_win_anim)
end


function stack_on_click_reveal()
	local s = deck_stack.cards
	
	if #s > 0 then
		local c = s[#s]
		stack_add_card(deck_goal, c)
		c.a_to = 0
	end
end

-- accepts any card if nothing is in the stack.
-- otherwise requires a single card of 1 rank higher or lower than the top of the stack.
function stack_can_goal(stack, stack2)
	if #stack.cards == 0 then -- any card
		return true
	end
	
	local c1 = stack.cards[#stack.cards]
	local c2 = stack2.cards[1] 
	
	local dif = (c1.rank - c2.rank) % rank_count
	
	return dif == 1 or dif == rank_count - 1
end

-- attempt to stack the top card onto the goal stack
function stack_on_double_goal(card)
	-- only accept top card (though could work with multiple cards
	if card and card_is_top(card) then 
		local old_stack = card.stack
		-- create a temporary stack
		local temp_stack = unstack_cards(card)
		
		-- attempt to place on each of the goal stacks
		if deck_goal:can_stack(temp_stack) then
			stack_cards(deck_goal, temp_stack)
		else
			stack_cards(old_stack, temp_stack)
		end
	end
end

function game_draw(layer)
	if layer == 0 then
		cls(3)
			
	elseif layer == 2 then
		confetti_draw()
	end
end

function game_update()
	confetti_update()
end

:: card_games/golf_solitaire/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Il1d
:: card_games/louie_chapman/
:: card_games/louie_chapman/huntsman_solitaire/
:: card_games/louie_chapman/huntsman_solitaire/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTI0IDE5OjUyOjAxIixtb2RpZmllZD0iMjAyNC0w
Ni0yNCAxOTo1MjowNyIscmV2aXNpb249M11dbHo0AK8EAAAmNwAA8RZ7WzBdPXtibXA9cHh1AEMg
MU4EDx32Hw4G9x8WBw8QDAcMDQcNBgDzBy0MBz0HDB0XDQwXDA0XLRctDBcWBx0CAPYAPQw9DD0H
HRcdB00HPQwHGQASTQQAUBwdBx0MCgAGGgAEAgBDDQwHXQsAHh0fAB83HAAHUz0XHQwtDAAAHgAA
awAEAgAAjQBPBwwdBx4AAjMnDB2rAA9XAAA-NwwNHQAGYQ0MNw8cDB8AAM4ADiEAQgwLRwsfABgH
HwAhPQxEAX0LBwsnDDccHwDBDB0MCwcbZwsNC2cLawEWHR0A9wAXDBtXDAsnDA0MJwsMVwsbAEAN
DFcLOgBSJwwtDCcKAAQ_ABEWiwDzATcMLQwbJwxNDCcbPQw3CwwZAEALJww9HQAQbRQAQT0MJwsY
AABgAGAtDAtXDI1XABAtcgDwBAcWBwwLFwwdDHcMrQx3DB0MFwvaAQATAADIAHAMzQw3DCcLFwDw
MAcWJwwdCxcMRwztDEcMFwsdDCcWFwsdC0cNFwxNFw8XDQoXTQwXDUcLHQsXFgcLHQw3DTd9Bw0H
fTcNNwwdC2kA8gAdJwwnDQcMHQoHHQoHCg0EAIAtDAcNJwwnHXcAogwNDAcLJw0nPQecAVE9Jw0n
CxYAQRYHHQs_ALE9Bx0KFw0XCh0HPTgAEQvxAAF2AWAnPQetBz0UABIHFgAjNwtvAGAKjQoHCh1p
ACELNxoAsVcLN30MDQx9NwtXEADRdwsXC20MDQxtCxcLdxIA0bcLHC0MCw0LDC0cC7cSAFL3Ay33
AwoAYgIMLQz3AgwAYQAMbQz3AAwAUscMzQzHFgARGQcAYUcM-Q0MRwsAUjcM-Q8MfQB0Nx0M9wsM
HQ0AUBcdDAcM-QEiBw0CAAB8AyYMFyAAARUAECcGACEtJyUAGTc8AEANJw0MHwAFQAAEOwBxDCcd
Fw0nLRUABl8AAVwAAB4D8AEWBwwtDAsd9w0dCwwtDAcWBgLACx0XDw4XDB0HLQcdBANgDB0XCRcd
eQKCFxZnHQcJCAlvACYHDU4AARYAQB1nFmcsACIMHRkAANABIB0MPQAAGQAB8AAwZxZnBAEwZxZ3
FgHgdxb3HxZHLPcPDA0MRxbHAvAOdwkICWcZBxlXDC0MNxYnHC0cVwkoCUcJGAkYCTfiAiAWF9AC
cwlICTdoN20OABFoEAABDgAxLQwtHgAQRzYAMAwdDKEC2UcMDQx3CSgJZwkICXdqADGHCXdoAPEi
9x8W9x8GDgY3Fg7-DQ8OFjcGDgVPEgUONvcJNg4FRBUEBf4bBQQVBN4BDhEOAQ4BDQMA8wsODQHe
BBUEHgWU-gOUBR41DgWkDg0BBAEEEQQA8wMBDQ6kBQ41DhQFngEPBQ4DDhMEAFADAZ4FFBkAaR5F
JA4BAxoATw4kRR4cAA5PBZ4BA1AAAC0FpDIAQKQFDiWjAA0ZAIuUBR4EFQQFzrIAM84FBO8A8wQF
BPUfBCxmbGFncz0wLHBhbl94CADHeT0wLHpvb209OH0sUgZfEBAE8PAxAP------------------
---------------------------------------------9dQbT04fX0=
:: card_games/louie_chapman/huntsman_solitaire/game_info.lua
--[[pod_format="raw",created="2024-03-25 02:12:03",modified="2024-07-21 13:23:51",revision=1558]]

function game_info()
	return {
		name = "Huntsman Solitaire",
		author = "Louie Chapman",
		description = "Hunt down the four matching ranked cards to win!",
		rules = {
			"\tCards are stacked with either decreasing or matching values. However, a stack can only be moved when following either rule, and not both.",
			"\tAces can be placed on any card, and any card can be placed on Aces.",
			"\tWhen clicked, the draw pile on the right will deal a card to every column.",
			"\tThe reserve deck on the left contains cards that can be played onto any valid position, but cards can not be played onto the reserve deck.",
			"\tCards can be stacked on both the draw deck, and/or reserve deck, when they have no cards remaining.",
			"\tTo win, match four-of-a-kind on each of the cards on the top of the tableau.",
			},
		desc_score = {
			format = "Wins : %i",
			param = {"wins"}
		},
		api_version = 2,
		order = 4
	}
end

:: card_games/louie_chapman/huntsman_solitaire/huntsman_solitaire.lua
--[[pod_format="raw",created="2024-03-22 19:08:40",modified="2024-07-21 13:23:51",revision=3917]]

include "suite_scripts/confetti.lua"
include "cards_api/card_gen.lua"

-- updates card size if it changed
card_width = 45
card_height = 60

tableau_width = 4
tableau_initial_deal = 5

reserve_initial_deal = 8

foundation_targets = 4

all_suit_colors = {
	{1, 1,16,12},
	{8, 24,8,14},
	{1, 1,16,12},
	{8, 24,8,14}
}

rank_count = 13 -- adjustable

function game_setup()

	-- save data is based on lua file's name
	game_save = suite_load_save() or {
		wins = 0
	}	
	
	local card_gap = 4
	local x_offset = 70
	
	-- draw pile
	deck_stack = stack_new(
		{5},
		x_offset+(5)*(card_width + card_gap*2)+10, card_height - 30,
		{
			reposition = stack_repose_deck,
			can_stack = stack_can_on_deck, 
			on_click = stack_on_click_reveal
		})
	
	local card_back = suite_card_back()
	
	local card_sprites = card_gen_standard({
		suits = 4, 
		ranks = rank_count,
		suit_colors = all_suit_colors
	})

	for suit = 1,4 do
		for rank = 1,rank_count do		
			card_new({
				sprite = card_sprites[suit][rank], 
				back_sprite = card_back,
				stack = deck_stack,
				a = 0.5,
				suit = suit,
				rank = rank,
			})
		end
	end
	
	stack_quick_shuffle(deck_stack)	
	
	
	stacks_supply = {}
	for i = 1,tableau_width do
		add(stacks_supply, stack_new(
			{5},
			i*(card_width + card_gap*2) + card_gap + x_offset, card_gap + card_height + 10, 
			{
				reposition = stack_repose_normal(nil,nil,160),
				can_stack = stack_can_rule,
				on_click = stack_on_click_unstack(unstack_rule_decending, unstack_rule_face_up),
				on_double = stack_on_double_goal}
			))
	end
	
	-- foundation piles
	stack_goals = {}
	for i = 0,3 do
		add(stack_goals, stack_new(
			5,
			(i+1)*(card_width + card_gap*2) + card_gap + x_offset, 5,
			{
				reposition = stack_repose_foundations,
				can_stack = stack_can_goal
			}))
	end
	
	-- reserve pile
	deck_reserve = stack_new(
		{5},
		x_offset-card_gap, card_height - 30,
		{
			reposition = stack_repose_reserve,
			can_stack = stack_can_on_deck, 
			on_click = stack_on_click_reserve, 
			on_double = stack_on_double_goal
		})
	

	suite_menuitem_init()
	suite_menuitem({
		text = "New Game",
		colors = {12, 16, 1}, 
		on_click = function()
			cards_api_coroutine_add(game_reset_anim)
		end
	})
	
	suite_menuitem_rules()
	
	wins_button = suite_menuitem({
		text = "Wins", 
		value = "0000"
	})
	wins_button.update_val = function(b)
		local s = "\fc"..tostr(game_save.wins)
		while(#s < 6) s = "0".. s
		b:set_value(s)
	end	
	wins_button:update_val()

	cards_api_coroutine_add(game_setup_anim)
	card_position_reset_all()
end

-- checks each foundation pile for a unique rank
-- also you can't have aces
function is_unique_rank(c)
	if c.rank==1 then return false end

	for s in all(stack_goals) do
		local c1 = s.cards[1]
		
		if c1 and c1~=c then 
			if c1.rank==c.rank then 
				return false
			end
		end
	end
	
	return true
end

-- deals the cards out
function game_setup_anim()
	deck_reserve.has_been_emptied = false
	deck_stack.has_been_emptied = false
	
	is_setting_up = true

	-- deal out goal cards
	pause_frames(30)
	local i=1
	while i<=4 do
		local s=stack_goals[i]
		local c=get_top_card(deck_stack)
		
		stack_add_card(s, c)
		c.a_to = 0
		pause_frames(20)
		
		if is_unique_rank(c) then 
			i+=1
		else
			pause_frames(20)
			
			stack_add_card(deck_stack, c, rnd(#deck_stack.cards+1)\1+1)
			c.a_to = 0.5
			
			for c in all(deck_stack.cards) do 
				card_to_top(c)
			end	
		
			pause_frames(30)
		end
	end
	
	-- deal out reserve
	for i=1,reserve_initial_deal do
		local c = get_top_card(deck_stack)
		stack_add_card(deck_reserve, c)
		c.a_to =i==reserve_initial_deal and 0 or 0.5 
		pause_frames(5)
	end

	-- deal out tableau
	pause_frames(20)
	for i = 1,tableau_initial_deal do	
		for s in all(stacks_supply) do
			local c = get_top_card(deck_stack)
			stack_add_card(s, c)
			c.a_to =i==tableau_initial_deal and 0 or 0.5 
			pause_frames(3)
		end
		pause_frames(5)
	end
	
	is_setting_up = false

	cards_api_game_started()
end

-- places all the cards back onto the main deck
function game_reset_anim()	
	for c in all(deck_stack.cards) do 
		c.a_to = 0.5
	end
	
	deck_stack.has_been_emptied = false
	
	stack_collecting_anim(deck_stack, stacks_supply, stack_goals, deck_reserve)
	pause_frames(35)
	stack_standard_shuffle_anim(deck_stack)
	
	game_setup_anim()
end

function game_action_resolved()
	if not get_held_stack() then
		for s in all(stacks_supply) do
			local c = get_top_card(s)
			if(c) c.a_to = 0
		end
		
		local top = deck_reserve.cards[#deck_reserve.cards]
		if not is_setting_up and top and top.a_to~=0 then 
			top.a_to=0
		end
		
		for s in all(stack_goals) do 
			if #s.cards>=4 then
				for c in all(s.cards) do 
					c.a_to=0.5
				end
			end
		end
		
		if #deck_reserve.cards==0 then 
			deck_reserve.has_been_emptied = true
		end
		
		-- set the deck to be fully empty
		if #deck_stack.cards==0 then 
			deck_stack.has_been_emptied=true
		end	
	end
end

function game_win_anim()
	confetti_new(130,135, 100, 10)
	pause_frames(25)
	confetti_new(350,135, 100, 10)
end

function game_win_condition()
	for g in all(stack_goals) do
		if #g.cards~=4 then return false end
	end
	return true
end

function game_count_win()
	game_save.wins += 1
	wins_button:update_val()
	suite_store_save(game_save)
	cards_api_coroutine_add(game_win_anim)
end

function stack_repose_deck(stack)
	if stack.has_been_emptied then 
		stack_repose_normal()(stack)
	else
		stack_repose_static(-0.16)(stack)
	end
end

function stack_repose_reserve(stack)
	if stack.has_been_emptied then 
		stack_repose_normal()(stack)
	else
		stack_repose_normal(3)(stack)
	end
end

-- reposition calculation that has fixed positions
function stack_repose_foundations(stack)
	local y = stack.y_to
	for i, c in pairs(stack.cards) do
		c.x_to = stack.x_to
		c.y_to = y
		
		-- if the stack is full then only have one pile
		y += #stack.cards>=4 and 0 or 2
	end
end

-- determines if stack2 can be placed on stack
-- for solitaire rules like decending ranks and alternating suits
function stack_can_rule(stack, stack2)
	if #stack.cards == 0 then
		return true
	end
	
	local c1 = stack.cards[#stack.cards]
	local c2 = stack2.cards[1]
	
	-- if the suits are alternating AND the rank is one below
	if c1.rank - 1 == c2.rank then -- alternating suits (b,r,b,r) (0,1,2,3)
		return true
	end
	
	-- if both ranks are the same then allow placement
	-- or if either are an ace
	if c1.rank == c2.rank or c1.rank==1 or c2.rank==1 then return true end
end

-- goal stacks
-- in this case , just looking for four of a kind
function stack_can_goal(stack, stack2)
	if #stack2.cards ~= 1 then
		return false
	end
	
	local c1 = stack.cards[#stack.cards]
	local c2 = stack2.cards[1] 
	
	if c1.rank==c2.rank then
		return true
	end
end

-- the animation for drawing cards <3
function deck_draw_anim()
	local s = deck_stack.cards

	for i=1,#stacks_supply do
		if #s > 0 then
			-- normal viewing
			local c = s[#s]
			stack_add_card(stacks_supply[i], c)
			c.a_to = 0

			pause_frames(3)
		end
	end
end

function stack_can_on_deck(stack, stack2)
	if stack.has_been_emptied then 
		return stack_can_rule(stack,stack2)
	end
	
	return false
end

-- when the reserve pile is clicked
function stack_on_click_reserve(card)
	if deck_reserve.has_been_emptied then 
		stack_on_click_unstack(unstack_rule_decending)(card)
	else
		stack_on_click_unstack(card_is_top)(card)
	end
end

-- when the draw pile is clicked
function stack_on_click_reveal(card)
	if deck_stack.has_been_emptied then
		stack_on_click_unstack(unstack_rule_decending)(card)
	else
		cards_api_coroutine_add(deck_draw_anim)
   end
end


function stack_on_double_goal(card)
	-- only accept top card (though could work with multiple cards
	if card and card_is_top(card) then 
		local old_stack = card.stack
		-- create a temporary stack
		local temp_stack = unstack_cards(card)
		
		-- attempt to place on each of the goal stacks
		for g in all(stack_goals) do
			if g:can_stack(temp_stack) then
				stack_cards(g, temp_stack)
				temp_stack = nil
				break
			end
		end
			
		-- if temp stack still exists, then return card to original stack
		if temp_stack then
			stack_cards(old_stack, temp_stack)
		end
	end
end

function unstack_rule_decending(card)
	local s = card.stack.cards
	local i = has(s, card)
	
	-- if the card is an ace , see if it could move the cards beneath it
	if card.rank==1 and i~=#s then  return unstack_rule_decending(s[i+1]) end
	
	-- first check if the card is a pair, triple, or four of a kind
	local n_of_kind = 0
	
	-- goes through each card above clicked card to see if it fits the rule
	for j = i+1, #s do
		local next_card = s[j]	
		
		if n_of_kind>=0 and card.rank==next_card.rank then 
			n_of_kind+=1
		else
			-- if there's already been more than 1 matching card
			-- then you can't have a straight
			if n_of_kind>0 then return false end
			
			-- otherwise set it to -1
			n_of_kind = -1
		end
	
		if n_of_kind==-1 then
			if next_card.rank+1 ~= card.rank then
				return false
			end
		end
		card = next_card -- current card becomes previous card
	end
	
	return true
end

function game_draw(layer)
	if layer == 0 then
		cls(3)
			
	elseif layer == 2 then
		confetti_draw()
	end
end

function game_update()
	confetti_update()
end

:: card_games/louie_chapman/huntsman_solitaire/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Il1d
:: card_games/louie_chapman/trapdoor_solitaire/
:: card_games/louie_chapman/trapdoor_solitaire/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTI0IDE5OjUyOjIzIixtb2RpZmllZD0iMjAyNC0w
Ni0yNCAxOTo1MjoyNiIscmV2aXNpb249Ml1dbHo0ADEDAADCOAAA8CZ7WzBdPXtibXA9cHh1AEMg
MU4EDx32Hw4G9x8W9x8WJw8O_BcNJxYXDfgZDRcWFxgN9xUNGAkAPxcNBwIADhEXKgBPBw0HCAIA
DiINB1YARAj3EQg3AGUnCPcACNcaAPECBygHGA0XGAcYDQcNGAcNCA0EADcYDQcxAD8XCAcCAAYV
F0oAtRcNFwgnDRgHKAcoSAA2CCcIrwBCtwj3BC4AGh1SAD0nCAcCAAE3AD8dBw0CABLwBRgXFvcb
HRcWFw0oDWcIDUcIDfcEDwDwExiXGEcYFw0IBwgN9wEWFxg3DSgNBxgHGAc4B0gHGAcNGA0yAAI4
APAABxgdCAcYNw0YDQdINxgHBQGABw0IFxZHGAcnAQASACEXGCkAIQgNEgASSBwAADYAcQcYFxgn
DQhIATI3GEdQAAMrAIEIDRcIDTcNJwsAAIEAEBcDAi4XHesBADYABhYALxcdAQEGRhg3DQcCABMd
OQIL_wE1FzgNFQAPNAIHAg8BGA0QAA9PAAQA5QAPUAARAfsAD1AADx_HTAASALoBD04AET8XSBdQ
ABEfSEwAEgKHAQ9OAA42Fw0IKAAPUAAIPzcNN04AEB9nmgA4ASECD04ADy8YR9ABOABoAw9OAA8-
NxgH6AA4DzQBEwBEAg9OABEPCgM-Hzg5ATgvDQhNAAVPDxoIB1cDDD8sCAfRARBCHA8bHBUAD1ID
BYMNHAsDCxwNBwIAAc4BBgIAA0kAUiwDCxMcyAQ3Fw040QQBIADRDRcMCxwDHAMMtxjHGHoFYwwL
AwtMeJgAUbgNFxYnQwCzLIgNZw2oDScWJxwxAAXIBfhAHAsMC0zHSPcBBg4GBwsfEwsDCyr-DQwO
FjcGDgkfEjMKAyb3CTYOCUUZBQkOChsDCwr_FAkFGQUuAysD-hUFGQU_AwsD-hY5TgP_Fzn_HQMA
tCkF-h0FGQUJ-hsJBwDzBAkF_R8FLGZsYWdzPTAscGFuX3gIAMd5PTAsem9vbT04fSzuB18QEATw
8DEA----------------------------------------------------------------11BtPTh9
fQ==
:: card_games/louie_chapman/trapdoor_solitaire/game_info.lua
--[[pod_format="raw",created="2024-03-25 02:14:11",modified="2024-07-21 13:23:51",revision=154]]

function game_info()
	return {
		name = "Trapdoor Solitaire",
		author = "Louie Chapman",
		description = "A spider solitaire variant with Aces acting as wild, but a more restrictive tableau",
		rules = {
			"\tCards can only be stacked in descending values with matching suits",
			"\tWithin a suit, Aces can be placed on any card, and any card can be placed on an Ace. (1 does not count as an Ace)",
			"\tWhen part of a larger stack, Aces are counted as if they were not there, and Stacks can be moved even with Aces within them.",
			"\tTo win, create an ordered stack for each of the 4 suits ranging from 9 to 1",
		},
		desc_score = {
			format = "Wins : %i",
			param = {"wins"}
		},
		api_version = 2
	}
end

:: card_games/louie_chapman/trapdoor_solitaire/trapdoor_solitaire.lua
--[[pod_format="raw",created="2024-03-17 19:21:13",modified="2024-07-21 13:23:51",revision=3739]]


include "suite_scripts/confetti.lua"
include "cards_api/card_gen.lua"

-- updates card size if it changed
card_width = 45
card_height = 60

available_suits = 4
available_decks = 1

available_rows = 6

all_ranks = {
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"",
	"",
	"",
}

all_face_sprites = {
	[10] = {67,68,69,70,71}
}


function game_setup()
	
	game_save = suite_load_save() or {
		wins = 0
	}	
	
	local card_gap = 4
	
	deck_stack = stack_new(
		{5},
		card_gap+10, card_gap + 10,
		{
			reposition = stack_repose_static(-0.16),
			can_stack = stack_can_on_deck,
			on_click = stack_on_click_reveal
		})
		
	local card_back = suite_card_back()
	
	local card_sprites = card_gen_standard({
		suits = 4,
		ranks = 10,
		rank_chars = all_ranks,
		face_sprites = all_face_sprites
	})
	
	for suit = 1,available_suits do
		for rank = 1,#all_ranks do		
			card_new({
				sprite = card_sprites[suit][min(rank, 10)], 
				back_sprite = card_back,
				x = 240,
				y = 100,
				stack = deck_stack,
				a = 0.5,
				suit = suit,
				rank = rank,
			})
		end
	end
	
	stack_quick_shuffle(deck_stack)		
	
	stacks_supply = {}
	for i = 1,available_rows do
		add(stacks_supply, stack_new(
			{5},
			i*(card_width + card_gap*2) + card_gap + 40, card_gap + 10, 
			{
				reposition = stack_repose_normal(),
				can_stack = stack_can_rule, 
				on_click = stack_on_click_unstack(unstack_rule_decending)
			}))	
	end
		
	suite_menuitem_init()
	suite_menuitem({
		text = "New Game",
		colors = {12, 16, 1}, 
		on_click = function()
			cards_api_coroutine_add(game_reset_anim)
		end
	})
	
	suite_menuitem_rules()
	
	wins_button = suite_menuitem({
		text = "Wins", 
		value = "0000"
	})
	wins_button.update_val = function(b)
		local s = "\fc"..tostr(game_save.wins)
		while(#s < 6) s = "0".. s
		b:set_value(s)
	end	
	wins_button:update_val()

	cards_api_coroutine_add(game_setup_anim)
	card_position_reset_all()
end

-- deals the cards out
function game_setup_anim()
	pause_frames(30)
	for i = 1,5 do	
		for s in all(stacks_supply) do
			local c = get_top_card(deck_stack)
			stack_add_card(s, c)
			c.a_to = 0
			pause_frames(3)
		end
		pause_frames(5)
	end

	cards_api_game_started()
end

-- places all the cards back onto the main deck
function game_reset_anim()
	for c in all(deck_stack.cards) do
		c.a_to = 0.5
	end
	stack_collecting_anim(deck_stack, stacks_supply)
	pause_frames(35)
	stack_standard_shuffle_anim(deck_stack)
	
	game_setup_anim()
end

function stack_can_on_deck(stack, stack2)
	if #stack.cards>=1 then 
		return false
	end

	if #stack2.cards>1 then 
		return false
	end

	return true
end

-- determines if stack2 can be placed on stack
-- for solitaire rules like decending ranks and alternating suits
function stack_can_rule(stack, stack2)
	if s == get_held_stack() then
		return false
	end
	if #stack.cards == 0 then
		return true
	end
	
	local c1 = stack.cards[#stack.cards]
	local c2 = stack2.cards[1]
	
	if c1.suit == c2.suit then
		if c1.rank - 1 == c2.rank or c1.rank>9 or c2.rank>9 then
			return true
		end
	end	
end

-- expects to be stacked from ace to king with the same suit
function stack_can_goal(stack, stack2)
	if stack == get_held_stack() then
		return false
	end

	if #stack2.cards ~= 1 then
		return false
	end
	
	local c1 = stack.cards[#stack.cards]
	local c2 = stack2.cards[1] 
	
	if #stack.cards ~= 0 and c2.rank == 1 then
		return true
	end
	
	
	if #stack.cards > 0 and c1.suit == c2.suit then
		if c1.rank + 1 == c2.rank then
			return true
		end
	end		
end

function stack_on_click_reveal(card)
	if #deck_stack.cards>1 then
		cards_api_coroutine_add(deck_draw_anim)
	elseif card then
		set_held_stack(unstack_cards(card))
	end
end

function deck_draw_anim()
	local s = deck_stack.cards

	for i=1,#stacks_supply do
		if #s > 0 then
			local c = s[#s]
			stack_add_card(stacks_supply[i], c)
			c.a_to = 0

			pause_frames(3)
		end
	end
end

function unstack_rule_decending(card)
	local s = card.stack.cards
	local i = has(s, card)
	
	local current_rank = card.rank

	-- goes through each card above clicked card to see if it fits the rule
	for j = i+1, #s do
		local next_card = s[j]
		
		-- either rank matches, not decending by 1
		if next_card.suit ~= card.suit then 
			return false
		end	
	
		if next_card.rank<=9 then
			if next_card.rank+1 ~= current_rank and current_rank<=9 then
				return false
			end
		else
			
		end
	
		card = next_card -- current card becomes previous card
		
		if next_card.rank<=9 then
			current_rank = card.rank
		end
	end
	
	return true
end

function game_draw(layer)
	if layer == 0 then
		cls(3)
	elseif layer == 2 then
		confetti_draw()
	end
end

function game_update()
	confetti_update()
end




-- winning things
function game_win_anim()
	confetti_new(130,135, 100, 10)
	pause_frames(25)
	confetti_new(350,135, 100, 10)
end

function game_win_condition()
	local stack_count = 0

	for stack in all(stacks_supply) do
		local i, len = 1, #stack.cards
		while i <= len do
			local card = stack.cards[i]
			i += 1 -- prepare next card

			-- for every 9 found
			if card.rank == 9 then
				local suit = card.suit
				local r = 8 -- start by searching for 8
				
				while i <= len -- haven't reached end of stack
				and (stack.cards[i].rank == r -- card has expected rank
					or stack.cards[i].rank > 9) -- or an Ace
				and stack.cards[i].suit == suit -- card has same suit
				and r > 0 do -- haven't haven't checked rank 1 yet
				
					if stack.cards[i].rank <= 9 then
						r -= 1 -- 1 rank lower, ignore Aces
					end
					i += 1 -- next card
				end
				
				-- failed to find all the ranks
				if(r > 0) return false
				
				-- increase found count
				stack_count += 1
			end
		end
	end
	
	-- if count is at (or somehow above) the expected value
	return stack_count >= available_suits * available_decks
end

function game_count_win()
	game_save.wins += 1
	wins_button:update_val()
	suite_store_save(game_save)
	cards_api_coroutine_add(game_win_anim)
end

:: card_games/louie_chapman/trapdoor_solitaire/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Il1d
:: card_games/louie_chapman/LICENSE.txt
MIT License

Copyright (c) 2024 LouieChapm

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

:: card_games/louie_chapman/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTEwIDA3OjUxOjQwIixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyJdXQ==
:: card_games/solitaire_normal/
:: card_games/solitaire_normal/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTI0IDE5OjUyOjQ3Iixtb2RpZmllZD0iMjAyNC0w
Ni0yNCAxOTo1Mjo1MCIscmV2aXNpb249Ml1dbHo0AIQDAACwNgAA8CJ7WzBdPXtibXA9cHh1AEMg
MU4EDx32Hw4G9x8W9x8WFw8O_BkNFxYX_BsXFhcY9xcYBwB-Bw8XBw0HCAIABnENBwwHGA0HLABC
9xMNGAoAZAcIDScMBwIAEw0CABQMAgAzJw0IKABCGA33EwoATw0YBwxqAA8GmgABpgARDbIAA8AA
8QMNKA1nCA1HCA33CBYXGJcYRxgJALA3DSgNBxgHGAc4J6kAQAcNGA0rABEXMQBwBxgdCAcYNxQA
QBgNCDe5AAAjAEAIFxZHywAgCAcSAEEXGBcYmgARDRMAEkgdAAA5ACQHGBwAYhgHGDcYR1QAAAQA
EAgDAGIXCA0XDTgMAACHAAarAA9qAQEvDTgAAQYzDQc4ZAFzBygN9w0NKA0AEzheAQ4wAAAuARM4
JgCFCA0YDfcLDRh2AUIIFw0IigEpBw0CAAIUAAC5AAIqAGInDPcPDCc1AOMNJwx3DSgNDA0oDXcM
J48AoScNNwwHDBcMGA0CAHMMFwwHDDcNMgCxCCcMFw0MDRcNCAwUATEMCA0QACQMJ18AlQg3DA0M
Fw0IDQQAVQwNDDcIQABQDScMJwywAYYXDRgMJwwnDToAl5cNGA0nDRgNly4AQIcNGA3gAReHKAAR
V3ACAJ4AAJICFlcuADAMNyyUATY3LDeQALYNZwxXDQgNVwxnDfYANscNx-AABxEBD0YBFg6BAQ_4
ARMJ6wEPHgISDxsDBQCjAjCHCPcsAAAhAAE3AABUAEIHDScYpgIRCI0DAIYDjggNJxYXKAcIAgAi
Fwg6AAMOAAAmAzAXCCdUAAE4ACIHCGAAAg4AgCcoBxgNFxbXeADxJwYWxwgNdwgN9wYW9x8GDgY3
Fg7-DQ8OFjcGDgtPEgsONvcJNg4LShsKC-4bCwobCg4aCwoLGgIAkAoLCg4L8gcLDhcAURELAQsR
AgCLAQsBDvIJDjsTAG4SC-4DCxIXACMOCwIAMwoOCgoALwsOKAABICsOcQAxAgoCCAAfKyQABF8q
DiIOKh4AA88eCy4KLgIuCi4LHhKfAAUfK8oAAE0KGwoL9gAjGwoTAfMECwr7HwosZmxhZ3M9MCxw
YW5feAgAx3k9MCx6b29tPTh9LNwFXxAQBPDwMQD-------------------------------------
---------------------------XUG09OH19
:: card_games/solitaire_normal/game_info.lua
--[[pod_format="raw",created="2024-03-25 02:12:03",modified="2024-07-21 13:23:51",revision=225]]

function game_info()
	return {
		name = "Solitaire",
		author = "Werxzy",
		description = "The game you know and love/hate.",
		rules = {
			"\tStack cards of the same suit, from Ace to King, in the card slots on the right",
			"\tCards can be stacked in the 7 middle slots if alternate between red and black suits (hearts/diamonds and spades/clubs) and are 1 rank lower than the card below.",
			"\tAce is rank 1. Jack, Queen, King are rank 11, 12, 13.",
			"\tClick the deck to draw a reveal the next 3 cards. You can play the top revealed card, but can't stack on top of it.",
			"\tWhen the deck is out of cards, click the refresh button in the top left to move all the revealed cards back.",
			"\tIf you believe you have reached a state in which you cannot progress further, you will have to start a new game."
		},
		desc_score = {
			format = "Wins : %i",
			param = {"wins"}
		},
		api_version = 2,
		order = 1
	}
end

:: card_games/solitaire_normal/solitaire_normal.lua
--[[pod_format="raw",created="2024-03-22 19:08:40",modified="2024-07-21 13:23:51",revision=3142]]

include "suite_scripts/confetti.lua"
include "cards_api/card_gen.lua"

-- updates card size if it changed
card_width = 45
card_height = 60

all_suit_colors = {
	{1, 1,16,12},
	{8, 24,8,14},
	{21, 21,18,13},
	{25, 4,25,9}
}

-- alternate color settings that have spades/clubs and hearts/diamonds match
all_suit_colors_matching = {
	{1, 1,16,12},
	{8, 24,8,14},
	{1, 1,16,12},
	{8, 24,8,14}
}

function get_card_sprite()
	return card_gen_standard({
		suits = 4, 
		ranks = rank_count, 
		suit_colors = game_save.suit_colors and all_suit_colors_matching or all_suit_colors
	})
end

rank_count = 13 -- adjustable

function game_setup()

	-- save data is based on lua file's name
	game_save = suite_load_save() or {
		wins = 0, suit_colors = false
	}	
		
	local card_gap = 4
	
	deck_stack = stack_new(
		{5,6},
		card_gap, card_gap,
		{
			reposition = stack_repose_static(-0.16),
			on_click = stack_on_click_reveal
		})
		
	local card_back = suite_card_back()
	local card_sprites = get_card_sprite()
	
	for suit = 1,4 do
		for rank = 1,rank_count do		
			card_new({
				sprite = card_sprites[suit][rank], 
				back_sprite = card_back,
				stack = deck_stack,
				a = 0.5,
				suit = suit,
				rank = rank
			})
		end
	end
	
	stack_quick_shuffle(deck_stack)	
	
	stacks_supply = {}
	for i = 1,7 do
		add(stacks_supply, stack_new(
			{5},
			i*(card_width + card_gap*2) + card_gap, card_gap, 
			{
				reposition = stack_repose_normal(),
				can_stack = stack_can_rule, 
				on_click = stack_on_click_unstack(unstack_rule_decending, unstack_rule_face_up), 
				on_double = stack_on_double_goal
			}))
			
	end
	
	stack_goals = {}
	for i = 0,3 do
		add(stack_goals, stack_new(
			{5},
			8*(card_width + card_gap*2) + card_gap,
			i*(card_height + card_gap*2-1) + card_gap,
			{
				reposition = stack_repose_normal(0),
				can_stack = stack_can_goal, 
				on_click = stack_on_click_unstack(card_is_top)
			}))
	end
	
	
	deck_playable = stack_new(
		{5,7},
		card_gap, card_height + card_gap*3,
		{
			reposition = stack_repose_top_three,
			on_click = stack_on_click_unstack(card_is_top), 
			on_double = stack_on_double_goal
		})	

	suite_menuitem_init()
	suite_menuitem({
		text = "New Game",
		colors = {12, 16, 1}, 
		on_click = function()
			cards_api_coroutine_add(game_reset_anim)
		end
	})
	
	suite_menuitem_rules()
	
	wins_button = suite_menuitem({
		text = "Wins", 
		value = "0000"
	})
	wins_button.update_val = function(b)
		local s = "\fc"..tostr(game_save.wins)
		while(#s < 6) s = "0".. s
		b:set_value(s)
	end	
	wins_button:update_val()
	
	suite_button_simple({
		text = "Auto Place ->", 
		x = 340, y = 248, 
		on_click = function()
			cards_api_coroutine_add(game_auto_place_anim)
		end
	})
	
	cards_api_coroutine_add(game_setup_anim)
	card_position_reset_all()
end

-- deals the cards out
function game_setup_anim()
	pause_frames(30)

	for i = 1,7 do	
		for j, s in pairs(stacks_supply) do
			if j >= i then
				local c = get_top_card(deck_stack)
				if(not c) break
				
				c.a_to = j == i and 0 or 0.5
				stack_add_card(s, c)
				--sfx(3)
				pause_frames(3)
			end
		end
		pause_frames(5)
	end

	cards_api_game_started()
end

-- places all the cards back onto the main deck
function game_reset_anim()
	stack_collecting_anim(deck_stack, stacks_supply, stack_goals, deck_playable)
	pause_frames(35)
	stack_standard_shuffle_anim(deck_stack)
	
	game_setup_anim()
end


-- goes through each card and plays a card where it expects
-- easier than double clicking each card
function game_auto_place_anim()
	::again::
	pause_frames(6) -- delay between cards
	
	-- checks each of the supply stacks, starting from the closest to the goal stacks
	for i = #stacks_supply, 1, -1 do
		if stack_on_double_goal(get_top_card(stacks_supply[i])) then
			-- if found, find the next card the can be stacked on the goal
			goto again
		end
	end
	
	if stack_on_double_goal(get_top_card(deck_playable)) then
		goto again
	end
end

function game_action_resolved()
	if not get_held_stack() then
		for s in all(stacks_supply) do
			local c = get_top_card(s)
			if(c) c.a_to = 0
		end
	end
end

function game_win_anim()
	confetti_new(130,135, 100, 10)
	pause_frames(25)
	confetti_new(350,135, 100, 10)
end

function game_win_condition()
	for g in all(stack_goals) do
		for i = 1,rank_count do
			if not g.cards[i] or g.cards[i].rank ~= i then
				return false
			end
		end
	end
	return true
end

function game_count_win()
	game_save.wins += 1
	wins_button:update_val()
	suite_store_save(game_save)
	cards_api_coroutine_add(game_win_anim)
end

-- reposition calculation that has fixed positions
function stack_repose_top_three(stack)
	local y = stack.y_to
	local len = #stack.cards - 3
	for i, c in pairs(stack.cards) do
		c.x_to = stack.x_to
		c.y_to = y
		y += i <= len and 2 or 12
	end
end

-- determines if stack2 can be placed on stack
-- for solitaire rules like decending ranks and alternating suits
function stack_can_rule(stack, stack2)
	if #stack.cards == 0 then
		return true
	end
	
	local c1 = stack.cards[#stack.cards]
	local c2 = stack2.cards[1]
	
	if c1.rank - 1 == c2.rank 
	and (c1.suit + c2.suit) % 2 == 1 then -- alternating suits (b,r,b,r) (0,1,2,3)
		return true
	end

	--if c1.rank - 1 == c2.rank then
	--	return true
	--end
end

-- expects to be stacked from ace to king with the same suit
function stack_can_goal(stack, stack2)
	
	if #stack2.cards ~= 1 then
		return false
	end
	
	local c1 = stack.cards[#stack.cards]
	local c2 = stack2.cards[1] 
	
	if #stack.cards == 0 and c2.rank == 1 then
		return true
	end
	
	
	if #stack.cards > 0 and c1.rank + 1 == c2.rank and c1.suit == c2.suit then
		return true
	end
end

function stack_on_click_reveal()
	local s = deck_stack.cards
	
	-- draw 3 cards
	if #s > 0 then
		cards_api_coroutine_add(function()
			for i = 1, 3 do
				if #s > 0 then
					local c = s[#s]
					stack_add_card(deck_playable, c)
					c.a_to = 0
					pause_frames(10)
				end
			end
		end)
		
	-- put stack of cards back
	else
		local s = deck_playable.cards
		while #s > 0 do
			local c = s[#s]
			stack_add_card(deck_stack, c)
			c.a_to = 0.5
		end
	end
end

-- attempts to place the card onto any of the goal stacks
-- returns true if successful
function stack_on_double_goal(card)
	-- only accept top card (though could work with multiple cards
	if card and (from_hand or card_is_top(card)) then 
		local old_stack = card.stack
		-- create a temporary stack containing the card
		local temp_stack = from_hand or unstack_cards(card)
		
		-- attempt to place on each of the goal stacks
		for g in all(stack_goals) do
			if g:can_stack(temp_stack) then
				stack_cards(g, temp_stack)
				card.a_to = 0 -- turn face up
				return true
			end
		end
			
		-- if temp stack still exists, then return card to original stack
		if temp_stack then
			stack_apply_unresolved(temp_stack)
		end
	end
end

function unstack_rule_decending(card)
	local s = card.stack.cards
	local i = has(s, card)
	
	-- goes through each card above clicked card to see if it fits the rule
	for j = i+1, #s do
		local next_card = s[j]
		
		-- either rank matches, not decending by 1
		if next_card.suit == card.suit or next_card.rank+1 ~= card.rank then
			return false
		end
	
		card = next_card -- current card becomes previous card
	end
	
	return true
end

function game_draw(layer)
	if layer == 0 then
		cls(3)
	
	elseif layer == 2 then
		confetti_draw()
	end
end

function game_update()
	confetti_update()
end

function game_settings_opened()
	suite_window_add_options("Suit Colors", function(op)
		game_save.suit_colors = op == 2
		reset_card_suit_colors()
		suite_store_save(game_save)
	end, {"4 Colors", "2 Colors"}, game_save.suit_colors and 2 or 1)
end

function reset_card_suit_colors()
	local card_sprites = get_card_sprite()
	
	for c in all(get_all_cards()) do
		c.sprite = card_sprites[c.suit][c.rank]
	end
end


:: card_games/solitaire_normal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Il1d
:: card_games/solitaire_too/
:: card_games/solitaire_too/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTI0IDE5OjU0OjAxIixtb2RpZmllZD0iMjAyNC0w
Ni0yNCAxOTo1NzozOSIscmV2aXNpb249MjRdXWx6NADCAwAAHzYAAPBqe1swXT17Ym1wPXB4dQBD
IDFOBA8d9h8OBvcfFlcM7xAMBw8O6A1XFjcM-xACB-gCDTcWJwz7Awf4Aw0nFhcMSwyXDCsHKA2X
DUgNFxYXOwzHKwcoxw04FxYHDCsM1ysHKNcNKA0HFgc75ysHKOc4BxYHKwxXDAsMVw8AIA0oEADx
AFcMKwxHKwcoNw0YDRgNRxQAUEcMSww3FAATaBAAH2sOAAAlDUguADEbDBswAFFHDSgNVxQAE2dl
AFlXDQgNZ2gAIfcADwAv9wAMAA8hDNfeABHXqQBX_wYH_AYIANAM_wQMBw34BA0HFvcfAwDzKxcP
Gh8bRwoHChcKVwqnDxm3FhcKDxoXCQoJBwonKhcaJxoJFwonLxkHDwkPGQ8JBwUPGQUnFicJCgcC
AFUXChcKBwIAcQkKJwQXBAcCAGEnFhcaCQdKAAEnACAJGgkA0ycaNwQXBQQFBwUEBSeFAPcDBwX0
BAUHCfoECQcWB-QGB-oGCACwJAXXBSQHKgnXCSoOAH-3ACQHKvcADAAKsWcFBAVXJAcqVylnEADR
VwUkBUckBypHCSoJVxIA0kcFRAU3JAcqNxkqGUcSABBkEABZJwlqCTciAAYSAARGAHonCSoJKgk3
agAyCQoJbAAjBedpABFHsAAQNA8A8RTnOgcWBwUkBdckByrXCSoJBxYXNAXHJAcqxwk6FxYXBUQF
l_MA8xSXCUoJFxYnBfQDB-oDCScWNwX0Agf6Agk3FlcF5AUHCeoJVzIB-iYXGA0HCIcI9wcLBwwb
FxYXCAcIBwgXGAcNBw0nGA0XCA0XDAsXGwcbDAcMGwcLDCcWFygHCAIAVRcLFwsHAgAANACAFhcI
JwgHDRgDAAIlAEENGBcbRgCAJysHGwwXFtd4APAtBhbHCA13CA33Bhb3HwYOBjcWDv8NDw4WNwYO
A08SAw429wk2DgNCEwID-hsDAhMCPgMiHgMvBB4DLwMeCwAFDgDQDgITAi4DLwIDDgMvFAUAEBMF
ADsBAw4UAC8zHiUADyweMzYADyUAAF8uMw4CHyUADY8OAwIOMw4CDygADyEPASoADygADhAfKAAf
LiUADAAUAD8jAh4mAA-xAB4CEwIDDi8EAx4vAwMeIgMABw4AIwMCeQHzBAMC8x8CLGZsYWdzPTAs
cGFuX3gIAMd5PTAsem9vbT00fSxLBV8QEATw8DEACx84MQD-----------------------------
----------------------------------_4UG09OH19
:: card_games/solitaire_too/game_info.lua
--[[pod_format="raw",created="2024-03-25 02:13:51",modified="2024-07-21 13:23:51",revision=75]]

function game_info()
	return {
		name = "Solitaire Too",
		author = "Werxzy",
		description = "Similar to standard solitaire, but can alternate between any suit.",
		rules = {
			"\tStack cards of the same suit, from Ace to King, in the card slots to the right",
			"\tCards can be stacked in the 7 middle slots if they don't match in suit and are 1 rank lower than the card below.\n\tAce is rank 1. Jack, Queen, King are rank 11, 12, 13.",
			"\tClick the deck to reveal a new card. Revealed cards can be moved one at a time and can't be stacked on.",
			"\tWhen the deck is out of cards, click the refresh button in the top left to move all the revealed cards back.",
			"\tIf you believe you have reached a state in which you cannot progress further, you will have to start a new game."
		},
		desc_score = {
			format = "Wins : %i",
			param = {"wins"}
		},
		api_version = 2,
		order = 2
	}
end

:: card_games/solitaire_too/solitaire_too.lua
--[[pod_format="raw",created="2024-03-17 19:21:13",modified="2024-07-21 13:23:51",revision=11102]]


include "suite_scripts/confetti.lua"
include "cards_api/card_gen.lua"

-- updates card size if it changed
card_width = 45
card_height = 60

rank_count = 13 -- adjustable

function game_setup()

	-- save data is based on lua file's name
	game_save = suite_load_save() or {
		wins = 0
	}	

	local card_gap = 4	

	deck_stack = stack_new(
		{5,6},
		card_gap, card_gap,
		{
			reposition = stack_repose_static(-0.16),
			on_click = stack_on_click_reveal
		})
		
	local card_back = suite_card_back()
	local card_sprites = card_gen_standard({
		suits = 4, 
		ranks = rank_count
	})
	
	for suit = 1,4 do
		for rank = 1,rank_count do		
			card_new({
				sprite = card_sprites[suit][rank], 
				back_sprite = card_back,
				stack = deck_stack,
				a = 0.5,
				suit = suit,
				rank = rank,
			})
		end
	end

	stack_quick_shuffle(deck_stack)	
	
	
	stacks_supply = {}
	for i = 1,7 do
		add(stacks_supply, stack_new(
			{5},
			i*(card_width + card_gap*2) + card_gap, card_gap, 
			{
				reposition = stack_repose_normal(),
				can_stack = stack_can_rule,
				on_click = stack_on_click_unstack(unstack_rule_decending, unstack_rule_face_up), 
				on_double = stack_on_double_goal
			}))
			
	end
	
	stack_goals = {}
	for i = 0,3 do
		add(stack_goals, stack_new(
			{5},
			8*(card_width + card_gap*2) + card_gap,
			i*(card_height + card_gap*2-1) + card_gap,
			{
				reposition = stack_repose_normal(0),
				can_stack = stack_can_goal, 
				on_click = stack_on_click_unstack(card_is_top)
			}))
	end
	
	deck_playable = stack_new(
		{5,7},
		card_gap, card_height + card_gap*3,
		{
			reposition = stack_repose_static(2),
			on_click = stack_on_click_unstack(card_is_top), 
			on_double = stack_on_double_goal
		})
		
	suite_menuitem_init()
	suite_menuitem({
		text = "New Game",
		colors = {12, 16, 1}, 
		on_click = function()
			cards_api_coroutine_add(game_reset_anim)
		end
	})
	
	suite_menuitem_rules()
	
	wins_button = suite_menuitem({
		text = "Wins", 
		value = "0000"
	})
	wins_button.update_val = function(b)
		local s = "\fc"..tostr(game_save.wins)
		while(#s < 6) s = "0".. s
		b:set_value(s)
	end	
	wins_button:update_val()
		
	suite_button_simple({
		text = "Auto Place ->", 
		x = 340, y = 248, 
		on_click = function()
			cards_api_coroutine_add(game_auto_place_anim)
		end
	})
	
	cards_api_coroutine_add(game_setup_anim)
	card_position_reset_all()
end

-- deals the cards out
function game_setup_anim()
	pause_frames(30)

	for i = 1,5 do	
		for s in all(stacks_supply) do
			local c = get_top_card(deck_stack)
			if(not c) break
			
			stack_add_card(s, c)
			c.a_to = 0
			pause_frames(3)
		end
		pause_frames(5)
	end

	cards_api_game_started()
end

-- places all the cards back onto the main deck
function game_reset_anim()
	stack_collecting_anim(deck_stack, stacks_supply, stack_goals, deck_playable)
	pause_frames(35)
	stack_standard_shuffle_anim(deck_stack)
	
	game_setup_anim()
end

-- goes through each card and plays a card where it expects
-- easier than double clicking each card
function game_auto_place_anim()
	::again::
	pause_frames(6) -- delay between cards
	
	-- checks each of the supply stacks, starting from the closest to the goal stacks
	for i = #stacks_supply, 1, -1 do
		if stack_on_double_goal(get_top_card(stacks_supply[i])) then
			-- if found, find the next card the can be stacked on the goal
			goto again
		end
	end
	
	if stack_on_double_goal(get_top_card(deck_playable)) then
		goto again
	end
end

function game_win_anim()
	confetti_new(130,135, 100, 10)
	pause_frames(25)
	confetti_new(350,135, 100, 10)
end

function game_win_condition()
	for g in all(stack_goals) do
		for i = 1,rank_count do
			if not g.cards[i] or g.cards[i].rank ~= i then
				return false
			end
		end
	end
	return true
end

function game_count_win()
	game_save.wins += 1
	wins_button:update_val()
	suite_store_save(game_save)
	cards_api_coroutine_add(game_win_anim)
end

--[[ as cool as this might be, it's expensive

!!! also doesn't use the new stack function parameters

function stack_win_anim()
	win_stack = stack_new({}, 0, 0, stack_win_reposition, false, stack_cant, stack_cant)
	for s in all(stack_goals) do
		while #s.cards > 0 do
			local c = get_top_card(s)
			stack_add_card(win_stack, c)
			c.a_to=0
			pause_frames(3)
		end
	end
end
	
function stack_win_reposition(stack)
	local dx, dy = 240 - card_width/2, 135 - card_height/2
	for i, c in pairs(stack.cards) do
		i = -i
		local r = 170
		local t = time()/9 + i/#stack.cards
		local t2 = time() + i/#stack.cards*6
		c.x_to = sin(t)*r + dx + sin(t2)  * 14
		c.y_to = cos(t)*r/2 + dy + cos(t2) * 14
	end
end
]]

-- determines if stack2 can be placed on stack
-- for solitaire rules like decending ranks and alternating suits
function stack_can_rule(stack, stack2)
	if #stack.cards == 0 then
		return true
	end
	
	local c1 = stack.cards[#stack.cards]
	local c2 = stack2.cards[1]
	
	if c1.rank - 1 == c2.rank 
	and c1.suit ~= c2.suit then
		return true
	end

	--if c1.rank - 1 == c2.rank then
	--	return true
	--end
end

-- expects to be stacked from ace to king with the same suit
function stack_can_goal(stack, stack2)
	
	if #stack2.cards ~= 1 then
		return false
	end
	
	local c1 = stack.cards[#stack.cards]
	local c2 = stack2.cards[1] 
	
	if #stack.cards == 0 and c2.rank == 1 then
		return true
	end
	
	
	if #stack.cards > 0 and c1.rank + 1 == c2.rank and c1.suit == c2.suit then
		return true
	end
end

function stack_on_click_reveal()
	local s = deck_stack.cards
	
	if #s > 0 then
		local c = s[#s]
		stack_add_card(deck_playable, c)
		c.a_to = 0
				
	else
		local s = deck_playable.cards
		while #s > 0 do
			local c = s[#s]
			stack_add_card(deck_stack, c)
			c.a_to = 0.5
		end
	end
end

-- attempts to place the card onto any of the goal stacks
-- returns true if successful
function stack_on_double_goal(card)
	-- only accept top card (though could work with multiple cards
	if card and (from_hand or card_is_top(card)) then 
		local old_stack = card.stack
		-- create a temporary stack containing the card
		local temp_stack = from_hand or unstack_cards(card)
		
		-- attempt to place on each of the goal stacks
		for g in all(stack_goals) do
			if g:can_stack(temp_stack) then
				stack_cards(g, temp_stack)
				card.a_to = 0 -- turn face up
				return true
			end
		end
			
		-- if temp stack still exists, then return card to original stack
		if temp_stack then
			stack_apply_unresolved(temp_stack)
		end
	end
end

function unstack_rule_decending(card)
	local s = card.stack.cards
	local i = has(s, card)
	
	-- goes through each card above clicked card to see if it fits the rule
	for j = i+1, #s do
		local next_card = s[j]
		
		-- either rank matches, not decending by 1
		if next_card.suit == card.suit or next_card.rank+1 ~= card.rank then
			return false
		end
	
		card = next_card -- current card becomes previous card
	end
	
	return true
end

function game_draw(layer)
	if layer == 0 then
		cls(3)
			
	elseif layer == 2 then
		confetti_draw()
	end
end

function game_update()
	confetti_update()
end

:: card_games/solitaire_too/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Il1d
:: card_games/spider_solitaire/
:: card_games/spider_solitaire/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTI0IDE4OjUzOjM4Iixtb2RpZmllZD0iMjAyNC0w
Ni0yNCAxOTo1MjoyNiIscmV2aXNpb249ODddXWx6NACgCAAAAjwAAPAje1swXT17Ym1wPXB4dQBD
IDFOBA8SHX8dLX4NDi2eHQ4NPi0PEg38Hw0ODB0cHT4dDA0CAPAIHA0sDRwNPA0sDSwCDAIsDQ4c
HUwtbj0XAAACAIGMDQ48DQ4NDCYAQBwdfi0VACAMAgIAgBwNDgwNLB0OGQASDTAA0wwdfi1sHgwN
PC0ODSwWAPMDPA0sHQwdPi0cHgwdDB0sHQ4dLgCxHRwdLA18DQweHA4NAABmAAVJAABiAANoAHE8
HgwNDA4cRwAGbQCTXA2cHiwtHB1MOAABPABiAjwNHAIMAgBAHhwNDBsAIDwtWwACIQCATAIPFQ0C
jB4MAAB1ABFcqAADaQBUCwwNCxzaAHMsPQwdPD0sXQBQPAIbAoxFAHMsDg08HUwdUgBTAhw7DAIC
AAANAYEcLQ4cHVwNXDYAszwbAowNDiwNPB2M3wASjCoAsQIdHA0sLTwNXA0MKwAR3DsAlR0sDTxd
LE08LcEA8gECDB4sDfwbHhwNHDIMMixSBAAxHAIclABSQgxCHFIEAPADPA4NLCI8EgwiLBIsEgwi
DBJMBgAAPwBQEkwSHBIWADIcEgwMAA8UABagDAIMEjsMOxIMWwUAIEsCBgBQAgwePEsMADACOwIH
APEHWwxLAiweLCsiDBsCKywbLBsCKwwbMg0AwA0OLBsCDBIMGwwCGxoAYQwCGwwbTA4AQQ0ODAIn
AKQcGwwSGxIMGxIbDwAARwFMLBsiHBsAADcAVB4sKwIsTwARHE4AUAIrLB0sjAATWxQAoFsMSzwe
DAIcAjuaAAN3ABFLrABAAgweXIQAE2ynACACPD8Akw4NLFsMGxwCHNIAIksCbQDgDg0sSwIMCwJM
Www7AhwjAAAUAPMLDAKsAgwC-A0CDB6MDR5MDgwOHA5cDowNbB44AhEOWALCDA4sLhweLB4NHA5M
TgJDnA0ODAIAVRwOHA4MAgAA_wExbB4MPgBBLB4NDGsDASUAIA0eIAAxLB48HADDDB58DfwGDWwN
bA0ObAAzHTwNHAAD9gIApwLBHA0OrA08HbwNfC1MaAFAAiw9HEoD8gktfB0sAjwdDgxNHlwNfA0s
DQ5tfB0cDly6AAH8AxEcCwOxDg1sTTwOLSwODWwoAHMcDm2MHRwtpABAHE1sDcsCkawdDA5MHswN
XI4Dww6dLA4dLA4NXAJcDVAAAQkBoZwtDC0eDD08PWwRAABdANI8PRwOPB4sDR4tnA08cQBwPUwN
Dh0cHvcDcS4tHC08DTxjAHAcPQwdDC0OOQByTA0eLTwNTGwAMA1cDl4CIw0sVAAhLi0ZACAdHjYA
Ek0YADAsDUxMAAEiAAAYABQcMQAAjwRQTA0uPTxhABAOfAQlDTwXAEIsDS4NZwQQDMkB8B4sDfwY
HaxN3l2sDQwNfh0M8gcMHW4dDA0rIgwdLv0HLh0MIisdCyL8FyILHQsdAw8CABP4ARILDQzyARsS
CxILEkviDQw6AGEbAgsCCxIEADMiOxIVAIACDBIcsgsSGxgAUQIrUiuyYwEDAgAQC1EAVxILAiti
MACnAhySC2JrAnvCHBQAAS4AKAzbEgDaEhzyACsMAjsSG-ICHMMAYAsCSwILAoADGQK8AJEMDQvy
AAsiCxICAGriCx0LAgwCABMyHAApAgwCAAD2ABMFGwDzAvIADCxmbGFncz0wLHBhbl94CADHeT0w
LHpvb209MX0syQbwCDNCBPDJA-AiAwAD8AUD8AojAAPwAQMADwA6BgMADgCSAw8bIwAD4AMAEgCy
BAMAEw4TAAPAAwAqAPEIBRMOAw4jwAMAIw4j8AYTDjMAA6AzDjMpAFAuEwADgBoAIwMOPABQIw4L
M4BDADUDDhMSAOIOIwADYCMuI-AIIw4bQ2kAMQAjGzQAYQkTDhsOMxIAMDMOGzQAggkjGw7DDgsO
DAByDgsuYz4bIwwAMxsTbk8AAEsAUQMbow4baAAy0ANghgBjCw6TDgsOFAAyAANAFgBRGw5TLhvW
ADAAA7BqACADIKMAUCMbA14TTwAAUQAxQAMw8AABAgAgEw6WABFjXgAhDiMvAGADAAMQAwC9AMIj
DiMeCw5jDgsTDiNUAAICABAQawAxYw4TcQBSMx4bDhNaAIAAQxAzDgMeMy4AsBsDPgMbHhMOMw5D
pgAwEAMATAABSQBAHgsOM3EAoCMOMx4DHgMOIxBWADIzGw5wAAMoAHAeIw4bHhMArQCQQw4bHjMO
Axs_agAATwDAGx4jAANQAwAzHhseuQAAMQCxCx4jDiMOOw5DkDPUAFATHhseG3AAEDtjADIAA5Dt
AKEDDhsuSw4jHjse4QEQsMsAMRMeO1IBIAMOFgAEPwERIy4AAOMAMCMOSxoCAhoAMtAjDkgAIwtD
NgEADgBEEAPgExgAUg4zDgseGAATExgAAEgAICsOCQIDSQAiI9CPADAjKw4VABQ7FwABtQGgEw4T
HiseA0seK50AIw4TvwAQMxUAow4DGx4bDgMeGx4ZABBwTwKSOx4zDhsuCx4jMgAiI3AcARAjcwAA
GwEiMw57AEATgAMACAARAy0BAawAQQsOMy5NABBweQAxAw5ToQFhQxsTHiMOTgBQAANwYwCdAOQb
TgMbAw5THhseM3ADAAIAAGgBZDMeCw5TPpYBAI8CAlYCMQsOM3sAAMcCEACnAaBzDhsjDnMOAw4z
tQJhDhsTXhMbiAEBvgJgI9ATXlMeGgIBWgACkAAiE7CzABCzTgABoQJTY7AzDlMgAAE9AxFg0AIS
sIQCAgIAMiMLDrIDAB4DIEMgIANSAwsOE6ARAAECAAAdAAPPA6AMAwADwBMOM-AcEgCBI-AcQwAD
8BwmACLwHgcAH8_WBBlfEBAE8PAxAAsfODEA----------------------------------------
------------------------h1BtPTh9fQ==
:: card_games/spider_solitaire/game_info.lua
--[[pod_format="raw",created="2024-03-25 02:14:11",modified="2024-07-21 13:23:51",revision=728]]

function game_info()
	return {
		name = "Spider Solitaire",
		author = "Werxzy",
		description = "Create stacks from King to Ace.",
		rules = {
			"\tCards may be placed onto another card of one rank higher.\n\tMultiple cards can be picked up as long as each are one rank lower than the card on top of them.",
			"\tFace down cards cannot be picked up and will turn face up when there is no card on top of them.",
			"\tClick on the deck to place a card on top of each stack of the 8 columns.",
			"\tStack cards from ranks King to Ace to transfer them to the goal stack.\n\tWin by transfering all cards to the goal stack."
		},
		desc_score = {
			format = "Wins : %i",
			param = {"wins"}
		},
		api_version = 2
	}
end

:: card_games/spider_solitaire/spider_solitaire.lua
--[[pod_format="raw",created="2024-03-17 19:21:13",modified="2024-07-21 13:23:51",revision=4710]]


include "suite_scripts/confetti.lua"
include "cards_api/card_gen.lua"

-- updates card size if it changed
card_width = 45
card_height = 60

total_sets = 5
available_decks = 1
total_ranks = 13 -- king

available_columns = 8

function game_setup()
	
	game_save = suite_load_save() or {
		wins = 0
	}	
		
	local card_gap = 4
	
	deck_stack = stack_new(
		{5,257},
		card_gap, card_gap,
		{
			reposition = stack_repose_static(-0.16),
			on_click = stack_on_click_reveal
		})
		
	local card_back = suite_card_back()
	current_card_sprites = card_gen_standard({
		suits = 5
	})
	
	current_suit = rnd({1,2,3,4,5})

	for sets = 1,total_sets do
		for rank = 1,total_ranks do		
			card_new({
				sprite = current_card_sprites[current_suit][rank], 
				back_sprite = card_back,
				stack = deck_stack,
				a = 0.5,
				suit = 1,
				rank = rank,
			})
		end
	end
	
	
	stack_quick_shuffle(deck_stack)	
	
	
	stacks_supply = {}
	for i = 1,available_columns do
		add(stacks_supply, stack_new(
			{5},
			i*(card_width + card_gap*2) + card_gap, card_gap, 
			{
				reposition = stack_repose_normal(),
				can_stack = stack_can_rule, 
				on_click = stack_on_click_unstack(unstack_rule_decending, unstack_rule_face_up)
			}))	
	end
	
	stack_goal = stack_new(
		{5,257},
		card_gap, card_gap * 3 + card_height,
		{
			reposition = stack_repose_static(-0.16),
		})

	suite_menuitem_init()
	suite_menuitem({
		text = "New Game",
		colors = {12, 16, 1}, 
		on_click = function()
			cards_api_coroutine_add(game_reset_anim)
		end
	})
	
	suite_menuitem_rules()
	
	wins_button = suite_menuitem({
		text = "Wins", 
		value = "0000"
	})
	wins_button.update_val = function(b)
		local s = "\fc"..tostr(game_save.wins)
		while(#s < 6) s = "0".. s
		b:set_value(s)
	end	
	wins_button:update_val()
	
	cards_api_coroutine_add(game_setup_anim)
	card_position_reset_all()
end

-- deals the cards out
function game_setup_anim()
	pause_frames(30)
	for i = 1,5 do	
		for s in all(stacks_supply) do
			-- ensure that the last click on the deck of cards places a card on each middle stack
			if i ~= 5 or #deck_stack.cards % #stacks_supply ~= 0 then
				local c = get_top_card(deck_stack)
				stack_add_card(s, c)
				c.a_to = 0.5
				pause_frames(3)
			end
		end
		pause_frames(5)
	end

	cards_api_game_started()
end

-- places all the cards back onto the main deck
function game_reset_anim()
	stack_collecting_anim(deck_stack, stacks_supply, stack_goal)
	pause_frames(35)
	stack_standard_shuffle_anim(deck_stack)
	
	local op = {1,2,3,4,5}
	del(op, current_suit)
	current_suit = rnd(op)
	
	for c in all(deck_stack.cards) do
		c.sprite =  current_card_sprites[current_suit][c.rank]
	end
	
	game_setup_anim()
end

-- determines if stack2 can be placed on stack
-- for solitaire rules like decending ranks and alternating suits
function stack_can_rule(stack, stack2)
	if s == get_held_stack() then
		return false
	end
	if #stack.cards == 0 then
		return true
	end
	
	local c1 = stack.cards[#stack.cards]
	local c2 = stack2.cards[1]
	
	if c1.suit == c2.suit then
		if c1.rank - 1 == c2.rank then
			return true
		end
	end	
end

function stack_on_click_reveal(card)
	if #deck_stack.cards>0 then
		cards_api_coroutine_add(deck_draw_anim)
	end
end

function deck_draw_anim()
	local s = deck_stack.cards

	for i=1,#stacks_supply do
		if #s > 0 then
			local c = s[#s]
			stack_add_card(stacks_supply[i], c)
			c.a_to = 0

			pause_frames(3)
		end
	end
end

--[[
function stack_on_double_goal(card)
	-- only accept top card (though could work with multiple cards
	if card and card_is_top(card) then 
		local old_stack = card.stack
		-- create a temporary stack
		local temp_stack = unstack_cards(card)
		
		-- attempt to place on each of the goal stacks
		for g in all(stack_goals) do
			if g:can_stack(temp_stack) then
				stack_cards(g, temp_stack)
				temp_stack = nil
				break
			end
		end
			
		-- if temp stack still exists, then return card to original stack
		if temp_stack then
			stack_cards(old_stack, temp_stack)
		end
	end
end
]]

function unstack_rule_decending(card)
	local s = card.stack.cards
	local i = has(s, card)
	
	-- goes through each card above clicked card to see if it fits the rule
	for j = i+1, #s do
		local next_card = s[j]
		
		if next_card.a_to == 0.5 -- must face up
		or next_card.suit ~= card.suit -- must match suit
		or next_card.rank+1 ~= card.rank then -- must decrease in rank
			return false
		end
				
		card = next_card -- current card becomes previous card
	end
	
	return true
end

function game_draw(layer)
	if layer == 0 then
		cls(3)
	elseif layer == 2 then
		confetti_draw()
	end
end

function game_update()
	confetti_update()
end



function game_action_resolved()
	for stack in all(stacks_supply) do
		local i = #stack.cards
		local card = stack.cards[i]
		i -= 1 -- prepare next card

		-- for every king found
		if card and card.rank == 1 then
			local suit = card.suit
			local r = card.rank+1 -- start by searching for queen
			
			while i > 0 -- haven't reached end of stack
			and stack.cards[i].rank == r -- card has expected rank
			and stack.cards[i].suit == suit -- card has same suit
			and r <= total_ranks do -- haven't haven't checked rank 1 yet
				r += 1 -- 1 rank lower, ignore Aces
				i -= 1 -- next card
			end
			
			-- if all the ranks found
			if r > total_ranks then
				i += 1
				cards_api_coroutine_add(function()
					pause_frames(15)
					while stack.cards[i] do
						stack_cards(stack_goal, unstack_cards(stack.cards[#stack.cards]))
						pause_frames(3)
					end
				end)
				
			end
		end
		if card and not get_held_stack() then
			card.a_to = 0
		end
	end
end

-- winning things
function game_win_anim()
	confetti_new(130,135, 100, 10)
	pause_frames(25)
	confetti_new(350,135, 100, 10)
end

function game_win_condition()
	local cards_all = get_all_cards()
	return #cards_all == #stack_goal.cards
end

function game_count_win()
	game_save.wins += 1
	wins_button:update_val()
	suite_store_save(game_save)
	cards_api_coroutine_add(game_win_anim)
end

:: card_games/spider_solitaire/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTI1IDAyOjA5OjA1Il1d
:: card_games/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTIxIDE2OjUwOjE2Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTIxIDE2OjUwOjE2Il1d
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTE0IDIxOjE0OjA5Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1NjozNyIscmV2aXNpb249MzM0NDNdXWx6NACxngAATZYBAPMUe1swXT17Ym1wPXB4
dQBDIBAQBPDwLGZsYWdzPTAscGFuX3gIAMd5PTAsem9vbT04fSwxAPEASkIEBvcLBvAABvcLJvcK
CQDwAgr2DgcPHdAOB-YMDvYMBw6wCgCRLvYMBwYOcA4GDADzAw4Xdhf2Di72EFf2EC72OC72NgYA
k2YfG-MLHRYNAwQAIBMNCAByli5GDfMPDQ8ABgQAwHYuRg0DFg0DJgMNFgMAECYNAIYNFgMWEw0W
IwMA43YuNg0DBgMGEwYTBg0TCQATAwIAMw0GAycAAgMAYGYuRhMWDSIAEiMqABQWLAAyExYzAgBv
di42EwYzTQABByUAAEgAIQYjmgAjFg0kACwWDUgAFvMwAPALHg8T8zgMHvY2LlYNIw0WDSMWHUYN
Mw0GDTMNAAEIAPQDBg0jDSYNIw1GLjYNQwYNQwYTIgAADQAABwARQw4AcDYuRiMNJiN3AFBmEw02
EwsAgCYTDRYTDSMGNgEQNhUAIQ0GHwAQRhoAUQYTJhMm0ACVE3YuRjMNFhMWHQAQBjwAQCZDDQYc
ARA2ZQAHHQAgDSMcAHMWIw1WLnYNYAFTEw1WE0Z0AFEmEw0TDXQAEVZ8AGQjBiMNNg11ACcWDXYA
FEO_AAAEAAA6ADQWEwZuABFD8wAB1AAAAAEPIgACAEICgw4c8zYcDvYCVAFyFvMHZi72AQwAEDMW
AgCAASADJgIANhNWLigAAYUAEQP0ATkTBjM0ACQmAxkAIRYNNAA2DSMWAwA1Ew0GIAABIQEj9gEa
AAIDAAD8AdcWAyYTBhMmAw1WLvYDvgICBAC58wMNdi72Ax0DDRYEADnjHXYZAwgGAP0XBg72NA4G
Dg8N-jj7PE8SCw72Kg4LShsKC-40CwobCv42Civ_NjsDABArGgAFJgABBwBbCwr7OArwA5ItNC4x
NDI4NTcGAAP_A0UtMTEuFAAyMTQzDQQZMw0E8REcGwQQXxQfFU8UDxU-FA8VLxQPFQ8UIA5EDxUO
NA0OJAMAogQOAA4kDg0ONA4SAPALHhQNHhT9By4EDv0GDgQu-QcUHQ4E-QYEHg0SAJEEDR4EDv0H
Lg0eACAODRsAIRQdGgABDQBxBwQNPv0GLhgAACAAURT9BhQeHwAQLh0AQQ4NDg1GAAI6AAAPAABs
ABAULQARHiwAEkSLABEekwAQLgYA8QUkHg0ONB5EHg0_DU4NXg1_DQAdDgoAX04NDh0ALQE28EMU
FQQA-xQCAA4UDmQOJA4kHoQOdB70Ah40HrQeNB8VHpQeND0eZC40XR5UHjR9HjQeNJ0OJB4EDhSt
JC4knSQeDTR9NA4EHjRddB40PZQeNB20PgBg9AIeBA40UACzDiQuDT4NLg0uDU4IAD8uDQ6_ACgf
Nr4AE-EMHxW0HjQeHZQeND4dZC40Xh1UHjR_HTQeNJ4NvgBQriQuJJ6_ABF_vgBhXnQeND6U9QAP
vgBY6TNCBED-IBlw-h1AfgAuAgBbniBuAC4CAF2OEE4ALgIAX24APgAuAgAAP74ALgIAAAxoAA8W
AAkPGAAHD3IAAwIwACEeEAIAEyAIAAUwAAMYADYQLhAaABV_FgAFMAABGAAQPhgAKSAOAgAAGgAs
fgAWAAIYAA8wADEvDiAwAAovIA4wAEQvDiAwAP8oH27GAQAPMAAILxBeMABMPz4ADjIAGmMOIA4A
HgAKAA80ALs3oA4gAgCxED4QDiAOQA4ADmACAAQqAAQMAAICAFWQPhAOYAIAAiIAZfAePlAOYAIA
AhMAOx4ADioA_xAOAB7wHg4QDvAfDiAO8B0OQB7wGR6ADgAO8BEOAA5QswVVMS4xMjWpBUI3Ljc1
nwUcMZ8F8UTw----aqPwDyNA4-ALQxBDHxsrHlPwChMOUx6LHjPwCRMLDjMOyw4z8AgTGw4T_wEz
8AcTKw57Lnsz8AYTix5DHlsz8AUTew6DDksOI-AFE1sOswoAcQQTaw6zDjsKABB7CgAACQDQDnsO
ow47DhPwBOMgUwgA8QAFw0BDDjsT8AYTDgMOU1AMACMFswgAABQAQgMOQ0AqAHEjDgMOYyBTPwAD
GwAQ41YAQQUTXsNoAPIBBSMeCy6jDksOE-AHEy4LLpIAQAcjDgsCAAKqABIIDgAQK78AEAoMAFHb
M-AMI_AAIQ4j8QAwEEMeAQFQE9PwF4McAR_eWQEoNQQDAAIASfAWAwACAEnwFAMAAgAg8BIHABGj
CwBHEAMA4wcAVDMPGwMOAgAQExIAc-MBAAPwETMTAFADDiPwEyEBBSQAQ-ATI64FABIU9AAAAgBQ
I-AUI44FABEeEABRHhPwFTMKAGEOCyPwFiM8ARQXLwABCwAAEgApGBMHADIjSyMFAHcZE0sT8Bkj
BQDwCSPwFzNLQ-ANs0uz8AWjHkseo-AEIw77BwYC8QEzDvsFDjPwBTMOKz5DPisOjQFAKw6DDgsA
YQkzDisOYwsAEAsLABFDCwAQDQsAESMLABAPCwARAwsA8QERMw5rDjPwEzMOSw4z8BUzFQDPGJPw
GnPwHTPw--9tsgEi9Q8QEAQwDVYNUA0GdwYNIA0GlwYNEAa3BgAN1w0G1xYCAJEGDdcNAAa3BhAi
ABEgLgBfUA1WDTDMDwsZOWwAQDxGBLPSAWcjDxNDDgMCABCDygHxBA4DDtMOAw7zIA0DDQMNww0D
DWMKADMDDSMIAAQ1AFSTDaMN4xQATw2zDQMCABE4LQMNAgAxsw2jEgAZYyAAb9MNA00DDTQABBZt
FgBPIw5TTSYABAgCAChNsyAAAkAAE60KAAHKABBTEgBHTQP9AUkAUU0DDXMO8wAg-RMNAALgAhBz
EQARjSEAEc0GAAMvAGFDDgMeAw4QAFH9AQP9BwoABjIAAlMADwIABQEeACJjDlYEA5wAAAIAEu2s
ABQjRgAPAgAUI4MeSAACqAAOAgAXjVYAD5oACwqcAAY_AQ4CAAK0AAROAQ9WABIB6AEfjRgAABLN
ngAxAw4zhwEPOgABDAIAEpOEABVtIAAQ7ZQBLlMtMAAMCgESk1QAA-wBAkcABTUAGFN1AAqLAAAJ
ARFNdwAZDQ8CCCgABQoAFJPTAQ4CAAHRABizRQEGcgACCAAEDAAuDZN-AQoCABEtUwEMSAAYTYwA
LLNtMgAJAgA4TfMAZQAeLTgCAOYBF3NRAAUIAAYCAAESADJzDgM-Aw6zAAIiAAVUAwOCAQ8CAAkU
LVIAA4YCOy0DbU4ABGoAASQAMzMOQzQADwIADwdWAA6qAAYCABBtrAA-sw0DUgIND1QAETD9ASP1
AAa5AA8CAAMxTQMtggQabQcBRAP9BdM9AAZeABWtjwIEiQI2-QnTNAAPAgAHFS1cAgbhARhtBgMS
s2sADwIACQAgACgdg0IAAgIAHG1mAB_zSgANASoABoQCE00GADVNA22NAANLAA8HAw4CBQMCBgAE
wgEAnAEDIgALqwAFOgABZABBDQP9AxEAAEEATk0jDrMvAA03ABKTDAAj-RtEABqNHwAFAgAB1AAi
8wCpASP9CQoFEy2sAAIzAQEGABKTRAIl-RshAAU-AAUCAEBtA12DtAcKZQABYwAERwAEHAB4sy0D
DaMNAwIABjQANy3DHQ4ABwIAGCMmAAMMAGGDHQMt8wcNAINjHdMNEw0DHbwGEw4nAAKIAws4CAAC
AAAlAiHzDAsAIvMURgsUDQgEK-M5xgjzAS0xMC43OTE4OTk3NjY5MDHVCP8AOC44MTI4MzQzODc4
MzQ0TwkBQlFWBBCaFACmFAAEAFEvFT8UHxAAEy8YAHMfFA8VbxQvDACC4A4kDhQODxWwFHAODR40
LiQe8RLwBBQONA4dLiQNDhQNDsANDhQODRQOAEE0LjQeKQAB7hRAFB4kLmIUAJQUELCEFADJEjQd
DjQAFYEODT4NHhQeFEAAAH0U8AENHiQNFA6wLg0fE0McHS4dmBRwTgwTDxsjHLwUASgAgAQODRwz
DA4EDQCBsA4EDQwTCwMCAPILUywNHg0OHRwDCwMrAwsjHA0_HR4NDGMMHiQoAAAWAAQCADuDCwMC
AHAzLFMLAwsjtwBAsA4EDhMAYPMLC-MMDHQAcrANBA4MAwsCABBDKAAQDAYAClAAESMYAAGnFRCw
7AAQDBUAYPMfDg0usLwAoQwDDAMMwwwDDGMKADMDDCMIAARKACATHvsAhAQOHEMMowzjHQAyDKMN
wAAAggAPAgAROCwDDAIAQDMMDhTSABAuVwABHAAZYyoAELOxABCw5QBvEwwDTAMMSAAEFmwWADAj
CwN_AX_wDhQNDENMMAAECAIAMExzPi0AGEMmAAJQABOsCgACWgEA3AEAfAEgDFMcAEdMA-wBWQBA
TAMMcz8XYbAeDQwDCzwBIPwTFgASIz0AEA3mADANDoMZABGMMgARzAYAA0AAMEMLEwgBES4tAgAW
AHb8AQP8BwMMfQAA0wBWDR4DC2N0AA8CAAUBHgCDYwsTPrANBA5-AgLNAAAeABLs3QABmAABsgAD
TwIBAAEPAgAUI5MMOQAFXgAC1AAOAgAVjGwAAzMALw2DvwANBcEAJCMNUAEBYwAElgEOAgAWrCkB
IhMNzAMvDFNnABS8AwyjDgQNsA0eDEPGABQsqAETIwEDIA2wKQMRI_4BD0oAAQ4nAXENHrAOBB4c
pAAVbCcAEOzxARMjfQFuDQQOHAMsQwAMRwEygwwOgQMCbwADfgIC-wAFPQAgEw0gBEkNFA4cmgAK
sAARbPUCAzoEEw77AwmUAggyAAUKALQOFA0_DW4ADSQNg0wCDgIAArsBuA0EPiQOVB4UDgwzogEG
kQACCAAEDABADBMMDksaEGT4GQAUBQ7qAQkCABAsDgEAPwG-NA0kDQQuBA4NIwtnAAAYTMAAEEMw
AFBEDQQNJIcFLHNsUQAJAgAgTJMuAEBUDTQecwMYQ5AAHizfAgN8AqcOFA0UbRQuBA1TdwAFCAAG
AgAUTPEDQQQODaR3BiMDCzMEDvcAAi8AAkgEMCsDPvEAAWUGLgyTtgAMAgAULGkAIQ0eOAAXHrAD
AB4AG2xmAASCAABqACMNLjMAQw1DC0NLAA8CAA8xQwsTZwEQLQcBJgwDbQAO2QAGAgASbF8DcgMe
BB6UDS7ZAA4OAw9sAAEAQgFvBA4kPRQubQAOIfwBZgDoLg00DQQNBA0UHg0ODXP5AA8CAANBTAMs
Uz8BATUAaC4EDiMLI2EAAqgAJPwFTgUhHlQpCCUEDlwABo0AAJ0CIExT8AEQpKIDA-MBBHMDMfwJ
Q0MCUCQdBB0UlQgmDXNhAA8CAAcDIAAQUyAGIRQNAgAkHhQPAwSeAhhsJQREQw4NHioAEQQFAQCn
AA8CAAkAIAAgHEMgHBBtEQID1QMEXQACAgAcbJIAnzMMDRQOpE4MY14ADQPPAwCqCTOUDg1gBxVs
eQAABgA1TANsLggB8wEQhMIJFWNsAA9cAA0gPoRZBCYODYgBBAYABIACBIQEAoIAJQ0ODQgK5gAF
VAAEgQQBEgESLhcANPwDA2EAQEwjC1MBCgFEAxAu4gUeI0sADVMAUXMMDiQNMwAUPk4JIvwbZgkA
rwIgRC1bAhAUnAAajDkABQIAE0xHAACbABCkJAEiDENiAiP8CUEBAvoKAJsFMw2DLAcBArwBAQYA
MkMLA2AEIBQNAh4iBB6-CgSJACEjC9oKiEQNND4NDJMsdgAFAgBAbANcU_4HUA0eNE0U2x8RDHwK
CqsAAakABHUABBwAMyMLA7kAAOgIaCwDDKMMAwIABkEAMCxzDKAeUD0UDg0eoQAnExwdAAcCABgj
NQADDAAABAsFBgQA_whhUxwDLPMHHgBHYxyTHhwAAVsAdwwTDAMcEwtgBAACAAcMAAHHAwQMAABu
BSEOZCsEMAMrE44BAGYLEQEdAEDzBS6k-wMTE6YLBgIAESPrABQjDgAUC8wIkR4kDSQNJC4NDBAA
IfMJBwBhwwuDCxMMpAERRMkEBPwEBO0LBEsAAVEMFmNtAAD5AAE0ADMODS7XC1NzDAM8AwwAMdMc
Y18DMg4UTWkC8QcNHJMsHR4NXg0ccxwNHg1eHQ4NHBMMLw3wFXQODQ5ELg1uHR4EDh0eNB4NTh0_
FA0ONA0eJB4dDhQNHjQOVCMAMg4NVMIhQEQODUQHACIeJBcAEA6HB-0hTg1OLT4dTh0_HX4dTh1u
HS4dXi0uDR7NEC0OXQ49Dp0OXQ59Dj0ObQ5NDk3g-THQag4AphejMjMzMTAwMjM0M2oOHzZqDgEK
3yHwEE4GBCAPEyMe8BAeEx5wDjMO8AMOAy8bEx5QLnMuYC4kDyEuMAsPohMeQB4jHiAeAw0CACgT
Hq4PZhMeAB4NAwIAFS5vDxFOCABVDhATDQNRDztDDQMCAAF_EQ8CAAgTk-wPDM0XCgIAL-NMgw82
4a8LBB8VnxRPFV8UTxU-aA-xAj8VbxQfFa8ULxVPFD8VXxQ-mA8RTxwAAogPE18cAAAMAAAsAHR-
FC8V-xQDuQ9xVD4fFR4kLlEPQQ4kLh3-ARBENwIAow8QHj8CER0kAjAUDh12AjAORD4WAPEJJB5E
PjQODU40Ph0eLQ60Hh0OdB4dDiQ_QQJBPlQuDU8CEQ3SD0JEDh0uKCRiHQ4ULjQOUAAjNB4UAIEu
VA4tjh0OtDQAElQCECMOJDgAUcQODT40jgAyDT5EMAAAHgUBOwBQPjQuFB7UArANLkROpC4dTnQu
LXUAAacAAHkAkjQ_LS4kLi0uROMCIA50nwAwLhQurSQRHWMAEgRbABAuNgAwRC4tNgNjDh0uZC4d
exABiQChHkReDQ4dDg0_VCYAEHQGAAGLAAGrAAUIAFIELkQ_VHoDw54kHgQ_DR50Pg0uJKQAgh0O
dH5kHg0emABSHR5ELkQzJRA_JwUAtwXyCB4NDlQuNC4NHmQeHS5kDh0udB4dLhQOgwCRNB4NPtQ_
HQ40DAAC5wAABAATFAQAAEsAUQQeRA4dFgAAZAH-G9QODZ4tvj0uHU4tfj2_XT49Xk1uPV4tLi0u
LT4dDh0_TV4dTi3_Av3-UqACNiEtPH0eAwEAH4ZBGwscMjsAEPM1ANGJ9gPzB-ZK9x3wHQEAAgBL
8AQBAAIAUoD3AvADDABqF-ACFwABAgAxUAcQCAAzIAEAAgAxIAfwCQDQByA3AAcAAQcBJwFHAQoA
CAIAIUAHIgDxBAEHEAcQBzAHMAfgARAHAAEQBxArABQHDQABEQAFAgAQMA4AECeKADQgBxBUAC8H
0DsAEQlxAAIqAEoQB_ABqAAEGgAP4QABCAIABOMADhMBCzIBD1EBAY-wHvcd8P--DrIBDA-tATXP
MU4EDx32Hw4G9x8WAwCj8RUGDgY3Fg79Dw4WNwYODU8SDQ429wk2Dg1MHQwN-hsNDB0M-h0FAB09
AwASLRsAAycAAQcAXQ0M-R8MhgM3LjUzAQADUAFVMTcuODYBAB83hgMB-wMSEgQQ3xAgDtwOAA4M
3gweDNEEABqsLtweAf4AAQDxALEpVTUuMDgzAQATNJIATDUuMTaRABk1kQCvDA4EAJ8QAA6cHgIA
AC-_CWYAJhk0ZgCQGQoE9AUwhBeUNyuTdDeEDhAOdFdkBgDgIA5kNx8WdA4QDmQXHZQHAJAdtA4g
DvQFDhAFAA1gIC41OHoBNi4zMAEAHzPpAAECgwAwxBdUgwA8lDdkgwAwHxY3gwAwhB0XBwA-pB10
gwA-U7tOBBCv6gcA_gcCCAACshcTDwgAACYIgZ8UHxX-FAEvDwgAPwgEJQATT08IUG8UPxU-SgEz
Hg8VVAYCngcTNG4GAwgAIR5EsgaxxA4dDmQODR6EDh1rBwJZCiEOhHoHAOMHwQAORB4dDlQuVB5k
Ds8GUB4UPmQeyQdADnQOHZAKEB42CKB0Hg2ULlQ_VC40BwcBpwoQtGgA8Akdjh1uHW4dXi0_Lb4d
Pi2OHX4dLi2uHa4WAJEtTh1eLY4drhQYCxD9MhSwHhQN8KNOBA4N8KMYB2ENHvCjDRR5DSDwox8I
ERQIACENDggAAVYLEA0JABEuMgAwTgQNFwBhDQRO8KMeTS0DRgAnBA5HADMNFB0_AAMIAAAjCULw
o04UPAAjHhR8AAKFABAUWwwEbQADCgAQXikAHz5eAAMaDl4AI04UJgABVgASFFUAGA5VAFM_8KMe
DUUAAckAD00ABw2rAAFOACAeBIYIAT4AEU5kAAyRAAs2AQ4_ASMNHo4AEQ1xASJeBF8AA0EAAGYA
ExRSAAIIAAM4AADGACUODcYAQQ4ELg0wAACeDgVDABIUmgAEOwASHoMAHR5BABAOegAePjkABDEA
AIkJ8AAdXh1uLX4trh3_AS2eHb4-AvABDU4tLi1eHV4dvi1_LU4NPh4KISQO4QJgVB50LnQuexBi
tA4NHnQe5AIADgMSRFMNEg4PCoFEDR6EHg0eVIQAEDQgAwAIAzEEHlR-CiJkDhILEx0KAADUCRB0
DgADMwARVA0KATwvAS8AMi4dHgsKETSbDfEJAA0ODY49Ti2ePW4tnh0OHa4tji1_LW4doA0QLeIJ
zW49nh0_HV4NIP2nEEsGRzMuOTE_BQJOBE0yLjUwTgQKSwb0BfxcBPP-9g8bmw4jDpsOUw5rDlMO
DAAGBACi82oOuyO7Qw6LQwgAAwMAYCMO82UOyy0AVDMOiw4zCwASywMA9wDzaA5bDmsjLlsuIw5b
TiMNACYOawUA9QYDDvMO-hDzJg4DWy5bMx5bHjNbTjMLADQuWyMEAAFnJQACAPEOsx7zEB7zJmsO
a1NbU1sOc1sOAw5bU1tTaw5bDiMNAAIGANDzDQ6D-gADDoMe8yTrKwAwg1sjKABDyx4jWwIAFw4C
AEEec84DUh1osx7zIA4DMgAyux4zMAD4BFsDDvMIDoP_AQMOU14jHvMg2w5ZACUOM1kAHQMCAEAT
HoPuCACHQ54jHvMea345AAK6AAICAPEE8wcOMw5D-gNDziMe8xoOA1t_YykAA_UAAQ4BAuQAD2cA
ASATDl8oIjPeDgAwI-4ARQCgWw7DDlsOQ1sOc2kAAEUAAUEABHYAADYAAlwBsQMOIx4jHgMOM-4C
BQAiIx5vHiBbsxQCUKsOI8sePgBfI1sjyx6AAAMRM0YlEyNKAfIBM-4FIx7zFluzuyO7I7seYzwA
Ak4BQTMuAy4mADAuI04qAGAAAw5D-gWCACHzED0AMzsOs4oCgCMOmx5zDjsOSCoRIwQAM5seQwwA
GgMCACIeM1UABYMA8Acj-gkzHvMSXrO_I74jvoNeU14jXiO_BgBjM44DDjN_ewAyI-4FMAAACQEg
8w1KAfAAPtOeQ55DnqM_cz5DPkOeBgCDMw4DXhMOM14pABKuCAA1M-4IOgBilQ6DHiOuggEBRgEC
AgBAcw7zDAsrLw4DAgBtOG4zjr4AAXMBogMOkw7zEw7zfN65ABEjqAIAAgBBww7zC9kAgEMeex7z
Hg4r-wJYKw7zHL5FAPAIM-4EAw5TTjMO8w4OQw7bDvMbDksO8wYFABAaXQEiM75YAAICADBDjhNG
AAAOAbP7Ag7zGWvzBmvzGh0AIgNOCAARI6YAAUIBMGOuE4YAQDMO_wSaARGTMABiDQ6jDgPuWwAC
hQAAAgBiU84TDvMFWwCQBg6jHgMeoy6DMAB9sy7DLqMOAwIAIyNuCAAS7g0BEQBAAAALA4L7CA6D
boNOcz4AILNO5ikEQwFCAw4znjwCAgIAYGP_AhMO8woAgFP7CoNuc25jNgBHk26DbjYABnQAJQ4D
AgAAvwCRAw5T-gQTDvMCvwOUIw6rPqsOg06DRQAyk07zFwEAcAATQ94CHgNNAhGOQwBgY5t_m5Mu
_gABugCfky4DLqMuww4DhAAGIEOuwABTCBMO8wEaAHKLnosOkw7TaQFhww7jDvMHGgA-Aw5DQAAA
D4oAAAACABF_UQAAzwBke757DvMIhwEV8-MiCUYAKkNuYAAFAgDxAL4TDuMuQ3tOM0578xRrY2Ys
QOsO8xaFAhQNJQBFDmMO450BExMMAFAjey5zLjUAEFNTLmEO_wEO8xQKAA5_AAYKAALOKwsCANCu
Ew7TLgMOI2suky5rUQCQayP7A-MUa-MOfyMVD3gAedMOU2sesx4jABILHgAUDgkAQJ4TDsNMAKJ7
0x5LDrMeex6zLAAACwABNS0QaxstECNuA0MFHnsejgBDXhMOs9UActN_kw7bDpM2APIGkw7bHksO
I2sjDkse2w5DDqMO2w4zMwBAngMOs2kAUA57025zaQMWcwkBQHMO_wgmLlAj_wgOwxwAA8EBEE5n
AHBTDosOs25jbgPwBGNrU24jXmteYw77CSNuI-sJDqMXABUjcQIRk2IAUfsBHjNOcgMTUzEAQFMO
_woxADAKDoMXABVDxgASk8YAhB77BA6zDvsIMABAQw77CzAAEAu5AzMIDiMqASCDLlEGcvsGDoP7
CkP9AWFOa05T_ww-LmD7DGP7ClMrACJ_AysAUS77Bg5jQAMRM_0AcYNrkw6rPsvrAFHLPqsOQxwA
ExPUARBzMwAQPrYA9gibfpsza1Nrg2uTm36rI2sjq36bQ5t_m7cAACsAUUNO_wVDHQMRIywAs4MO
i56bI2sjm56LNQMVA3oBADAAYVNu_wIOM-8CBDEAk3u_iyNrI4u_excDFTNQBAAxAEFj7psz6QID
LwADDAASIwgAN-sOI10AUXP_AHsz4QIELQACDAAC9QIxI-sOGAEFAgAAMwAzk_5rwwIDMwADDAAD
FAADYAADBwIAMQABZQExvnsj1AIENAACDAADFAAIZwACrgEAawGFsz5rI2sO0w40AAIMAAMUAAdo
AAE2AAFDAk9rDsMeNQAGAOICJfsNawAyEw6jQQMRewQAA-8AAAoAlCNr8wBuI-sMHmIAISMeAwMA
yjITewYAAy8AAgwAAjEAMHv_BlwAEiPlAzGLs4sEAAIpAAEKAAInAEGL-gVD3wgBwANEDouTiwYA
BA8CIZObLACAAU4zDov_A0PKCBEBLAACRAsFCAADMAAADgARqzIAYQoOm-4Bg3cGAdwAEB6lAiWr
HggAMGsOQzIAAQ8AEssyACAeq6kGIfMFLwAy_woeBQAxew4zKQAj_wwmAEX7AQ7DcQEwwy4TLQAw
CB5DBQAgM4ssAEGTHvsLLAAQCywAADoFsPMCPgMOIy77Bi5DBQADJwAyLvsKJwBSLvsBsw66CTIj
DrN2AzAELmMFABFDKwBBoy77CSsAQQwu_wBRABADeABQPvsCPmMFAAMmADI__wgmACQ_61AA8QAD
DtM_Aw4zTttOg07bTlMoADKzTtsIAkHzDU7LTgAgBC6CCXCbXqNem15jVTIhDkvINEDDXps_4AQC
BACD8w5emw6jDhOpACDDPt4HwATD-gRzjjNug27T-tEEUm7zD-4AHQfB8wUuEw5D-gLj-gKDIgAx
4-4IIgA3EO6TsgKx8wA_Ew5T3vMD3qMmAFHzAd4DbigAIBLOSQD0EPMIPhMOY57zB57TblNOo07z
BJ4zTkNOQ07zFZ6TDhNGAGAGPhMe88IwCoMOPiMe87wOAwwE1fMMTiMu8_JeM-40Ay4CABQOAgAA
IgIALgIDBgsABAAGuA2x8xR_82IOYw6DDrucCwKxDYFTDmMO8wf_RUkAAuMwBUkDkiMOMy5DLmMO
u30MA0wAAMsNgUMuQy7zCP5BNgAHgQAChQCBQ04jTkMOW342AADSDQLWDZ9OM04jTvMK-kBsAAFx
U24DbjNbfvoLQx5bHkPpDcFuA27zeW4TTkNrDpMMDRGD0w1gbhNO83sezgsDVQ0BGQAxqw4zFACk
834OYw5jDssOIxoAEbvnAGZ_LtMeyyMuAIVDLvONLmNuaxMAYWtOwy7zfEQAI3NuSA0BGQAyW05D
WgBxe24DbrNbDhwNIEMOXQ4BjwABpgBgA24zDrse_wwAcgEAYQAQIxkAkXpOEy4DLjO7HgMAAC4O
ETMSADDzey6WAACrDAEEAAG-DAABBLFDLlMO838OUy5TvgIAsF5TvlMOUy7zj55zAgBsPnOe8-8I
LRRcMy4yNTguFG4tMTQuMDYsFg-FFxc3My42hRQXM3I1HzJzNQMoMU5PAAABABvsUwAZMKoAFTRT
ADgzLjWiEA-PNRBgFwA-IAAX1DX-CBcOUA4XBgANFw5wDhcNBgewBxYHDpAOBgACM7AHBigAEwA4
ABAQSwA-PgAX-DUJoDMuMDQ2ODI1MzkGABQ2tgDvMi4zMjEwMzE3NDYwMzOQFQLRDAwEwFdQBz8U
B1AHMAQAACkaUDAHAA4HBwCSEAcgVxAHIF4QHwBPV1BeEHsAKC8xMo8WADJ0FySRFkBkJwQnjRZR
ZA8WRw2WFiENR5cWIicNGABRFw0EDRcKAE4dJB1knBYPkwAiD28CCQ9YAI4H7UCwTvAVTiA_IP4T
ID4PQPAH8BMeEC4ALhAO8BcOEF4ADvAZDgBOEAcAAFE9T-AbDgAHAP9GAmUBEk5zARJegQEkLgCT
ARIQowEQIK8Be0D_HXD_GUAOAlUxNi4wNAEABNUEKDEygQQfNmUCEA9XADUADR3xBxINDx0N7rau
LT8SHQ72Fy4tDB4N9xrNBPADDvccJgcG9xg2HgYXBvcVJi4dCAAwGwYOBwCQHQYnBvcXFh4NDQAw
GhYODwAgGxYgAPEjJicGRx8MDxwHew8MS2o7ZzYnBkcKCwcLigsKS1caCwcGDxZVDxUGJwZHC-cG
Bg8WRXkOAPBLVwvXBglF6QgGFwZXC2cGCVX5BgUGhwYJVbkM_QEFBkcWCQX5BAz5ABU2CRX5BwEM
6RUIFfkDDFkMIQzJFQj5BQEMWQEMGQy5JfkFIQw5AQwZAUkBHAEpJekMCAABEQAgDCkiAFABGQUI
BTcAcSkMAUkBDAkcAOIMASkMaQUIBUkMARxJETIAYDkBKQwBWRUAcAFpDBEMKQxYAPMMOQE5DAFJ
BQgFOQEMaQwJAQwpDBEMOQwBOQxJFwBQeSEMKSETAIEcCQxJDAE5FRUAAGkAESkFACEMAU0AQQkM
AUkbAJAMWQwBGQEZDAETAAIPAGE5FSgFORzQAOABCQwBeQyZFSkFKEkBHIAA8B0ZDOklWRUYBTkM
MRkMOQy5RZkVGAVpLPkAFfkBBRgF_QcV_QQFGBX5AxX5BwgA8Q0AFfkKFQgViVX5DgUIFSlF_RUF
KBX5GwUIFfkdBQBDKBX5HAQA8DYRlTgV_QlluSgV_QB1_QQFCBVZhQk2JwX5BQUIVQkWHrcV_QYF
CCUmBwYHC9cF_QYFDjYnBgcaKwcLBwsHKxoOBWmlCSUgAhAHAgAgOhsYAJA6DgU5FQk2d2YUAOEn
Bsc1CSbnRicG9xk2B0QCEiYuAEP3FzYHCQARFhkAIxgmEADwZQYNDucWDkb3Bh0O9wAGDg0GB0ZH
NmcmDQ4GdxZXBg4dDsYenQ4GBwYOTQ4mRwYODQwOZg59jl0eXQ4WJxYeJg4MDQ42lxYOJoc2Dg08
LQYOLK4GRxYnBg4dzg0cHSwdDgbOBicOHf4CDQwdHA0OFv4CDf4FIB8DCwBBPRz_GjAfsgwN-hkN
DA0ADA0cCQDAPP4ZDRwdHA3_GhwdJQCgHB0MDc4NDg3_CWcf-QUdrj0uHW5Njg0MHRAMnUydXK0c
DSAZTTIuMzkNR28xNy4wNDG7AwrwMx4eBA8V-xQMDxUPFA8V9AoOHxQEDfQIDQQdFA30Bg0UHSQN
9AQNJB00DfQCDTQdRA30AA1EHVQO3Q5UHVQNDr0ODQgAEd4GABHWBgA-BrcGCAAxAWIAA28AA30A
A4sAA5kAA6cAMA70CuVJawwe-Qz_DxYBNTQuNBMBJjE0gh6jNTU5NTIzODA5NTMHHzcUAUYh3yAH
AD8MsAwIAC0PFQG4BA4ADwgALR-eFAFsDk8HD1UAIg_BDB4KmSQNZAwv8PAxABkSM29FBgEAHyM_
AAUPrgAj5DIuODY3MDYzNDkyMDYymwSDLTcuNTU5OTIZAB83ZCUB8SoQEARAHxkZHnAOeQ5ADpkO
IA4JLxQOGQ4tCQ4QCQ0OeQ4NCQAO2R4pFzkXKQ4pBx8VBxkHHAdZBxwIAP8YKQ4JGBc5FxgJHjhZ
OA4AOFk4EA4YGT0ZGA4gDpkOQA55DnAeGR5A7QALHzaRAAzwELkOENkADtkOTxUPFgUPFQUdDxYF
DQUNHh0MBQ0FDg0GADINDhkIABAJBgBBHR4JDhUA-wMJDg0FHS7ZDgBJDxR5EA5JKzmYACrwFGAZ
wA8ZGg6wCQoHCaAOCgcaDpAJBwoHCglgDgkqJxoJDhAaDwBwRwoHKg4JCgsAMCcKBxcAIQ4JGQBT
BwoJDkAMADUJDlAVAFBADhoHKgoA-xQOMAkKB2oHCSAOOgkeCToOEAkaCQ4wDgkaCRAKCQ5wDgkK
ALMAHQBJBBHABQDzFA4fFA6gbYAOTQ5wHR4NHh1QHRctFx0wHQceBw0HHgcdIA4NCwD-GQ0OMA4N
Fy0XDQ4dEN0eLWCdAAIPGAIAXQ5NDAgMXQ4AHp0eQB4tLjCMABz-RBACHxgCMAIeAiAOOA4QDjgO
AA4IHw4oHlgOGB34DA7YDgIOuA4SHpgeAg8VAh54HgIMABIuOC4SEAwSfhIMIAwiPiIMQAxyDGAM
UgyADDIMsBxgggA18A8eCB2YDhgOqA4IHggOiA4IHgIOCA5oDggeEh4IDkgIAACTACEIDgIAcR4S
DAASPggmAOICEAwSbgIOAgwgDBIOAgIAMQxAIgkAPxJgcqcAI-IhMA8WBjcGDmAGdwZABpcGIA4G
lwYOEAYHBncGBwYQBwYFHxUGFwYdBQYHEAYHPRY9FQBBHQUWBRQA8R4WBxUOFw4VBxYQDhYXBh0G
FxYOIA42FTYOQAV2BWAWDhYOFnAOBgUWBQYOcAV2Sj8F8ASjAAwPkAQcxS0xLjM0MTI2OTg0MY8E
VzExLjkzrQUPGiwA8AUQoAT3FAxRDGcMcQxXEQ8QNw4RVwIA4A4BDjcMEWcOcXcOYccMEAADFQD3
BQ4BDmcOUQ6HDjEO9wUmBwZXBgcmQgAYDkEAAywADhoAD0YAA_MTgQ5XDoHHDhG3DBEOpwQAobcO
AQ7HEQzHEdcCAC-3B3QABu8BDlcRDMdxDGeBDFcRDG4AD2IOgVeBDldbAAE4AF8OcQzHDusADcAV
AQ43AQ5nDBE3EWclAPAAEVcMEQw3EVcOETcMEVeRwQATDKwAX9cBDvcDrwAENA4BN_EAUBEOxw4R
egBvDFcOAUcOfAAAD0QADgwEAJQMlw5xDleR9xM6APIIFgwBDrcMIacMMZcMEQ4RlxEOBxGXHhen
AGIRxwwRDIcyAAWwAIMTDA5RDgxXkWwATxEMNwwGAA4BKgAhkVc6AAVKAAypAtQ4LjM3NTc5MzY1
MDc5QQhUMy45NzEKEg9mFALwCRYYBAD-EwQADvMEHv8bBB4NA-AAAw0eCwcAEwsOALAOAwsN8AAN
CxMPGggAIgwTDwCfAw0MC-AACwwdBwABFA00ABkMMwAfDmAAAUYe-QQemjIFAgAF5jIGAgBLEx7z
BIEXAgIAD-YDCxw38wCJ8DX-IABgDgACAEnw6A4AAgA5cA4AAgBfUP4A8GFqACEgUP4DAAxwAElQ
DvAUBQAfAH4ADQUDAA_HABsAigXxBx8bOx5QDpsOIA67DhDbAA7bHtsO_zAHAO8A2xAOuw4gDpsO
UB47HgdMGgBaAPEHEz8bE1ADngMgA74DEN4AA94T3gP_MAcA7wDeEAO_AyADngNQEz4TWgAd-wpA
XxNwnkC_IN4Q3gD_UADeEN4gvkCecF5ASAAZ9SY8LgT-ICZQ-idAHvAjLjAe8CQuIB7wJS4QHiA_
ED4QLiAuED4APiAuEC5wLgAeIE4APgBOAAYAQHBOIB6HVFkQHgAeAAoAYABOcD4gThAAEjAYABNO
GABmHnA_ID4gGAAmPhAYAC8eQEoAAQMcABEwdAADGAAWThYAAKQAAbFUAZdVABYAQPAoPjC5AAAz
ACE_EMEAEBCsFQCzAAEUAATBAACJABEwYQARQLxVBncAVlA_ID4QGgARTsEAaj4wPjA_ABYAjz4Q
PjA_UB4ARgAFAHQAM04APhIAAj4AIk4goAAPGAAAg-AoPoAO8AEuFgAQPhQAIHAuYAA3ME4AFABC
YE4wbrwAAnZWYlA_UG4gbrQAARIAAJYAZ24wTkA_ABIAEGCUAEcucB4AOABUgA6ADlCkAAFuACDw
AJ0AAg8AsE7wJx4ALvAmHhAuFQLwAS7QDkAOEE4QTvABPhAuwB6-VDEAXvBQABDOdhUBAgAAiQGA
7hAeEL4QbgAjAABqAGD_ABAe4B7jUgQTAGDwAR4QHtANAAM0ACDwAkUAA1QAEiBBAAJnAe1OMO4g
HvArHvAr-idQ-tsFAKZYYDA0NzYxOQYAEzLvAmM3Ljc4MDUBAC82N58aJRM4VwA0MTkwY1ByMjIu
NjEzOAEAHzlZAAFgUwwEAA8YHQ0DBADxBQ8Q-AANIAMvGwOAAxsDMA8Z6QoAlwoDBAD_Ag38Ag0A
A1sDUAM7AxAK_QEKHQC4ewMwAzsDAAr5ARodAMEdTA08DUwdAAObAxAgAEg5BMoEIQDyAAFNAQ08
DQFNAQADOwNrE0MAJwQAIwDhEFENPA1REAM7I6sDAAR_ALBIHjgeSA4QDfwADVYA8wAPEyOLAxAE
ugQ5Ch74AB6SAGI7AwAHM2uwAGUPFR7YHgYZAEIgBzNLrADwLwAGHjg_OB4GEB38AB0AExsTQAcz
GxMAGukaBBAGXhZeBiAB-QIBAAczB2AHQwcABPoBBDAWHhYQFh4WQAH9yDS9EweQBxMHIATqBBAV
MTQyMTcXEBQ2ZBcAzFolOTQRAh83UzoBC3I08AMXDw74GQ0XFhf4GxcWFxj3FxgHAH8HDxcHDQcI
AgAGcQ0HDAcYDQcsAEL3Ew0YCgBkBwgNJwwHAgATDQIAFAwCADMnDQgoAEIYDfcTCgBPDRgHDGoA
DwaaAAGmABENsgADwADxAw0oDWcIDUcIDfcIFhcYlxhHGAkAsDcNKA0HGAcYBzgnqQBABw0YDSsA
ERcxAHAHGB0IBxg3FABAGA0IN7kAACMAQAgXFkfLACAIBxIAQRcYFxiaABENEwASSB0AADkAJAcY
HABiGAcYNxhHVAAABAAQCAMAYhcIDRcNOAwAAIcABqsAD2oBAS8NOAABBjMNBzhkAXMHKA33DQ0o
DQATOF4BDjAAAC4BEzgmAIUIDRgN9wsNGHYBQggXDQiKASkHDQIAAhQAALkAAioAYicM9w8MJzUA
4w0nDHcNKA0MDSgNdwwnjwChJw03DAcMFwwYDQIAcwwXDAcMNw0yALEIJwwXDQwNFw0IDBQBMQwI
DRAAJAwnXwCVCDcMDQwXDQgNBABVDA0MNwhAAFANJwwnDLABhhcNGAwnDCcNOgCXlw0YDScNGA2X
LgBAhw0YDeABF4coABFXcAIAngAAkgIWVy4AMAw3LJQBNjcsN5AAtg1nDFcNCA1XDGcN9gA2xw3H
8AAHEQEPRgEWDoEBD7gBEwnrAQ8eAhIPGwMFAKMCMIcI9ywAACEAATcAAFQAQgcNJximAhEIjQMA
hgOOCA0nFhcoBwgCACIXCDoAAw4AACYDMBcIJ1QAATgAIgcIYAACDgCAJygHGA0XFtd4AKEGFscI
DXcIDfcGJzif9h-_IR8N-h8bAwAE-wMLDxL7HwoA_h8QC-4dCxAK_x0LEg0PPhwAcB1-HS1_DQ4a
MqoNPi0PEg38Hw0OBAAfHgMAAQAZABcOLQASHQcAAB0AYkwyDDIsUgQAkkwODTxCDEIcUgQA8AM8
Dg0sIjwSDCIsEiwSDCIMEkwMAHAeLBJMEhwSFAAyHBIMDAAPFAAYcD8VDDsSDFsFAJBLAgw7Eiwe
PEsKADACOwIHAPEHWwxLAiweLCsiDBsCKywbLBsMKwwbMg0AsQ0OLBsCDBIMGxwbGQBQAhsMG0wH
AAEaABAyGACSDBIbEgwbEhsMDwABGQAvIhwZAABTHiwrAixJABIcSABAKywdLIUAE1sUAIBbDEs8
HjwCO5EAAhIAIUsCnQAQXHkAE2ybABBMmgBzDg0sWwwbTMMAMUsCDJYA8QAODSxLAgwLAkxbDDsC
HFt4AACFAfALHowCG0wLDAscC1wL-AEejAsCHAILAgwLLCuQAKMCHAucDQ6cAgsMAgAzHAscCgAR
AgQAYIwejBsCDDIAEQIdACACGxwAMywbnOgBCgkCLg4NCgAfHgkCAQAfAPAaHaxN3l2sDQwNfh0M
8gcMHW4dDA0rIgwdLv0HLh0MIisdCxIMAgwC-BF8ADESCx2EAA8CABZPCx0CDAIAGhEdbgAPAgAU
HxJeANoPegEdArkBD40ADg-YASNfDQzyHwzMBBnFMgsEAPIeIALxHgIQBQAPDwAML-IeLwUMHzXh
GR4fMTIALALZGvYkGAiQCA8YkAjwBRhwGB5wGPAFKFAoLlAo8AU4MDg_MDjwBUgQSE4QSPAFuF5Y
8AVY-gEIBgAlABgGACPuKAUA9ET-DgnwBD0gTQC98AQdUD0QvfAMLSCt8A0dMK3wDQ1AnfAHCLBd
8AkYsG3wByiwbfAGOLB98ARIsH3wA1iwjfACvVCN8AI9MD1AXfAGHXAdMF3wFgMA-xsK-QLwDE0A
TQBN8A09ED0QPfAOLSAtIC3wDx0wHTAd8BANQA1ADfD--x8vDQAGAQAWM4oNCJ8ND48LAAIjAf8Z
HRhACEAPGPAOODAYMB7wDFggKCAu8Ap4EDgQPvAImABIAE7wBvgCXh4BEPEOBG8OUM3wA11wvfAC
XZC98AFNsK3wAE3QreA98AAbARKNBQAkBhgFACQFKAUA8DEBHfAArfAAHeC94D3A3dA9sO3AXZD9
AbBdgP0CsF2AXVBdsF2QTWBNwD2wPXA9wD3ALYAt0B3gHZAd0B3wAA2gGgEfExoBOvAArxgfGPAX
OD7wE1he8AkY_AAvBzgcAg3wCk0APSC98AQ9EB1QvfADLbCt8AMd0K3wAg0CAUEUXfAXAwDxBwkY
sF3wBziwXfAFWLBd8AQN8ANd8AMGAPAGAh3wBF3wAT3wAl3wAG3wAV3gjeBdMQ8fJd0AOv_F1wgP
GPAaGB7wGCgu8BY4PvAUSE7wElhe8BAIzvAOGN7wDCju8Ao4-gDwCEj_AfAGWP4C8AVYvljwBki_
SPAIOL448AkPICheiA3wCC0YPj1YLfAGTQgefShN8AWtCA6t8AaNGB6N8AhtKC5t8ApNOD5N8Awt
SE4t8A4NWF4N8BUd8Bo98Bhd8BZ98BSd8BK98P--eeEAOhHR_QMwDvAO_AMwHvAM9wMwLvAK9gMw
PvAI9QP0Ik7wBlheWF7wBbiOKPAFqJ4o8AaIrhjwB3i_GPAHDyBYzggN8AYdSN4IHfAFLSi_KC0H
AIIGLRi_GC3wBwcAgggtCL4ILfAJBwDwFwotvi3wCz2ePfAMPX498A1NXk3wDk0_TfAPXR5d8BC9
8BKd8BR98ANAGD3wGvBDH373ADoU1rUCANABExPUAZURWF7wDxje8AvQARcH1QEE2gEG3wHzCgdI
Th8gTkjwBh04Pj0_OB3wBT0YHn0eGD3cAf8QBZ0YHp3wBn0oLn3wB204Pm3wCE1ITk3wCx1YXh3w
FNwBAQ_9AlT4BFh_8A5YnvAMWL7wClje8AhY-gC8AoBYnljwCFh_WLwCMFheWLwCIVg_uwL-GFge
WE3wBV1YXl3wBl1ITl3wCF04Pl3wCl0oLl3wDF0YHl3wDl0IDsMBUQHeADEbCA7iABMZ5gATF_oA
HxXbAQDxEguobljwBoh_SPAIaI448ApInijwDCiuGPAOCL4I8ApfINYA8BJNSB1OTfAIPTg9Pj3w
Ci0oXS4t8AwdGH0eHfAODQidDg3bAP8JEU0QTfARPTA98BEtUC3wER1wHfARDZANwwE4D8wHATMx
LjhAAE8tMy40NAgBAhsBDvgpD0AABx8xdgAiCh50-wQFBQQQAiAiAAECAQIBEAEgAQIBGQ4NHDNB
AJABAgACAUIBIgFGAD8gARBAAB1vACIAYgESfQAkIRACNwAEfgAfAn4AHgN4ABFCAgEApkgPgwAb
cC08BDAN9hMxMCH3Fd0vEfcuMID3GQYADfcbDSorDwMAEfEUZw8XDw4PF2cPDgIOJw8XCAxnDgIO
ZxZXDB4IDEcOIg4HDCgIAMFXFkcMLhgMJw5CDkgGAPACRxZHPigMBw5CDxhoDAcOUggRAIE4DkIL
iA5SCw0AgUgLIguoCzIbDQBxWAsCC8gSOwwAYWgL6AsIKwsAL-gJCABSgAwu_AkbCA5H2ADj_AkL
CA5XFmcc-gkIDmcHAQ8DAA0QBlQBEABeARIQagESIHgBEFCEAQ-rGgwfNLkBQvA19xsWxwIOxw4C
xxa3DiIOhw4iDrcWt1IORw5StxanDnIOBw5yDqcWZw4XDvIFDhcOZxZnCA4H8gcHDghnFmcYDvIH
DhgJACDyCQcARijyBygHANA4kgiSOGcWZ0hyKHJICAAwYkhiCAD5C1hCaEJYZxZnaCKIImhnFmd4
AqgCeGcWZ-gNBQBFDvgLDgcA8xB3_At3FncO_AkOdxaHDvgHDocWpw74Aw6nFtceqB7XywAPdwGE
-yl3CJcIDxiXCKcWdxh3GB53GKcWdyhXKC5XKKcWdzg3OD43OKcWd0gXSE4XSKcWd7heWKcWd1j_
AgYADvAz-w4ICJcWd0wXTAesGIcWdzw3PBecKHcWdyxXLCeMOGcWdxx3HDd8SFcWdwyXDEdsWEcW
hywHCBcsZ1ynFocMBwwYoBWAZ1wIlxaHHCgXAOAYhxaXOLdcKHcWh0i3XEIAMFi3XEAAUbxXXFhH
YgAyR1y3WADzNlzHFvcHXNcW9wZc5xb3BVz3ABZ3-AL3ARaHTAdMB0z3ARaXPBc8Fzz3ARanLCcs
Jyz3ARa3HDccNxz3ARbHDEcMRwz3ASMBD7EBexOHsQEylxaHsQEylxaHsQEylxaHsQEylxaHsQGQ
lxaHuF5YlxaHeg0IBwAnABgHACXuKAYA8CQfDjccN8yHFoc8FzwnvIcWh7wXvHcW9wisdxb3Caxn
FvcKnGcW1wi3XJcWxxi3bIcWtygGAICnOLd8dxaXSAYAkIdYt4xnFoe8VwYAAZMBMacWh5MBSbcW
9wiYAXKH-AL3ABaXkgEyABankgEyABa3kgEyABbHkgEyABbXkgETAAQBD5IBewgDADDHGB_WATDX
FqeJAUA_txaXiAElTqcIABCHOAwVlwcAILiOdwHwAaieKJcWl4iuGKcWl3i_GKeJAUBYzggc_wIh
SN4IAFYsKL4oLAgAdZcsGL4YLKcIAHWnLAi_CCy3CADwF7csvizHFrc8njzHFsc8fjzXFsdMXkzX
FtdMPkznFtdcHlznFue8UQEgAJzpAvMHAXz3Ahb3Alz3Axb3Azz3BBb3BBz3BdUAD3UBTg6fCQ87
ABMOmgkPOiIMA2wAH_YFDAIPDwsQHw4PCxcP6gsPCqkAHzHaADEAtRIClBEAthIBlhEAtxIBmBEA
uBIBmhEAuRIBnBEfBZwRUfAQDfABrfAADfAAveAd4N3QHdDtwC3A-QGwLbD9ArAtsJ0RIC3AnREg
HdCdESAd4J0RUA3wAB2QuBIOnBEOCQEfMjoBHg8xAL4P3A4MEQujFACoFGAGqF5I8AcFAGAImF44
8AkFAP8LCnhuKPALaH4o8AxIjhjwDTieGPAOGK4I8A-1Ak4fM3kVm1AfIPAEHXsV8Acs8BNdTPAR
XVzwEF188AL9AozwAgxNAgBQTPAGHD0CAFE88AcsLQIAQPAIPB0CAFAc8AlMDQIA-xsM8Ar8AvAM
TABMAEzwDTwQPBA88A4sICwgLPAPHDAcMBzwEAxADEAM8P90DQYPlRVxQAEPIED3AyEBDAcARQAc
MBgHAETgLCAoBgAPoBUO8RFcXbBdgAxNbE3APZAcPXw9wD2QLC2MLbAcHRyAPB2cHQkA-x1MDawN
sFyAXFBcsFyQTGBMwDywPHA8wDzALIAs0BzgHJAc0BzwAAygDPD-BDYBDA_dA1wPMQAeZGRkBP8Q
-wEAPeIMHgIAT-43DB4CAABP-jQMHhcABEsPHB4NAgAAGgBPMQweDQIAAAEzAA8XABYfDUkAm18Q
Df4TDBoAGgAcAB8NHAAKHh4eAA8cAA4AHgAfCh4ADg4gAA8eABEAIAAfByAAEg4iAA8gABMAIgAf
BCIAFg4kAA8iABUAJAA-AQ0eJAAYDiYADyQAF28NHgzeDR4lABsOJwAPJQAYbw0eDK4NHicAHw4p
AA9OAAMfFk4ABD9_DR4nAB8eTnUAD04AAh8ZTgAEP04NHicAHx5_dQAPTgACHxxOAAQvHg0nACAe
rnUAD04AAh8fJQABHw0lACBv3g3_Ew0eAgAMT-4iDR4jADBvAQ3_EA0ebABTIQQNAgUPbABSIwcN
FAUPbABQJQoNIAUPbABOJw0NJgUPbABMKRANJgUPbABKKhMNIgUPawBILBYNPwUPawBGKhkNDgUP
JQACHxsQChn0KyAgBPC9B-AOJ-AMR-AKZ-AIBwBHAAfwBicAJwAn8ARHAAcAR-ACZwBn8AJHIEfw
BCdAJ-AGB2AH8As1AC--gXAAGQ5ODg8lERgTEFoc8gARSB8OTvARSB1O8BE4PT4FAFALXShdLk0O
MChdLk0OMBh9Hk0OMBh9Hk0OPwidDkIRWw8xAP9Sj2RkBBwfEBweAgAbPwweHDIATk8cDhweMgAf
D8oA------------------------7Q9qVwAGa1cmNjOLXYA4NTE1ODczMAYAD2xXAvIUZGQEJV8V
9Qr_DaVeVV5VDjVe9Qr_DLVeVV6lXvULzV4dTsUMAPAACt0_PT7VXlVeNQ5VXvUJDgDwJOVeVV4l
HlVe9QjdTh1O9QBeVV4VLlVe9QWeXb71AV5VXgU_VV71A75NvvUCXlWuVV71AgwAEgMMAPEcAb5d
nvUFXlU_BV5VXvUATh1OzfUJXlUuFV5VXuU_PT7N9QpeVR4lXlVe1Q4AEQueAKBVXsVOHV699Qxe
sABRtf4M9QoKAFGl-g31CpwAcVVelf4N9QuaAHFVXoX_DfUMlwAADAAxDPUNlQAADABCC-UOrgoA
Mwr1DwoAMQj1EY8AY1Ve9TIuFQkAIx4lCQAiDjUJABI3BwBpMf7-gfUwEwACBwBBNQ71MgkAIyUe
CQChFS71EA8W9wcMhQ8AYgU_9Q-3CQ0AVK71DvcKCwAyDfcLCwByPgVe9Qz3DA0AoS4VXvUL9w2V
XlURATb1CvetATUJDPeuAdQNvwwPHDcPFx8ODxc3twF2Dc8MNz8ON7oBAxEABr0BABEAAzUABsQB
hwQMlw8cTwy3yAE1t0u3yAEADAAEyAGFt0sPHJcM9QTLAQROAETLDfUI0QEAcwBEyw31CdMBIDc6
DwAUCtQBkDcPFxoJNw8cu7oBAN0AYrX3DAz1CdsBF-fbARf32wE2DPcM3AE2DPcL3QE0DPcK3gE0
DPcJ3wFvDPcHDPUQ4QFFNhH_CN4BJP4K3QEj-gsKACcN-tsBJv4N2gEX-toBD4cDAkQMvV4VhwNG
C80_NYcDEAoOAAXKAU8JzU4VhwMuNhVO3bYBRj41Pt20AQEOAAWzATBOFV6VAw_HAwIPoAQ6uyG-
EAEOAQ4BviG_CABVDiHeAd4EAAwOAG8OAb4BvgEIAABTMc4BzkEEAJ1xDhGuAa4RDiEIAJsxHhGO
AY4RHkEIAJuhHhFuAW4RHoEIAEHhHhEumABPLhEewQwABDCBLmEOAE8uER5hCgACzwFOYR4RDgEO
ER5hbgoAAHfOYR4hHmGuBgCdfiFeYQ4BDmFeCAB4PhFewV4RLgYAhwFOEV6BXhFuBgB3zhFeQV4R
rgYAUf4AEV4hGQAFBgCH-gARbiFuEa4GAHfOEX5BfhFuBgAxjhF_PgE-fhEuCgABnDF_ES4hLhF_
IQgAEJ4eARAhHgEf7goAAC-_AXsAAFeOIY4RbgYAeI4RriGuES4GADYxziECAB8ePQICAggAFw4z
AjveAS4OAA8-AgJGAb4BLkECT0HOAS5BAgNPEa4BLkECAQEIAB8uQwIBAQgAAC0CD0MCCAUMABoO
PQJcUQ4fHA5UAgpAAlxRDg1MDlcCEzFLAnZRDg0sLiwOXAIGTgIAGwBYHiEeLA5jAhGBVwIQsRsA
ghEMDQ4RHiwOagIR4VwCEnEZACEdLBoAAnACEaFkAuIxDg08DhEMHWwOEQ48DngCEnFrAgEZAIMN
nA4RDg0sDn8CEw75AXAMDjwOER5sbQAjLB4UACEOMX4CIDE_GwABbwAiHC6RAhZxfwJxDREuPA4R
Lh0AAZcBBBkAFQ6IAiAMHiQAESEiAAaeAgDrAQSMAnAMAS4RLjwtIAAYARgABZ4AVV4RLkwupgIT
DpwCZQx_ES4MLqsCEw6hAiQMnqgCQRGuIQ6kAmEMviGOAS4LABUOowIhDK4JADtuIR7zBIcMzgE_
AS4hLvgElAx_AT4BHhFOERUABLACkAwBXiEuAT4BPu4BBRYAAgUFMH4hHjQAKQEuCwUgDBEtBDE_
AV4vAQIUAAgPBTE_ES5qAA8TBQEAdQIPFQX--3kvYS4SBQsvYW4PBQUvYa4KBQEMCAAbgU0CBP4E
CFECGqFLAgbuBAgGABsO0AEH3gQIUwIH1wQPCgACD00CAgzMBA8KAAIPsgk6cQ8VIg4CHgIEAPAG
Iq4CDjJuAg4S-gFC3gJOAg5SDiIO8V2xEj5CHiIOMg4CDjIQADMyDkIaACACLiYAMEIOAgQAED5H
AIIyDjIOEn4CDlMAEQI2ACACfigAAwIAQi4CDiIsAAEUABRCJAAhnhIIAABWABESegABFgAkDiJq
ACMOIioAGCI2ALEOcj4CHgJuMr4CHloALa5CJgBAIg4CXlQAAAQAIEJuEgACDAAhAg7WABJu0AAx
Yg5S8gABhgBQLgIOQi7AAEQSDjKezAAAUgCRUv4GEh4CDlKODwAQLikAJhKOcQAXEskAAF8AIQIO
LgADcwATIgQAQTIOMl61ACIOIiQAAF8AUE4CLgJ_LAACdwAAuwAgIn4MAAEgAAASAECeAi4CngED
SAACuAEQUhwAIp5CCAAULr0AFHIiAAOKABECDABwAj5yDjIeAgUBET4aAALGABVeIAAhfiLZAVAS
-gICLsoBRgIOMn67AADoAQGWARDuWgESQqMAEh6jABkyuQBgUq4CHgI_TQBDEg4CTuoBIi4CMAAB
UAASMgICMg4SnsMAAmYAERIGAAIsAAAMABMyegAAJwETMigAAcEAAGQABKABBBEBFW4uAGL_BAIO
Mo5xABFSUQAwEv4AHAAxMh4yuAAAeQERUmwAIjIOTgBCIg5yLlwAAxIAAGYAEM4GAAECABA_agAR
Uu8BUAIOIp4CvwEAeAJhjgIOEm4SUAAEmQEgMs5OAAJUADUCXhLWABESXAARMggAJBIOWgAxMk4C
PgACKABAAg4ijv4AIiIe2AARMtwCA-UBEG4gAACeAALpAVFCThIeIg4AMgL_Aj8AEmKBACJeMkED
UO4iDhJ_BgIgMi6JAQAaAgExABGuzwJA7jIOQoMBIE5CoQEEkQAQLtMAAucBIjIuzwEBSAIRHhwA
Ih4CDgABBwEB4QAhDhLPAwByAACDASQCHkoAAogCBgIAEhLQAgEMADQijjJAAAENATNyDhIiAAA5
BBEiAgATMvcBESIIAEASDjJ_UwExEq4CygACDQIwIt5CZgARXmcCAqEDEn4fAkMS3gI_3wMQDsVi
ESLHAwBiACACLkgDAEIAArQAFTKrBAOZAQOWAAA6AALXAQHIABEe0QEUPuAAAToAA6QAAgMCAZ4A
Ew5MABG_LAABAAEG2wESEnQDAfgDIjKuXAAC5QIVEigAAjMDAokCEVIgABEyVAFBaA4CnigAEh6U
AQEsABL_TwABLQCQEg4ITxgIAk5CkgIjzkK6BQAxADEyjgIIAADQA1IIDUgSHtIAIkIOOQAxQh4C
DgQEAgAREuQAAR4AAA4AEG4zABM_7QRhrgIuAk4yGwBhIg4iPhIOWgAhLgIkBBESXgADxgAABAAE
BQMCUAEBkgMB1wIAFAAnQm4xABNCMwADawEEDAABSwABWgAR3hQAARwAMBJ_aO4EEyIsAREiCgIS
EjQBBEsAgC4SDmlnbw-uIwERDXwAIh4CBgLwBF4JTxkJB0YHDw9PHw8PBB5CDjIEACMOAkcAFSJ4
ACISPigE4gkPGUkHBkcPDw8fTw8UhQAgHgKYBQEOAyICPi8AAVICABAAIS4CsAEMNwABWgATEuUB
ATEABd4AMSIOAuAAESJvAw85AAATMi8AIjIuqQAiAn5xBwKtAB4CpQAwQl4i7wQSMjwAFD7wAZAi
fmkHBkdsFG4LAVISHlIuUs0AAlUA8AAOIq5qdwa3bxceEh4yLhLfBCWeIqcABOwD8QESDgpJCgd2
V0YHC08OCw1OnwQAPwcSHgQBAQwAIS4SOACxCglKBwb3AwsFSx1GAAKeAQEYBErOUv4BHwAELwQU
MjsCAUUHJ1IeJgABrQYUUvkAEU67AgBZAAKHAQgqAAFYAQBvBBJChQIDNwcA8QJRavcFax00AAGP
ABIeMAgBpQIBfACwMi5fGW8LZ28NDn2zABDOlAACqAEUQnoAEn4QAIBPGQ8LTxsPC3kBkg1PEg8N
DxIObQUCIB5CzgEDZAACpQIAzwNyEl4PCw8bTzIAgw8STw0fEv4DnQAgPkIzBz3OMg4jABIexgYC
8gEAkwITIpMHBZMALh4CNgAUXvgBASIAEC6xBhMiLAADbQEBHAAADgANPAABrwATMnAAALMHESIo
ABMCAgAhEo5UAAHXAAErARMfhQECNAASbuUHJAIOggICrgCTIs5fA28MDn8STAAAiQcE4gURImkH
ANAAADoA4DIeTwMPDE8QDwwPEA5vjgAAbgk0Au5CPwMSnvEBIAJuIgBhTwwfEP4FegAAPAAzDlI_
pgABiwEFNAA0DkIOLgAD-gcBDQETnj4CABQAEL7eBAMdAQYtABMCzAABUAEFWgACVAAANwAkMk7K
ABMCUAkGOwAC3gMDBwEkAh7-BAMGCCEeAmoAQwIOIk4jASAObzcAARMIEp7oABeClgYVQsABM0Ie
cw0IERKSABMCVwBEAg5SnoQBAAIAQhK_Yx4MCCIS3q0IQCIOIl6uAAA7CAIgASMCngwIA1oABFIA
AUAANI4S3vMFAR4AIw4ihAADHwoBRgIAuwQC6QAjAm4yAgImAAAQBANmAhMCQgADIAIxDiLeeggC
GAABJAABQAAPAggBBBwAA7IAEyILBgAUAAIUARgyDAghDkKSCAOmBQJuCBBOCQYQAMEBBxEIEp5D
AADzAAJLABUSCgYPFwgGACAAAGYKAnMIBQUGExLUAQIkAAENCAE8DAB6BwB5CAOoBAwDCBTOEAAS
EjoAA3UIAVsBMC4yPtUAA-8HIT4yPgASMjwAAYkBBFIAABAAAN8AEggbACMyHsIHAQgCIBKeewIT
AmEAERJGBCMiDg0FAREIExLYAQJ0CDJSrjJcCADsAgJGASOOMtMAAZkAApEAAy4IIELukwAAWgAQ
IgwCAXYKARwEIp4y2QoBjgEAqwADKAAANQsSzqwHApIAEXK0AAIhAxMC2AECVAIGRgYB6wAAawEC
DAABrAwTElIAEgI2AAUEACNSjqgAEC7sAARdDAAgAgZIAjIinhKZAQEiBQMEA0AOUv4HqwADqgEW
HpYBJzIOSwwiHhJNABXuUgYElwADxwAVAmcAIlIeHgAFLQEFUgATIioAIRKeQgAhDjLxAAI2AABb
BRQSEQEAFgASHhAAABwABNsKAIIAEwL9AgI5ASMCDnEBAQ4AIRI_FQMArAkAAgkQvpEOEwJ4DAFD
AwBpBgURAURSDkIeLgoA-gAQUggDEq6sAAAEAAQJAgWyDxN_0gAA3wFT-gUCDmKlAAKLAAJXABMy
6QAREgwAE2IYAAISACESLhEOAVsHJCJuLAATAm8AAI0PARAAAXUAEwIYABUSQwERMsQCExJaADNC
DiJBAxMyzwARIkENI0JeewEBZgohUr7XAAFcAAIfEALzAwJEADAi-gA-ACIC3sEAAiIEAn8AABAB
AqEAEzKBAAUgAhEuzwAPiRE6jxgCPxUCKAI_BAATTyIeIggEABZvDxgSDUINBAATfyIOAg0SLQIG
ACkfLgQAGF8_Ai0SLgQAGD8NAg4GACkXIuoADwoBDgZBAQ8EAA8FmQEPBAAQEDiVDA8FAB9PKAIt
EgQAFwCLAQ8GACsfLgQAGF8_AigSLgQAGACRAQ8GACsfLQQAF18CHgINOAUAIAayAQ_PAzsHZAIP
jgP-------------------_3Hxj_Ezpi8YoPECEOAgBzkQ5xDkEOwQ4AABAAQ0EO8VgNAAM7JwEM
AGxxEvEBGBEVAPAADvEeGAJRDkEOIR8OCPEMCQApEzE8AAQrAGtBGPEBHQEZAFTxBBsD4QwAFB0J
ADYHGyFDABJuQQB3wQ4RDhEOYRYAgBEZIQ5RDvEFdycxDvEZBwBUERoJ8QckAFIOAVQBHj4ABxUA
oBFDAR4BGhEO8QwPABBkEwAxgQ5BAgAQgR8AEFMSAAAGATKhDgECABJ0RgAZAUYAFGNbAIDhDpEO
AQpJJA4AYfEVDhFLIwoAEQorABARGQAYHmQAARYAQg8aSyMXABEB0wAwIQ6xRAAQFGkokEET8Q4O
AQxLEw0AAqUAAEcAEAQPAAECAEEbA-EFRwCCAQ4RDEsDIRKIAAQCAADPLTABBEkvADNRGzGmAdGB
DgEFSxEOGALxCR8MPQARgUEARAEO8Q0PADQYEQ5KABYBAgBBFxEOMW8BEbEaALchDvEADgFu8RgO
AQIASiEO8Qk3AAcCAAtRAAMUAAJtAAACADWxDgECABFBXwAiDgHXASMBDksBb-EBHpEOIVYAAAQU
ABNhEgACAgAADgAEAgBwERcOMQ7xFgoAMEjxEsoAJRfBNwAGNQAADAAgEVgGAB8BHAACAGMAgkEO
8RgOEWiRnQBEEUgBHhQBBnUAXBFNKAEOAgAC9gEIYwAQIZMAUQ8XTSgRWgCTURKhDhFoAR7RTAAS
oTEAQQZNGAUwABNOPgAgGALRAQlmACHxC_EB8AMGTQgFDxYBHgFeAR5BGMEGTSieACLxCyYAUQZN
BRABxgEEfwACBAACZAATERQAcPEXDnARRy6ZAmHxAgZNCBEJAxshAgC0AQ4BB08HIAEPHEdbKwNA
AAEcACIITU8AAZwAIBkKKgBBCkceBVUAEwnwAQEpAAk5AHAhDhEUAQpMLABaDgUAAQ4gACgBDr0A
4vEXGQQBB0wgAVcFEAEeFAAzAQ7BCAAb0V4ABWIAIBkRNAAmDnBPAQ8CAAMSccoBMW7xAjAAg0wg
AT5hDvESVwAWYVEA9AAOAQdMEAUABUwgAS4BQwEZAAG4AwIMAEABGYESrgGgSQEe8QAOTAAFEC0A
0B4BUxEOgRsDwR8KCTEqAGcYAgEOEVlYALIOAQ5MQEwgIWMBDgIAEzERBfADERaBGAEOEWkBHuEe
7CARSyMRmgAAIgAwEUYpBwAVAUEAYhHsIAEPGo0EABYAFUHeBfQCEQxGKQEe4Q4B7BAFAA1LEwFE
AIgBDgEMRhkRDkkApBHsAAUQDUsDAQ4CACDxEEIAEAknAABEADAwBUt1AQbdBAECADUJRhHbBJKh
DpwvFREOERhWAPAA8Q4OgQ4xE_F_AQ8cnA8V7gEQETwGFxPnATMbAxFqAQUCADEPHJzvATEfDlGy
BgAOBhVBJQBBQRvxAgkAUREPHJwgSAQWEI4ABYUDGiEUACAHnI4BARoAUfEwDgE_EQACGwAjDpFk
AAJoAAY3ABUhagJTYQ6cIFEMAOPxMA4RUAWcEAVJEQ7xFGoAAtkGYRFgBZwABd8BAD4AFVG8ANDx
BA5BDnEOEYCcBWkREAQANACE8QUH7C8VAQ7PAQAzAHHxJxkRDxzsLAFxDEYpEQ7xBjoAAKMGMGEW
CRwAJgUQuwHBIQ7xGRjBFiEK7CABqQEC3Qcg8QtmATAADgEYACUJRiwAEQqNADBBDhRHBDBRB0x_
AFFMIHEOAYYEAgIAAO8FUQdMAgUA8wIIQANBIQ7xJB4BxBEHTAUQAQdMAAUPBJYDIfEBkwAEvQcA
ZgAQkUkAjCABB0wFHQEOAgBQMQ4RFgkJAELxGg4BVABQIAEOQC1QAFnxBBYBDngAEhRLADIGSS0T
AEQBDhETWgZXEQ4BbsHCARRRpAAgEAUxAGERDlEbA7HEAQOMBQK6AGUCAQZJHRFpBxIxYAIxWAEe
QQYBQQBxBRgBBkkNEd4AARQAIgFoCAAAAgYH5gBiDkAoAQ1JRDACHwAAhANiAXgBHvEUjQBSBE8I
KHGiBhDRQgBFBEooAY8AAw0ACIcHAkIAEBEaAEgeoQ6RdQYhBEpdAwICACLxAwkARARKGBGyAxBh
DwA4CAEOAgATIUIAMREESusFI-EAEwARIfECMxEISmAGAUMGMwhKETYAIPETiQkcLkkAESFBCTOh
DlGVAAIaABNh0gMl8Q3dAwBDCBEebQAbAQIAAkcABmIDIPECJQA3Fw4BAgAFlgkDUwAGAgBgHhEO
8QEXZgAfgVwABFBhDvEDF_gAE0H7AQACAEPxGw4hMABRERdBDjFiAE8RSgEeRgABBEoAJPEWMwA0
WgEOCAoA3wAS8SAAAA0BUPECDhFqqwEiERMkAAR0ABAhkgECgAlSEUQqAQ4CADBxGwMOBvICEU4B
HvEHDvEPDxdEKgEewRt3ASARXgYAAxwDAXsANAJEGpIBQMEOEW7vBwARBAB-AkCxAkQKHAAGwgAU
EawHB7sAQQEKRBFFCzHBDhHNBzAe8S6BAxSRIABFDEceEZoDFUHdAgB2BRQhzgGBFhEO4Q4RDEd2
AyvxJoMCMw4BV0IAIBgRuQAAeAEEiAAAeACHgQ5BGghxDhECAGZBEzEOkRhqCwEzArcRGvEQGwOB
DjEaCEAABykCQxkb4RpzCxkBZQoZQbkAEYHaAgAJAkcxDvFZLwBDIQ7xIPgCARwANw8OQQIAHwF_
DTpf-xBUDA4CAE5P-lYMDgIATk-_VwwuAgAcT-5VDC4CABxP-lkMLgIAHF-_-yIMbgIAAoD_-8wR
DhH_GAUAdSNB-hhB-iEQAJAvCQQPGQQN-gMNADA2CQf7wvABHf4CQf4wDQQNHhcJNB3_ABsAAA8A
_0YUDQQHbQT_RRQdCRdNCRcdBP49BA0eCS0JFwlNFwk9-jsELQkHLRckLQkHCQ0BDxQdBP46DQQd
BwktBwQtBB0XCQ0LAS3_OgQtBz0HBF0XTQQLTgFuAgASPjEAoQkHBE0XbQ4B-jhUAPACCRc0DQkH
CT0E-jsEHQQeBBsOABBNggDgPgQNLgQLBAsEHgQrBAuTNw8CAA9TNC4ECxQMAH-_RAQL7gEuAgAc
T-5ZAS4CABxP-lUBDgIAGACIAQEYCA8CABow-hwdu8Q1Bwn_1QkPAgAQix00CRcBDg0EXQYPaQAK
QRsEbQcSAl8N-hsBDgIAESEEHScCTx0UAQ4CABUBpTgKAgAhDj18AjAJLQmyAADkOAsCAD8_AQ6M
ABEgCwFDAnAtJBctBwktSAAPAgAPOx4BLgIAUB4tAQsNCQO8LQQHLQkHHQQNLgECAAMYCg8CAAuf
CwRNF10EBz0HiwATA2EGDwIAC0FtF00ESgMfHdkBCgGgBg_lABIwAQQ92QM-NBcJNAEKAEc9D6UA
FgIYAhBNWACfGwQOAQQdBA4BAgAFYU4hDgEeIc0GIAEJ5wIAxAYDEAAABAAwCwQrQwAADQQBQQMj
DgEeADFhDkGUAAF6DgWvDQLrBC8OAQIABBEURgA9NA4BAgAgER54CQU8AREOIRRADQQNES4FJw4h
AgAAQwAXIQIANBFOMQoABeYDAlUFLw4BAgAgBokAB8sPBZ0FIPE6XQE1DQEOoQUvAQ4CABIVD7wJ
DwIABRkh6QWdCx0E8RYD8RIO7AUCLgAXAUoPD8UAAC8DCiMADgcyBqhhA-EOAwohA-EOKQZEIQ4h
CuwBaCEDQQoDChAAGlFEBtIBCmEDwQNhCgMxEwpBCgBmQQ4EHQQRVwYgIQOkARADrgExMQMRBAAQ
AVUADRQAQSEEDSFyAhARfwblEQoxA2EKsQoDYQMxAwoKAPAFUQ4BNAoRBAsUMQoxChEOIQMRCjE8
AJsDCjEOERohGlERADAKEQMTAMIDEQQLQQMhAwpBCiERAFiBAyEDUQ0A8QEBA1EDIRpBDiEaARpB
CgMRDwAbgQ0AESo0AK_hCgEaEQoRGgEKDwAFAOAAkCEKERphDhEKARkAPxEaARQADmAqcRoBGpEc
AABPAB8KDgACUTpxChEKFgBfCjEKARoOAAX-AWEKEQoxCkEaEQoBCiEKAQoSAAohGpEUADFBChES
AC8BChAACSBxCmwAE0FCAB8BEAAKADQAEVEWAB_xCgAAIPEABQAVEQUA8Q3JCjEK8QMK8QgKUQpR
ChEKQQrxAgoBCkEKQQqhEwAQ8Q0AFZEYANEa8QAKURoxCvECGuEaHABxcQqBCtEKgWAAAAYAAAQA
cbEKIQphGqEGADFRCjEIABFhEgAAAAERASIACggAE2EOAHdhCiEKUQrBBgARgQoAEVHCABehBgAR
gQoAEXEkAAD2AB9hCgAABhIAEVGAAQAOAB8RDAAGFxEWAABYABNxTAAICAAEDgARcaIBAAoACggA
BA4AAOoAAg4ACAgAEzEOACLxblEBAQUAIPEACAAwYAphCgCB8QoK8R8K8SQZAF8DCvH-IMgMOvYW
-P--gB8PDxcI-FAPDwEOHAn8TQouDAkE-E8PGRkU-AIPDUcPFwUA9TH8KCkE-AMNTw4ODRsNGw4N
Sw78KQkPGfwEWw4bDQoNCw5bDvwqDxT8BA8YSw4GSg4GSw78PwJLDgILCg0KCw4CDwAzDQsNDwBj
DxUyBgsFBABx-D8PDUcNAwMAUvw-DUsOAwCA-AkNC-wkWw4CALL8CA0HAwv8IwZLDgMAEPynjmAL
DxIL-CJbAAEDAIj8BwsACw0HDRMAiAgLAwcN-CMFbwDiCQsN-EgPGg8LDxr-CwAJAHD8Pf8LCPw7
DQBxHxv-AwIfGxYAIDkI9zbyAP8DBg8bDwsI-DgBDxsfAwQAFQEJABQPCQAQPwUA8AT8OARfAxRJ
FDkUSQT8DA8GNxr8AarwFwQp-AgKHAp3CvwTBFkPCQ8KyQQBCAEZ-AAKBwo8Gg8dCpf8EwRJGQDw
dgcAuSEEGdwKRwoMGg8dE5cKzBr8BAQ5DxkPCQAOaQQBOQQBKcwKZyojDx2XrAo3ClwKrAQ5DxMP
GQ4PE2kUibwKdyozDx2XCmwKZwpMBwqMAQQJBAEZHxMpBNkEfAqnKg8dQwWnCjwKhwosChcKfAEZ
FPkADgApBAUqPAqXSmMFpwocCkd_ACAKNyEA8ywMBPkDDgAHABkEAQUnCgwKl0oFcwWnCgxHGgWn
DApXBFkEuQ8ZDgAOKQEDBddakwX3ACoDpwp3uQEESZUA8AkpBBPHCgM6BQMFgwXXGgUKAwXXCgUn
BJkBAfErSRJJI6cKAwUqBQMFo9cKBRoTBUcKVwoTBQcEOQEESSEEeQQZBCMFhwoFStMFtzoFIwUn
GkcaIwUEKT4A8B8EAblDBWeqswWXSkMFOjcaBTMFBBkhBMkEASkEY0eqBdMFZ0oFUwUaBScqBTMB
NQDwHCkEAVkEGRQpFGMnGgWKBRMFswU3GgU6IwUTBQMVChcaBQpDAYkU6QRjBSofAPAUCtMFFxoD
SgMFCjMFAxUHSkME_QtzBaoFAxoFwwUDBRoDBUrRAORTBUoFAxUTOQIpAgkCKQYA-wODBYoFKgXj
BQMFqnNKAxojCQICAAf-AJMFqvMEBYoFcyoFKjMCCQIAB-EToxV6IwXjBRMFCgVKBRMFUxoFAxoV
I-IMswVKFSMV8wAFExgAv2MKBQM6MwIPAQIGAgAD8AgSwwUKNSMV8wUVGhWTBToFkw8VAw8UAxvP
8GYDCwMPFfMDNfMMJbM6BRMFcw0bAx07HwQbAxsN0w8PIw8fk0cPF-MBBcMqBRMKBYMLEy0LTwQL
EwvjXw9zDxdPDg8P8wIFsyoDBQoFkxsdSx8EGw0b4w8PBiwGc18ODPMPCiMKBcMdSy8ECw1DARMB
MwcFBwM7gvA3LA8OMwUHBQMPGE8ODPMEBTMfCmMVEwVDAVMdG28EUwEDARMBAwUPDgUTDxgfAlMH
DwoHAw8CTw4MMwHzBB6TBRMBEwFTC6YEcA8EKxBDAQMyAJEHAQcTHwgPGFNaAAIuAPAcEwHTDwoO
J9MEAwRDCx0LHSsAKxAzBAMEAwQjBCMMAw8fYwQTDT8CDxgPDhcAEOMtAI8OCBMBFBEEIQQAEBDj
LQAQKWcCDwQAD3wE0x5DWQRpAgCRAdMYQ-k_BOMJBgBNBEMCaQIAr0kE4wFDDSkCGQIFABjvCQKz
AQQDAUMLGQILCSsFABggAiMEUr9zBAkBQwsJCwAbEAYAIu9DDxiDCQQDBAETGxALIAQAD_0bIwUK
FwoFYwQJBCMLYAIA8CYwCyMKNwpjBAkz8BQb8BcLIwoPAScGYwRD8BUb8BYLIwpHYwFD8BIbEBvw
AwrwAiMPGT4MFXMC9T8TUAUKQAUK8AQb8AUqDxaAGzALEwoHgwETBCMBA0ALAwVAAwUHwBtAG-AE
GwgqC2AbMLMEIwkjBANAG0ALEwUKwBvwDBsKC0AbEBsgBBH7AfYAAbALIwUKUBvwHBtABAkE5wFg
sAsFAyVgGACQMAR5BGkESbBLPADwAPAgCwT5BkAb8AAb8BkbcA0AE1ANADFgCynmARApBgGK8A8K
kBvwBwvNARAwGgB7DAgqkBvwBq8B8AEAGxAbEBtgCBoIwAsqCBtgKgAdBZABESAkAPcBKhgaCLAL
ChuQGxAb0AUKMIABAKQAwUAIKggrKggAChjwAVYAUrALAwVwgQEBYgCRCggLICoIGgAIIADwA_Ab
8BIbUAoICggaCCAaCErwAnwA8A0qGNoIC-ADG-AQG2AFCvACCwoIOggbOggLCvAFFQAAcwGA8AM6
CBsQCAsVABEQnAHwABAbMBvwBAgKCBswCgAKMAQB8BEACwMFUAUasBvwDhugCgAIoBvgG1ALAwUK
B7AbYBvwBnYA8BQKAAoACBrwFAsDBRrwBhvwAwh6CAoIKghgG1Ab8AMLExXwA9gAgAUKoAjKCAtw
FgBBAgsFI3EAsSALAwWgCwg6GGtQ7QCDEBvwAUugGzANADDQS_AvABEVEQAg8BoMABAbNgAPoAk8
8QX7HxwcDvxNbvxNXvxPHvz-2A78UAMAEVUDAEE-DvxWAwDwClEO-DAOKg78DA78MQ5KDvwlDgYn
DvwRDmqUlPAhDA5GF7wOJw4sDicOfIr8HQ4WBw5mBw6MDgcmFw4MDgcWFw5sivwbHrYHDnyHRids
IwDwAJYHDlwOBhe2Rw5MDmoOfNyw8BgO-BAeFhcOjA72AycOTA5KDiwOFwYOB2YHDrwOJyb8Cg72
BSdcDipnAHCmB5weF0YsaQAg-AIYALLcF9YOXB4Xdg5WBxEA8AAMDgcOnAf2AEwOJ4YMDiZeAPBm
Aw6mB2YnDgwWB5wOB_ZMF6b8DRdmNzYnDhwOBw6sDgcWDgc2DgcGHlwOB6b8Dw5XLtweDA78DQ5G
Fx78Ai78Hi78Ew4MHvwMHvwiHvwGHvwADxMDHxusLvwJHvwBHhwO-A8DXQs8Ax0L-BYfEBwZDAn8
FQMNuZ33Gx0LHANN-BUJMRkBCZypDEkMOQwZCAMICQEJAQkDLQEtAxgNKQwZDBkMCQIAABAAECkQ
s-ACYRkMefESAx0DHQOxGQEZLBk3AG8RCfEPCQECAAxiCCMIAy0bDACPATkcPgw5AQkCAAdyIQlh
CSEJIQ4AgRkcCREDPQMPQOaDAw0LAz0LAQkCACEpPIMADgIAP_EJAQIAA-AGAw0DCCMNNQgTDTgD
DQEJAWkMHgwOjgBPHFkBCUgABEBpARMI6ADCARUTBQgDDQUJKAMNHwAiESkEAQwCAF9BCQEJceMA
CTAZAQ1-CUMBCQEYTAAAb7SCDgkMOQFJAQkRACgBCRIBdAEeDBkBmREeAACwAVENExUIAwwAIhgD
MAADkwEOAgBy0TcpDjceDFQA8wGJAR0DFQkBAwgBOQgDiQwZFwBPCQEJHLQAAJAhLx8GDpcODLkN
AIAdAxUZCANJGDIAB4sABgIAE2EIAPEOUS8PHx8GJxZXDhcOFx4cWQ0DBR8UHgwDHBkODAhLAA8C
ABD-Cw8PBySvHwQCBpc_DQMFDxQPBBcOCGcOHDkcQgAA4bEUAgQCJAeEEgY3MgQiMAD5BQIWQhcG
Eg4MDlcJDBcJTBkByQEJAgDwH0QCBAIUAgQHBAIUBxQyRAcEEg0FEAQSBzQiJPcCDjkMDicOFw4M
WQFpAQnkAgQCACIHFAgA8C8CJAUQApQSFFIGVwYXBgIexw4nDCkMHgwp9AcChAIVAAI0AgQCVAI0
AgcCBjc2AhQyBjcGEmcGDmcM9BIlD0EAEkRHAPAIAjSCdEIUAgYHBmIGNwbkAvQCFQAK9AIdAFIH
JAckB9YA8AhkIhQHNBIHBgJUB-QLAAUACvQIAiQCdGYAkQdEAiQHNBL0ExcAER93APAeBAL0CgeU
AgUQ1AL0HAcEAgf0EhUA9AQH9DwFEAJEAvRGByQFEAr0MgKkAvQBcADwDjgH9AcVEPQCAmQC9AYC
9BMClCUAAkQH9A8C9CkAKwDwAU8AFRAK9CkC9BACJAIVIAp3AMCULx30FgL0DwIEACUSAODUCx8N
G3QH9AUS1AIkAsQA0EUQCvQACwgLGAv0DBI8AfEJ9BESAFUABAKUByQCKAsIAvQBB3QSBAcktAAR
JBIB8ADkMgo1ABQC5EL0BgJEFzSQANV0EgpiFAL0ARL0DAe0KQAAAgBghAIEQhoi8wD3AvQYB-QH
IqQCBJL0FQL0ACJUJgAFbwGRkvQmIgQH9AAiEAAyovQn0wEYB1MAAgIAYCQCBIIEAjMBkQwHZAIE
B-QCQhkAEGIGAN70IQcEEgcUBxQHdAIEAgABKgBApAL0B7MAUgQHNAe0GAACGgABHgCK9CUSBAfE
AgQCABAiHQCC9CgCBAc0AtQqABKCjQCS9CECFAckAmQHNgIFAgD4AWIEAvQIB-QRB-QFAgTiBAIC
ADX0IhJ5AAgwAFIkAnQSB2ICNsIEAgIAYfQHAsQHpKcBNpQCBAIAN6IEAlMAEwQ7AEACBPIFBwBg
FAf0Bwf0RwGBNAekAmQyBLIdAOQCxAL0DhIkAgQX9AMCBN8ABVEAcvQYElQH9AkQAAMUAQNjABEa
MwEs9AOTAQQ_AAImANQTAiQSFxQCJAKUAvQFFQBMJAf0CzcACdQB8wL0FAcEF-QFB-RBAvQJAiQC
JC4AAgoAQMQH9ACRA88CNBIHtAf0QxIEB_TlCDqiTxUVDqUOpQ4lXggAIBVuCADzAHUOBR4lDkUO
RR6FHlUuFQoAJCUeFgCxdQ5FDjUuNc4lTiUIABJFEAC8vjUOJU4lHoUeNS4KABPVWgAZpQgAGeUO
ADNVDjUKABfVbAAfhQwAAiMVfnQAAXwAMyVOJYQAG2V8AFUVDgVOFYgAG2WAAAEIAB9eFgADHQV8
ACcVbgoBFU72ABDOGAACigAoFT70ACCFHiABBIwAKwVOYgACagEYTvgAD4IBAywlHgwAWTU_JR51
_AAFCAEcvvQABJIAPxUuVYYBAU1eJQ7lFgAADgIa1fAACxACJhV_9gAIDAIZZfQACIAAD34BJwJE
AAiEAAaAATUVbhWCAAiAAUwVHiUeBAEEggEsRT6CAQAOAD81PiWAAQQWpXYACwADJDUeegALAAMR
HowBDwADHB_l-gIIPzUuNf4CIS8uVX4BAy9eJX4BAC8lXvwCBy9VLvwCAwL2AQ78Ai_PGHsBAgBr
ABOtCAAGewEAFgAbqHsBCPEAOUgBSA0CCPsCZD8OLxA-DgwCGL70AEksTxAsDwIV1fkANRhhGAsC
FeX5AAQWAAALAhfV8wBXKBEIESgNAiQVfvcAN0gBSAkCCH8BOT0hPQ0CBmkBE60IAAh-AQADBAgY
AAyBAReCDAAIgwEG_wEKgwEOAwQKhAEfpYQBAg7-Ag33BAsBAwb7BAoBAwj5BA8BAzMCTgAEggAK
AQMGBQQNAQMJBwQIAwMsRT6EAQkFBA8DAwAfpQEDAgL6AQ4BAwoFBA98ARcACgIudQ7yAA6AAQr7
BAX9BQnyAAoQAhbV9gAJhAEF9gAJhAEdpXYABAwCJhV_9gAICAIZZfQACgwCG2VgAA58AQ-_AgMK
_QQP-gIUKS5VggAHgAEvXiWAAQAF_QQN-AIJ9wQL-AIG_wQL-QUvLjX8AiAP-QhlD04KNw9cfxEP
MQCNX2RkBPD-AQATHyeJAEoAm5VQFvcRFlBtlPAOIAYnDxzxEQ4nBhAnAfwTAScABhcB-AoOKg5c
ARfmE3AKDkoOXA4HFgC-CQ5qDkwBNwH8CYoHAAEEHgABMgAACQBQCw4qDmwJAB8XBQAORQ8QAQ0C
ADAdAS2vxCcMDQIA9AIdATfxCB0BHSwdAS0hN8ENAQIArz0cPgw9ITcxDQECAAF-LTwtQTcBDQIA
ABFtCxNzPQENATcBHRQAVA0BLQENAgAgES1sAB4RPgAFLABjDA0MDgEMDgBxNxEtAa0BLQIAYCwB
LQEdAToAUG0BDQHtJAASDCYAAG4AMP0GAZSyBGcA5TcBTRwuDA4cHQ4MzQENTgDwBx4MDkcOdw4c
TQytATcETx83BksXBhveEQA7r-ESTAE3BA8Piwc5Kyn3AgQ3BPkCGxlrVwYXCwQ3BCkLCQtZBABg
OQsHGzc2FAATaRQAcAkLKQs5iwkyABAKDwBQBykHKQcOAFAQCykLGQkAHxcFACtBDfkXDQUAYBcG
Bw75F4QW4A35FQ0XBgAnDfkTDScQ28Zw_Q0dDicGIIACEFCKAg-llgwdMb8CRh32ER1amMEXDxz-
EAdvGS8QDxxlmMEXDxD8Bw8cag4sDxAOzyULLCYXeTwLFx0HDhwjF4FMDgcNBgcLDCQXdEwLBxYH
DxYiFwEPADYJ9gEaFwEQABQCEhcEDwBD3BcWCQsAAgMXESYPABaG_hYCIAAYB-oWEAYTACMLDPMW
EJxrAFEL-BMuDAkAMS78FAgAQdwu-AYJAEEsHvwSCQAg-BcHACcBCwIAlxsBKwwbDBsMCwIA9AYb
AQcWB-EIGwEbLBsBKyEHFgfBCwECAFA7HD4MOxQAPzELAQIAAUwrPCtBZQAEAgARazwDMDsBC2EA
IwEbFgBUCwErAQsCACARK3QAHxFCAAUAAgAxKwwLQAMCDgCRBxYHESsBqwErAgBiLAErARsBPgBQ
awELAesoABIMKgACdgBl_wYBCwFLbwAAEwARS0gDZxsODMsBC1YABEoDMEsMqxAAAUwDQEgXBhhM
A1ELDBcLTBYAoA8PiAc1KCX3AgQOAJH1AhgVaFcGFwgOAFElCAUIVQQAEDU3tBI2FgATZRYAcQUI
JQg1iAUUACD1ChEAUgclByUHEABSEAglCBULAB8XBwBR4QYNBwj1FwgHHRcE9RUE29FCBPUTBNzR
Rwj0EQhgmgBGAw97Ax4K1ZvCFwQCXxUiXiJeIk4EewNRDg8YUiwCABMMitIgDBIgsQcEAAHNzVoE
DBIMQgQAAMUAQQ5SCHICABFCqdIxQihSAgAQMg4AREI4DDIDABAiEQBoAgwSKAIsBACYIgcWByIo
IgwSBAAgCAJLABMCSwAhUhgPACMoUgIAAUkAWBgSDCIoBAARAhcAWAgSLAIoBAAAYABEQgw4MgMA
HiKmAAvCAAbfAAMEAAGjAEgsIgwSBAASDKMAAjkBMSxSHA8AIyxSAgAASQAkAhw-AQQEAB8CYAAE
D0YB-zMvEg5HAcAPdAMCAAXWFAJCAQQEAAMV1hIcOgETUhzWMQReIgIAHgSlng9FBBsPfwoDI-8Q
gAoh-RV8CiH9F3gKEP0hCgsFADMtAW0CABktGAABBQAAxwkMAgAWDToADgIADzgAER8NAgAUAi8A
PxENAQIAEB8RXAAePB0BLQIADqIKD0AABzwRLQECAAKoCg9AABIP1wAWD1IAQC4hDQIAD5AAGR4h
AgAPPgAWL-EZ0QAYL-EZWAAZPRENIQIAARkAOzENIQIAHzEwAAoCAwAzMQ1hAgATMRIAIA3xkAsS
8ZALEvGQCxPxkAsU8ZALHvGQCw-QA_SHDxkEDAQJAQ0CAM83Af0EHAQMBAwHCa1yAgKVHDQJFwEN
DAQM1AO_AgRsBwQMFAwEDE1qAJAEHBcJTBcJHBTMAwXSA8w8CRdMCRcJLAkdDARAA-UCBBwPFQAM
CQcJLCQXLAcJLATJA-wCLAALDAkXHAQsBAcsCQccBAxvAMsPFARMF1wEBzwHLAS9AG9sF0wEBwk3
AAOkAQQ8CQcJDDQXCXAADsUAEEwiAIcaBA0BBBwEAaADMAEUKhUAnwoECgQBDQEMBKcDBhEUIQAS
NPIPCaMDLxEUowP----rIA8T0gEz8RUDWwA-AwENAgAHYBEDCBE3UWw3IAgRegMSCJYAYGENIQNB
CBQAAUM3UAgDMRMIJBQgEQO1AzExAxEEAKEBCAMIMTdhCLEI-zYgCEFCAPEFAxEIMQ0BCCEDCDEN
ERghGEE3QQjKNhII1zYyNzEIszbwBhiBGAEYUTcxGAEIA1EIIQOhCAEYEWYAMBgBA4cAgAgRGGEN
EQgBIACwITcxCBEIcRgBGJERALEYITdBCAEYcQgRCBAA8A4IMTcNIQgBCAEIYQgRCDEIQRgRCAEI
IQ03DTEIASMAoQghCEEIEQgRCCElBHBBCAEIcQgBKgABNgARQTQEcHEIQQhRCGEQAAM9BF8DCAEI
wUEEcVDdTxn9BAoENAxNrEIEYB08Dez9AQkAQfwF-QAIABEEEABCDQH8BDwDAgwEBBgAQx08DdyL
AwFBAI8tLD0cDUz9BUcEIx8MRgT---9mCz8UAUkEAjkUAUsEATIUQQH8FQHw4RD8DQkQByIaDwcA
BjMsAWwCABgsFwAKBwA9DAEsAgAaDEYADgIAD0AAGRkMAgCrHA8ZBAsECRwBDAIAACsAINwbiD1A
Bwn8AQ8ANBEMAQIAtRwbNAkXHAsECwwBAgAB1xa6vARrBwQLFAsEC6xtAKcEGxcJSxcJGxRcYAD4
AxwBTDsJF0sJFwkrCRwLBDwBHDUA9AQEGw8VDyALCQcJKyQXKwcJKwQcOgDwBREsARwrCg8VCwkX
GwQrBAcrCQcbjQAnLBFAAMYPFARLF1sEBzsHKwR1AAPGAGRrF0sEBwk4AAS-AAM6AKEBBDsJBwkL
NBcJdwANPQBgDBEEGxdLIwBlGAQRBBsEQQDwASEMIQwBDEEIBCgEEQQIBAg7AFcLBDEMITwAAgIA
IREUHQBHNBEMIX8AESECAGExCAQhDGELAAh1AAQCAAIxAAoCAAA-ACjxGcMADwIACSIPE88AAHME
BGEAPwMBDAIABzARAwViAAF3BAEKAFERDCEFIaIAYmEMIQNBBRYAAXsEUAUDMRMFVwBQMQwRAzHP
ACEDEQQAUAEFAwUxJgAxBbEFfwQiBUFKAPABAxEFMQwBBSEDBTEMERUhFRcAIUEFgwQSBYMEAE4A
EgWFBFEVgRUBFREA0hUBBQNRBSEDoQUBFRFyADAVAQOXAIAFERVhDBEFASIAARgAgAURBXEVARWR
EwAhFSFfAGEBFXEFEQUSAAGWAPAGDCEFAQUBBWEFEQUxBUEVEQUBBSEMGAAwMQUBJwCCBSEFQQUR
BREWAIAOQQUBBXEFASwAATgA0EEOBx0XDHEFQQVRBWEQABEMlhSCDPEDBQEFwQyUFGkOHPENHA6R
FB8S1hguQwbxEQaWBBT2lQQS9pUEEfYSAj-2FwEHAA0x1qHWCABxpiGmIRYxRgwAYZYB9gFhNgsA
YYYB9gJxJgsAQ3YB9gMLAENmAfYECwBTVgGGYUYMAGJGAXahNlE5AGI2AWbhJkEMAIMmAWbxAWYB
Jg0AU1ahNzFWDgCUFgFWoVcxVgEWDgA2kXchDgBTRqF3MUYOAJMGAVahdzFWAQYOAFZGsXdBRg4A
N8FXUQ4AN9E3YQ4AL-EJDQAeNFbxB2sAZRYBRvEHRpQAT1bxBVYNAAFUJgFW8QPXAAnyAAALATVm
ATYjATV2AUY7ATSGAVZSAQAFAANoATQFAXZ_ATEDAYYLAFGWEeYRlgoAUbYhhiG2CgA_5oHm0gEP
BwAJRPYZBwYkAhQANgIWEEoCDi4XDzQHKGIW-xURDxagAkIPFfUTaBsxLvUTWRuxBT71Ew8WBxYH
XvXFGC7_GQUAQB71EV5yAzH1E04HACEUPgcAIRUuBwAgFh4HABBFe4shhQ4LAEP3CQx1CgAzCgxl
CgAzCwxVCgAzDAxFCgAcDQkAIwz3HAAZdeqMBBQAAtiMDw4ABgkuABNF34wDDgAvt0sKAAEA14wD
DQAG04wDvAAC0IwEDQAXOgwAFA-KjB910gAYQlUM9wsKAEJlDPcKCgBCdQz3CQoAAbqMAQsAMB71
FgcAMC71FQcAMD71FAcAQU71Ew6kASkRHpoBBgUAMA71EqQBUQz1Ez4FpRkx9RMuXQIRDvIBAF0C
Twz_EQxdAjxSDP8QEQxbAgAvSACaWRMGyB0fAYpZAhEBv0YAeQIhDEGCWRDBzAUCWkkqTw4qUwX7
TwDfACBBDkk_BWZZESEVAAEnSAAYAA1eWRchNQAIUFkkMQ5vAAE4ADQFHxaaUAJtABEBzQJRUQ57
EUzlShaBaAB3DEcrAQ8cTC9TEwGcAJVRCkcrAQpMHgUyABAeBVkBFQBXDgULAQ4CAAFgADERGQRP
AFZcBRsBHn0AAhsAEBEaACUOe88AApIAARUAIEcrw1gRAWIAECGSAGMbBQsFRyu2WAO7AEBHCwUb
FQABnlgWAcAAdA5HS0crIWMpAINBHucrEU8LIyQAARQBlRHnKwEPGk8LIyUAYA4B5xsFCxQAFROi
AAEpADALBRsWAALiSAUsADA7BUBASgKgADOhDpcvWAEgAIJhfgEKlw0FCyZYFxGZAAUCACEKlxEB
A94BE4EyXSKXK5RKA-YABgIAMgyXKwFLAy4AET4SABQOAgAIYQBTYQ6XK1GpAHBhDhFbBZcb4lcI
JQB2EWsFlwsFWc8AVBGLlwVpJACUUQznLQEOTwop9QFQERkRCufPADQHRCklANMBFAkRCucFGwEH
RBkRSACzARQhCucrAQdECRFBAQAVSWjnKwEJRBHfARAt3wE2cQ4BJQAgDEdfAADlAQTZAgNSAACt
AIcMRwUbAQxHC6VXFkE5AG4rAQxHBROqAgM7ADIrAQ63XhiBMwAjBElkWgCiARkDbAAgGwUeAIYR
DlEfCw8DETUAEAtqVyUESSpbSAEfCyFpACAFHx8AIQMR71UDNgBYDksgAQNQVwZpACECSK9YRBEc
DnEuACoCSPRPJRwREwQDMwACO5ABAgAh4Q4vCgA2AB4AdgRwMQwHBg8NF0ZUIABIFQAArAQgCg8k
BQ4HV2QxDhcGHQo1BTAKLQr0BH8KXQr2Ewo9kgctFRDGDiHxFS0FRPEXFw3OFwJFDA8FANgB9wAS
BgUBEgATAQCuBhIOJQEPrgZFE-wICUMPEx8L80cREJgGQANvC-xKDTMPEzP1RyEPDg8AIlMPDwAS
Dg8AEAMPABAzBQAFEgCBHxtDC-wMBgdQCdMPEzMPCwsj-AgGHAYXEgAxIwsPbQDEE-wABgcGPBYP
HQYnGwDULwsLE9wGRwYMFg8dHRYAxDMLDwsjzAZnJi0PHUUAhIO8BncmPQ8dZwCjcwt8BqcmDx1N
ChEAEBM2SLMjCwomPAaXRm0PEq8AAEtI1gkTCw8LCicGDAaXRgobANQZDwkJCCMPCw0K11Z9FgDx
AQUPGQgFIwsdxwYNNgoNCl0YAOAFExVDLacGDQomCg0KbYMlwQVDCxMLLQqHBgpGnRAAUnNNCmem
GwAAbgBTIwttR6YrANETGyMbbScWCoYKHQo9EgBQcwttCiYQACEGTRAAgYN9CqYKDRYKDgDRAQMF
IwUjjQqGCiYKXREAIwUDAgBDnQqmfSMAAwIAQ60adi03AHGFvQpGGi0aDQARERwOgQEVzQoGOi0a
RgCyBA0PFA0PFf0DOr0PAAA9P5HdDw8tDx_dRw8dJ5IPFR0PFO1fD32_RgATAOIfFR8U7Q8PASIB
fV8OAhIAoE0PCx0APQcKBw2uRoAiDw49CgcKDa5GEgJGAOAPBF0ADQAdAA0KDw4KHaVGZV0HCQcN
DiEAUB8ETQANIwBABwAHHZZGEF1CAAYgAFEPFB8EPSlL0C0LLQINDx9tCx0PFT6JRgAhABYDm0MF
BAAQA0gBSxsjCxMEACADBRkAIwtjAgARUw8AKPMXBwAzEwVjAgARMxAAQAMFDxWLPxwMBQAQFR4A
IC8U8z8eKAUAADwAUQwfBAgDnhQPBgABEBH2CSAMEbwUCQQAAvAPMxEIYQIAETEQAEFRGPEPCQBB
YRjxDgkAgDEYERjxAwaBDQCgCEEY8QUmDxZhCEYE4QxBGPEEGAkmCCEMFw0PABAwDBgGDgAgBhrU
KBH81CgSKhUEEFohBB86VgQtFPFVBDEBTxCZjxJOBBAFm48AVwQiDB6UjwCyAAJmBgeMjwAUAAKE
jx8uDAAABn6PAhAAAnyPAgwABnKPAhAABmiPAhAABG6PJi4BeAAKTo8CKAAKX5QAFQATIVGUFAtR
lAC1EREBR5QjCyxHlAQoAAATAAU-lAAoABCREQAxEQwLG5RSoQcWB3ERABMbLZQASwBADjEOCw6U
ExsnlAKLACEeIRUAEAsjlCALLHdVAhYABh2UAWsAEgFCAAUXlDIbHC5BAEQRDiELD5QTGw_UA0IA
AwOUABYAEi5CABQR95MUK-eTBCwABO2TAmkAFh7nkwURAALhkwUPAALdkwUPAAbXkwUTAATRkwUR
AAbPkwaNAAnJkwGNABcOw5ME4gAZDL_TAiYACLWTASgAB6uTRAcWB6HyATAuER6RARchOJEB2gES
buYBQBEeYW4_ACABjuEBI2GOrQAEFJEBqgATIQyRAjgAEREGkQEoABGOAJECNAARnvqQE54YADNu
IW4YAAPqkANIAAXekBIhaAAE0pABaAAlAa7EkBCuEAATDEgAEAzpAyEBXmwDE15DEQNsAwNIES4M
8esOD3wY-wIiDAF9GC0BDAIAD34YCiAMAX8YLwEMgBgiKwEMZwAQHKUABYcYAFYALQEsiRgoFAGI
GCkBDIkYLwEKiBgKHwqHGEYkAQyIGE4aBAwBiRiDIQwBCgQqBAz5HACMGC8MIY0YADEBDBQfABM0
DgAMkRhCIQwKBAgADpQYDwIACRQRZgsvAQyWGEMVCJYYAQoARxEMIQiWGADrBwSWGAIRHQ_WGAEA
Ex0AJgAGFR0ElhgyCDEMFx0RDBcdADcYCRkdAE4ACRsdABEACx0dAhMAEAOXAAAfHRQMHx0AGAAK
IR0BXwAJIx0AdQQPJR0AAoQIDCcdABYADycdAQCWCAcoHQWXGAApHQ6XGA_yBDckDvKxBOECXxUy
DEI8AgwCTEIcAroEoCIMIgwCHAIMAiwGAAEOABEsft4BzwQkAgwCAADo3iIifAwAICI85QRQMgwi
DDIOAEEMQhwiCAACSi8wAsxCRAAkXEIQAAEoACESbAgAEpwSAAECAEAcAgwSBAAjDAKEAAFQAAMy
AEACDBJsay4CIAACLgABHABiTDIMMqwyIgABEgAgMmwcAENoDAKcPgBBHAIMMlgAAdSQMUxCXCYA
AEIAchwyDAgLSBLvACIMUhcAMAwSbBUAETx2ABAs3QxxAjwyDBIMEiwAAX8AAI8AEDIZABeMFwAT
QhUAAYoAUnxoEpxS2wAwLBIMQJAB6gAqIlwzkEEcQgwSMwAqMgx2jwGRAAIbAADAAAwdACEMIh0A
ASUADx0ABi4MAlcAEULOMCACfLyPMmoUbCgAMG8Kd6uPEhwOAEEPCkkFlI9SDxdOAwswAEAMBQlF
D49fAw5DGwwSAClDZfcFYwwAERwbjzFtDHsPACciDAKPcg1PEg0BDGsZABVcUo5hDQFNEXwC_ABj
MgwADxtAFAAAwAElDCItASQACBkAE1wkAgEyAhcSGQABqQITAnoBQWBnbRE5AAMuABCMW44kDHFr
AgVDAgZIjkEMYQwycQBgAjwCHAJsEwAAo40i7ALBMQE6ACRCDBcAACwAIwxSGwARMtoBBRsAA3cA
MQwCPDwAEIy9AQYdACYMEmsCIQwyWQAxIgxvUwAUTBcAAEIAhRIMQhx6bBIMFABQDBK8ahwxAAJ3
AAD-AoNCDAKcAhwCjGgAMSwCTAQBBgczAcECA-8DEiynAAP_ACMMAg4AAI0AATQAEXwqAAJyAQDx
AwGrAxBSDAASLC4zcQIMIvwAAjx3ABEM6wQwAhxC-QADxwAyMnwChw0QAq4DEizFAAMdAACKBBYU
qAQSJLoEEFTGBB80rQkuD_M5Gi8NBuQ5AB8W4zl_VEwe-BALaxITrOg5gA8TPxsPCzwDrRIi-AoS
ABAjDQBzHANPG-wJC1Q5jwMoASgDHxMI_DkEckEDGAMYA7H9OTALAQsMB6IRCwELBSMFAygfHjkH
BjozBRgDdFBjCA8LAzgEIAAACDoUG2E5vAUTCD8VBRMINQMIBTrnEQsBEhMCBQMIAgslAwgDOgM7
AOYBKwEIIwITAgELARUDCP85MwsMO5kAYQMIExIFAxoAIhUDSzoXG0AA9QQLAQsYAxILAQMFATsF
A4sMGwwr4TmQGxgDEhsFA0sVEwAKEzpCKwgDAopPUhsODAW7GgADNwBQHggDAgBlT2EFZw4cOxwd
OjANLx8WAGkKFkoXBhohOvABDQ8PGggCEAkaBzkqKfcCDRMAgDkCEAqZGhlaFk8RChIA8gMpChIA
CjkKCQpZCjkKBwoGNzYYAPICOSINCgkKSQoJCgkKKQo5igkWAFASAA35AhUAAYg9AhQApwACAA35
CAopChkQABIPDABxCgIQ2Qr5AA0AckkSAPkEB5kMAHECEApJCvkIDQCECQcpAhAN_Q4mAAYLAHIQ
_QIKaQopDgBiIgAKSQf5dQAgSQAyABMNDABREhAN_QwMAACtALMSIA0JB0kKmS8dWeMAMAkAIhQA
ZNkEHw0USRQAskIQDfkABAUEFQQ5EwDTGgBSAAkKmQcpCiUEBXUAkhk6DTIAGQrpSiQA8AMqDWoZ
CvkBGlkKBwYFFwA6HSo5AVD5Aw0XBWIE8AYAavkMDRcGEwUGFw1A-QwKFwYFIwUSBH8FUwX2EwUz
uzpARxIuAiwEAAfDOk4CDgIsBgAPyzoKEgJNegYEAABfHxVOOXoDBACbBxYHEh4COAwCBQAfLlQ4
CACC-R4SBgAEXDgBU30GBAADZDgFPX0DBAAEbDgBD30NBgAPdDgIaxIeAgw4AgUAD9wAAg8GAQYP
0TkFAccADgYAEgzZAEgsAi4SBAAD4TkHsQEBBAAE6TkGpwEIBgAvAg6AAAYPsgH-nC8SDrMB-w0P
7zsIDbABAgYABPc7B7IBAAQAD-87PQ3cCU4PEBEOAgAkAQ7tCSQB-p8TEv6fE2wMXg8MHgsCABBO
sQ8-XgseAgAAACYBTwE_Cx4CAAASPjIXPQseDAIAMAseC0kBDxwAAjIMHguEFx8_OgACD1YACB8M
VgD-----WB8LVgAKDwIAAAFWAA8bAAMBiyg9TgseAgASXrwZFP76KgGqBQGyGQB8Gg8CAAAPxxk8
HvdX4g8DAH4O4uEPAAEpB4k3AFIAMvcbAPYAMwb3-wEAE2gRADEA9xsbAQ6wMw9tAf8TD1pPEQ8x
AP------vSwxTqFVH_wuBhnxCzFOBA8SDQ8dDe62ri0-Eh0O9hcuLQweDfcaJRTwAw73HCYHBvcY
Nh4GFwb3FSYuHQgAMBsGDgcAgB0GJwb3FxYeMTRA9xoWDg8AIBsWIADxIyYnBkcfDA8cB3sPDEtq
O2c2JwZHCgsHC4oLCktXGgsHBg8WVQ8VBicGRwv3BgYPFkV5DgDwHFcL1wYJRekIBhcGVwtnBglV
_QYFBocGCVW5DPkBBQZHFgkF_QQM_QAVNgm8cvAcDOkVCBX5AwxZDCEMyRUI_QUBDFkBDBkMuSX5
BSEMOQEMGQFJARwBKSXpDAgAAREAIAwpIgBQARkFCAU3AHEpDAFJAQwJHADiDAEpDGkFCAVJDAEc
SREyAGA5ASkMAVkVAHABaQwRDCkMWADzDDkBOQwBSQUIBTkBDGkMCQEMKQwRDDkMATkMSRcAUHkh
DCkhEwCBHAkMSQwBORUVAABpABEpBQAhDAFNAEEJDAFJGwCQDFkMARkBGQwBEwACDwBhORUoBTkc
0ADgAQkMAXkMmRUpBShJARyAAPAdGQzpJVkVGAU5DDEZDDkMuUWZFRgFaSz5ABX5AQUYBfkHFfkE
BRgV_QMV_QcIAPENABX5ChUIFYlV_Q4FCBUpRfkVBSgV_RsFCBX5HQUAQygV_RwEAPA2EZU4FfkJ
ZbkoFfkAdfkEBQgVWYUJNicF_QUFCFUJFh63FfkGBQglJgcGBwvXBfkGBQ42JwYHGisHCwcLBysa
DgVppQklIAIQBwIAIDobGACQOg4FORUJNndmFADhJwbHNQkm50YnBvcZNgdEAhImLgBD9xc2BwkA
ERYZACUYJhAAgg429xoGDg0GEQCyRzb3BRZXBg4dDiYRAKAHti3WRwYODQwOQwD_EDYefTydlg4N
DB6GDk0MDQ4cTRxNHJ0eDT5GDi0MDg0CAO5OLU4dHjYeDRwNDh0ODQIAUB4dLgYOXwDBDQYOXQwN
Dh3_Bg1OEgCgHB0cDQwdHg3_DA8AsQYeHA0cDQwN-hgNCQCCHc4NDg1_Bu4WABMOAgBTzgYOBp4M
AAAYADAcHQ5R3hYOAgAgLB0uAET_Bw0OAgCobSwdDB0ODa4NDgIAIe0cKQBgDg3u-QgMnwBEDD0O
TVsACwIAIC08IAB-DTz9AizNLCQEGfUREBAEMIFQAYcBQAE3DTcBQAEnLScBQAEXTRcBQAEHbQcG
AFsXHQcdFyYAADYAVY0BQAGGCAA-UIEg4QQc8A8PHfYfDgb3Hxb3HxYXDw74GQ0XFhf4GxcWFxj3
FxgHAH8HDxcHDQcIAgAGcQ0HDAcYDQcsAEL3Ew0YCgBkBwgNJwwHAgATDQIAFAwCADMnDQgoAEIY
DfcTCgBPDRgHDGoADwaaAAGmABENsgADwADxAw0oDWcIDUcIDfcIFhcYlxhHGAkAsDcNKA0HGAcY
BzgnqQBABw0YDSsAERcxADAHGB3DVQAUAEAYDQg3uQAAIwBACBcWR8sAIAgHEgBBFxgXGJoAEQ0T
ABJIHQAAOQAkBxgcAGIYBxg3GEdUAAAEABAIAwBiFwgNFw04DAAAhwAGqwAPagEBLw04AAEGMw0H
OGQBcwcoDfcNDSgNABM4XgEOMAAALgETOCYAhQgNGA33Cw0YdgFCCBcNCIoBKQcNAgACFAAAuQAC
KgBiJwz3DwwnNQDjDScMdw0oDQwNKA13DCePAKEnDTcMBwwXDBgNAgAQDFr0IzcNMgCxCCcMFw0M
DRcNCAwUATEMCA0QACQMJ18AMAg3DL9aJQgNBABVDA0MNwhAAFANJwwnDLABhhcNGAwnDCcNOgCX
lw0YDScNGA2XLgBAhw0YDeABF4coABFXcAIAngAAkgIWVy4AMAw3LJQBNjcsN5AAtg1nDFcNCA1X
DGcN9gA2xw3H8AAHEQEPRgEWDoEBD7gBEwnrAQ8eAhIPGwMFAKMCMIcI9ywAACEAATcAAFQAQgcN
JximAhEIjQMAhgOOCA0nFhcoBwgCACIXCDoAAw4AACYDMBcIJ1QAATgAIgcIYAACDgCAJygHGA0X
Ftd4APQzBhbHCA13CA33Bhb3HwYO9h8ODw3_Hxv_HxsOC-4bCw4bHgv_GQseGy4PEv4XCi4bPgr_
FQo_G076FU4bTgr7EwpOEwAhLgohAAMwAAM_AH-_HwsK_x8KngkdB-wEDwMAoAFHAWAN-h8d-h-l
BkEbDQ4dI_MhHh1GAfQGDC4dPgz_FQw_HU78FU4dTgz9EwxOEwAhLgwhAAMwAAM_AH-_Hw0M-R8M
5Ar--8UxRvcZ5AoWRuAKQvYDx2bZCiD2HdEKgNbulm4NPmYdpufxMzY_DV4NHlYdLg3_AR0_HV4d
Dg0WHU4cHf4FHX4NDB4dPiwd-hAdDC4NPB0eLTwODP4FHTwNLj0_HfwSDT4NPiz9BREKAIIK8w8N
HD4NLB3_B80eDA0uDR4NLg3_FQwNHg0sLf4XHQ59A64NDF0OTf4RHTxNRQoPywQZ8A9XDO8QDAcP
DugNVxY3DP8QAgf4Ag03FicM_wMH_APZBcAMSwyXDCsHKA2XDUiDCPAFOwzHKwcoxw04FxYHDCsM
1ysHKNesB-AEFgc75ysHKOc4BxYHKwxXDAsMVw8AIA0oEACRVwwrDEcrByg3WAcRRxQAUEcMSww3
FAATaBAAH2sOAAAlDUguAACmJgAUAFFHDSgNVxQAE2dlAACCBxlnaAAh9wAPAC-3AAwADyEM194A
EdepAFf7Bgf4BggAtAz7BAwHDfgEDQcW9ArwBhofG0cKBwoXClcKpw8ZtxYXCg8aF4Il8AEKJyoX
GicaCRcKJy8ZBw8JRDmzBwUPGQUnFicJCgcCAFUXChcKBwIAcQkKJwQXBAcCAGEnFhcaCQdKAAEn
ACAJGgkA0ycaNwQXBQQFBwUEBSeFAJAHBfQEBQcJ_gQbKFf0Bgf6BggAsCQF1wUkByoJ1wkqDgB-
9wAkByr3AAwACrFnBQQFVyQHKlcpZxAA0VcFJAVHJAcqRwkqCVcSANJHBUQFNyQHKjcZKhlHEgAQ
ZBAAWScJagk3IgAGEgAERgB6JwkqCSoJN2oAMgkKCWwAIwXnaQARR7AAEDQPACDnOi0o8Q4kBdck
ByrXCSoJBxYXNAXHJAcqxwk6FxYXBUQFl_MA-BSXCUoJFxYnBfQDB-oDCScWNwX0Agf6Agk3FlcF
5AUHCeoJV9AITwsHDBvQCALfDAsXGwcbDAcMGwcLDNAIBkULFwsHAgAANAAP0AgCERtGAF8nKwcb
DNAICvEDE-4fEw4D-hsDDhMeA-4ZAx4Tigf0BgIuEz4C-hUCPhNO8hVOE04C8xMCThMAIS4CIQAD
MAADPgB--h8DAvMfAgUEHPERA-8bHwMO_x8e_wAeK14LPgtOC04LDgse_wReC14bHguuG-EJKw8a
dx2LHgt_Wx4LLgseK5cd2x57Hgs_CwBA_wc_GyQA8QAnOycLDScdFx0bDTcdO04pAOInHVtHCxcd
G0cdaw4LPhEAAEABkxcdGxdbGgk7ThMAEg0TAGEdOxkPGWtNABENTAACGABRNx0rB6sUACdHCxMA
pAg7GDseKycbHicWAKAXawcYDxgLGAsMwwAxK5cLbACwGx4XHS4bBxgcCFsUABBHRgBwHR4rBxsc
SyYA8AUNdy0nHUcNFx0OOwd7Hgse_xMHa7wA8AUNF0sHCwerDRsNKw0bBw0bDWseKwcA8wMHDQsH
iw0LrQsHCz1bHjsNBwsCAMBL7Q4GDistOx4rFw1hhiALDRYA8SkrDQvdDk0LDTse_wUNC-0CWx77
By0LPQtdCw1rHvsGDvsIHvsADjsOGw4bDjsOSw4LDhsOKx7LDqkKMQ4LLgIAEA6VAQEWAAEKAJAL
XgtOCy5bHnsQABE_FAAAqh1QXgsOax7UAEELLgs_EAARPggB8gQOSx5b-gQLfrseOw4b-gkLDsse
PguhBwsO6x47-gr7ARYLEAoPAAEhABAbCQBxHgv_CHsOiwkA8REFBjcGew5bHhv_BgYXFicWGw4b
HlseC-4GBgcGVyZeWyMAcFcGJwYHBl6qAFALDgv_A1AHMEcmfoQAABAAYAIGJwY3BmcHEW4TAGD_
BMcmbisIAFAHBjcGR0R_AHMCEBs5AAASACQXRhAAYLcWBwYuC2cCkv4EBjcGN0aOG2IAgxZHRgcG
DgNuDwBBBgcmB78HQCMOA04uAFUCCy4GBwIAFjMWABIDEwAiJiM9ACD_AEEBMRMGDhEAAB0BABAB
oAELPgMOAw4TDgNgAQMVAPEAAwvuC04bHis_C-4UKx4ryQASEvMAECtaAFILngsuS4YBET6WAQDK
ARFexAEQDicAQhsOSw7aARCLCABBHisuKxYA8Bb7AQ5bDvsDHvsADisO_wMOWx77Hw4D-h8DDxPz
HxXzHxUDBfMbPob0EAXzGQUTFSMB8xcBIxUzAfMVATMVQ-EVQxVDAfUTAUMTAAMhAAMvAAM9AH-z
HwUB9R8BKQglpfcfFicPDvgXDSeNEEEYDfcVHg5PGBcNBwIADgS0EC8HCAIADgOcDlQXCPcRCDcA
ZScI9wAI1xoAEQctDgSCDjENCA0EAADmBQYxAAh8Dg3KBQVKALUXDRcIJw0YBygHKEgAJQgnRwBC
1wj3BCwAGh1QAD0nCAcCAAE1AD8dBw0CABJ4GBcW9xsdF4cSIgQddQBQCGcYRxgtEEkIDfcBkhIv
B0iREgcvB0iPEgcAKQAGjhIRFyYABZESECdIEQ_QEgU6Nw0njxIuFx3vAQA2AAYWAC8XHQcBBlYY
DScNBwIAEx0_AgsAAjUXOA0VAA85AgcCzwAZDRAAD08AAz8YHQhQABIB-AAPUAAPH4dMABIB-xMP
TgAQPxdIF1AAER9ITAASAogBD04ADgI_Ew9QAA8-Nw03TgAQHmeaAA-TAScvDSdOADc-NxgHTQAQ
L0cYHQKIAKEDD1IAET8YDRhQABIvDTg5ATg-DQgXHwIoIg8aFQAPugIMNCwIBwIALw0n5gAFQhwP
GxwVAA-lAAaDDRwLAwscDQcCAAJLAAYCAANLAEQsAwsTJQABmgMDAgACRwAAKAyhHAMcAwyHDSgN
t-0G8QENKAwLAwtMaB1nHagNFxYnQgAzLHgd5AFyHZgNJxYnHDYAILdIzwXxKRwLDAtMx0j3AQYO
Fg8LEwsDCyr2FA4PDR47Ayv_FRk_GwMb-hYZDgkuK-4VCQ4ZHgkuC-4VCR4ZHQz0BgUuGT4F-hUF
PhlO9RVOGU4F_RMFThMAIS4FIQD-Bh4J-hkJHhkOCf4bCQ4Z-h8JBfkfBfkHJQ-tFKX-EwY3Fg79
Dw4WNwYODV8SDQb3DwYNXB0MDY72CY4NDB0M-h0FABgAdBEEBwAP9RQe8AEzQgTw--82AwAD8CAD
AANgCQBgFAMAIwADDwAAAgAk8BIPABIjDQAzAw8bGwDBAEMAA-AQIw4jAAMABgAADQATgwkAUQtT
LgsjQQCwDAMAIwsOAz4TDgsxACEKAy8AYAsOUwsuQw4A0DMOAwtjCyMOMwAD8AgbALATCw4jLgsz
DkPwBh4AgSMOCy4TCx4zIQABeAAAQADQMw4LQwsTDjMOQwAD0BMAIDMOSQAwDhMeSwARHnsA8gCQ
AwBjDiMeEw4LHgMLHiNDAFGQAwBTDkAAESNAAAFCAGFwAwADHhsXAFEDCxMOCwkAQQ4bHiMbAEEz
DjsOlwAhAwsYADE7DlNIAHETDiMOKw4jQwsACgAQA2AAMgADsBoAkhMOSw4DDkseIxYAEtAUAADQ
AFJTDhMOE80AAikAUBMOGyMLlgATA80AAhcAUSsuAx47HwARI1YAoDMOEw47DjMLDguSABADFgAB
iABAMw4rHjIAgAsTCyMOEx4rcQBQkCMeGw4xAFETCw4TC1AAABEAQAADcGOEABEe-gAAFwAxIy4T
5QAQUxcAQQsuAwtLABGDWQACaQFBEwsjHkIAAcgAAYoABG8BI0MLngACAgAS0DMAYSMeC0MLHhMC
EUDmAABaACluC_MBEGNSAAIPAnAzHgtjCx4zKQIA_gCQCz4zDgsOM-AOOAIxM04LUAJREx6DHhMJ
AFUOEwBzDgsAAosAAQ8AAxABAUQAQBPwEgNNAXFAAwBD8BIj2gIUIwkAA9YCJAOgCQCPwAPwIgPw
-5qDIx4PMQD---------------8kUG09N319
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTE0IDIxOjE0OjA5Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTE0IDIxOjE0OjA5Il1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTE0IDIxOjE0OjA5Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1NjozNyIscmV2aXNpb249MzI1MTddXWx6NACxAAAAwyAAAPAIe3tibXA9dXNlcmRh
dGEoImkxNiIsMzIDAF8iODAwMAQA----------8pFzAMAA8EAMgXYQwADwQA--------yPEOIiks
aGlkZGVuPWZhbHNlLHBhbl94PS0xMDYuNzUOAPICeT0tOTEuNSx0aWxlX2g9MTYKABB3CgCvem9v
bT0wLjV9LGMQCB8wAQD--------------------7D2MQBRU2YBAfN14QCVAuMjV9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTE0IDIxOjE0OjA5Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTE0IDIxOjE0OjA5Il1d
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTE0IDIxOjE0OjA5Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1NjozNyIscmV2aXNpb249MzIyMjNdXWx6NAAWBwAA8A4AAPBycHh1AAMoAAAEAAQP
QBACDgABoAEgAqAOAA8QAA3wyQwBAgMEBQYHEZAPDQkKDwsMDw0PDg8PAAGQAg8RDxIPEw8UDxUP
Fg8XAAGQAw8ZDxoPGw8cDx0PHg8fAA--kAQPIQ8iDyMPJA8lDyYPJwIP-5APKA8pDyoPKw8sDy0P
Lg8vJwDxAQ8wDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOvwGFoBEAYP
IxABIAEgAfAAAhACDx4QASAPISABEAIAD8AAAgAPKgABQBkAExQZACAPHRYAQH4gDGAWABETFgDw
PA0QATAPgCAP-mAIoA9L8AMKIA8OIA--IA-DIA7wRw89DzQPK7ABoAmgAQ2QBvCUD-gKD-8PgA-3
Dw0B8AkPMRAGDx8QASAJIAUB4FUAEyBrAPoOMA8soA8ZIA9cIA_o8KcNYA8oD--QDWAPJA9m8K5F
ABMBRABgARAREAHARQATMEUAsA-YD-4BMAEQATABFwAUPBcAlPIADrASEAIPMxEA-g7qYA3wdw8R
UA8aDQ8cDyawAQ1QDx8PegwND8TwrG4AFyA2ARMLRABAMA7ww6UALfDGMAAAIwAUBWUBEy8wAPwR
8L8CAQNAD-8PtA_KD3QPWg8-DzUPKg8lDxUPDwoF8LxGADQCDx92APARDxIQBgsAESAPKCAB4AEI
kB8UAALwAAEIkA0PC-CCAXCHAMMAAqACEUAPDw8aDypdAOA6D08Pnw8fDxoPFRoFAB4A-w8aD0UP
eg9qD1oPSg8-DzoPLw8lDxoPDwoVwA8O8HzIAAsQH4EAlyEQETAPbAABgAkBALYBaF8gBwACQBUA
diUgD1egEgARAPIO9yAPbfBjDygGDw6wAgFQDy8Pmg-5D3QPVQ86DyqmAI4-DxoBoAjwlIkAD4AB
Gw-mAg8CIAITJRoAdQ8SIA_AkAFdAAHjAk9_IA-94wIhawEQDxYPIbEAkQQAD-0AARACIH8A8QQC
MA8RAhAPBA8vUAEgAQ8EIA9HfgAgDx0rAEAgAQ-mpwCDgAADAAFQAQIKAgAYAMUWAAEAD4MAAwAC
8F_HACAPLYgAzg828AQPWw_bDzzwfREBFx5LAkACBAARTgDQCQABsAEIQAEAD2YAAWwAI-CgogIR
nyECcUUfOh81Dy_kAo4fDxofFQGgBR0DGQJcAEMGBBABXABiwAwQBg8TawD_AQ8E0AIIoAfwgwED
UAkAD01cAGyADzUADzJgAB--AQDUofAPQAANQA8wDzLEBj00DzIGAHMvDy1--w8vJAA9Mg8wBgDz
BC0PKf--CPEAfvEA-ggPGg8jDygmB-INLA8uDy0PKg8mDyMPIA8dDxsPGH4PGQ8dDx8PIlsH8gE-
KA8mDyUPIg8cDxj_CPBwkADwEUgeD0oPTB4PSA9MDg9IDg9MLg9KHg9MH00PTA9KD01uHACQTQ9P
Hg9MD08OJAD7Dk8uD00eD08fUQ9PD00PUW4CHhIeEg4CDgIuAh5SDgD5AQ8gHhseGw4LDgsuCx5b
bgsOAGLwBA8x8FuGABBPgQAwSg9MawBUD1FuDB4NAGMMD1NuBh4MAPEEBg9UTgQGDA4PTQ4GDg9P
DgQOCJMAIkoOewABBABJTiIOAgIAAnoAAQQASU4rDgsCAAIGAcMBMA8k-i8F-i8N-i8YAfAK-rDw
cAcADQALIA80Lg8yLg8wLg8tLg8wDgwAUy3_GQEuAgCDDgEuAf4ZCy4CAADcACD_GTwAJA8bRQAF
CACfDzceDzseDzwOCQAJdj4eDzweDzcJABkDGgB-Aw4BHgEeAQYAGF8LHgseCwYAGAi0APEeDxNA
DzIODzQODzYOHy9_Hy0OHysODygPKw8tDi8oLg8jDg8kDg8oHg8qHg8rBgDAIw8oHyoOHygOHyQO
HwBQIR4PCQ4CAKEZfhkOGQ4pDikuEAASHgIAIDkOFgAAEAACkQGQG34bDhsOKw4rSwECkQBxHgse
Ow4bDjkCGR6dAPEBFEAPIw6fKj4PKA4fI74PHm4A8g0jHl8hHg8eDyEfHj4KDyEKDi8cDgkOmT4J
Dhm_eAD1MVkeOT4pDikOCw4fIWsMPgsOHL4PIg4GHgYeNhweHBs_Dx8aDioOD6gAlDAEABSwBAAP
kBAIEDgUEDQwJAAkAAQYAPgRBBAEED8kH4QQMjASBAAkAA_sBA_vDyQ0n6sPJ6_r-pqtAAcGAuok
DyYPKP4tLwb_LSv_LR0ADwgAZfMDPyQOLx-_KD8GDiX_KDsOK-4oGAB8KQ4vKP4oNRcATisOLykX
AC-_sAgAC-MCDzCuA-4jDwSuAf4jC64L-iMXAPEKNA8yDgMJDgMJDzUuDzT_IxEOEQ4hLgH_Iw0C
FS4pAIW_Dzf_LwH_LxEAL-6wCACOH-8BAP_ZUP----8g
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTE0IDIxOjE0OjA5Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTE0IDIxOjE0OjA5Il1d
:: suite_scripts/
:: suite_scripts/confetti.lua
--[[pod_format="raw",created="2024-03-20 00:52:48",modified="2024-07-21 13:23:51",revision=2632]]

-- TODO change to user data?

confetti_all = {}
confetti_color_sets = {
	{21,2,24,8},
	{4,25,9,10},
	{1,16,12,28},
	{19,3,27,11}
}

function confetti_new(x, y, n, vel)
	for i = 1,n do
		local a, s = rnd(), rnd(vel)+0.1
		add(confetti_all, {
			x = x, y = y,
			dx = cos(a)*s, dy = sin(a)*s,
			f = rnd(0.2)+1, f2 = rnd(),
			size = rnd(1.5)+1.5,
			a = rnd(),
			c = rnd(4)\1+1
		})
	end
end

local mlx, mly = mouse()

function confetti_update()
	local mx, my = mouse()
	local mdx, mdy = mx - mlx, my - mly
	mlx, mly = mx, my
	
	local t = time() * 0.25
	for c in all(confetti_all) do
		
		-- swing
		local t = t * c.f + c.f2
		c.dx += sin(t) * 0.06
		c.dy -= abs(cos(t + 0.1)) * 0.06
		
		-- drag
		c.dx *= 0.94
		c.dy *= 0.94
		
		--gravity
		c.dy += 0.06
		
		-- mouse interaction
		local mdist = max(1/(0.5+sqrt((c.x-mx)^2+(c.y-my)^2)) - 0.02)
		c.dx += mdx * mdist
		c.dy += mdy * mdist
		
		-- movement
		c.x += c.dx
		c.y += c.dy
		
		-- rotate based on velocity
		c.a += 0.01 + c.dx * 0.02
		
		if c.y > 280 then
			del(confetti_all, c)
		end
	end
end

function confetti_draw()
	for c in all(confetti_all) do
		local col = confetti_color_sets[c.c][c.a*8%4\1 + 1]
		local w = sin(c.a) * c.size
		
		-- cheaper draw
		--rectfill(c.x-w, c.y, c.x+w, c.y+c.size*2, col)
		
		local dy = cos(c.a)*0.5
		local y = c.y - dy*abs(w)/2
		for x = c.x-w,c.x+w,sgn(w) do
			rectfill(x, y, x, y+c.size*2, col)
			y += dy
		end
	end
end



:: suite_scripts/main_menu.lua
--[[pod_format="raw",created="2024-03-19 15:14:10",modified="2024-12-15 00:56:37",revision=23616]]

include"cards_api/card_gen.lua"
include"suite_scripts/suite_mod_window.lua"

-- this isn't actually a game, but still uses the cards api, but instead a menu for all the game modes and options

cards_api_clear()
cards_api_shadows_enable(true)
main_menu_selected = nil
cards_animated = {} -- clears animated card backs to prevent overflowing memory

-- stores the original display palette just in case a custom game changes it.
if original_display_palette then
	poke(0x5000, unpack(original_display_palette))
else
	original_display_palette = {peek(0x5000, 0x400)}
end

-- x position of all the card boxes
local x_offset = smooth_val(0, 0.5, 0.1)

-- updates all of the tables containing modable data
function update_all_assets()
	
	-- initializes the list of game variant folders
	game_list = {}
	for loc in all{"card_games", suite_save_folder .. "/card_games"} do
		local trav = folder_traversal(loc)

		
		for p in trav do
			-- find any game info files
			if trav("find", "game_info.lua") then
				local op = add(game_list, {
					p:dirname(), p:basename(), 
					loc == "card_games" and " ." or split(p, "/", false)[5]

					-- expects /appdata/solitaire_suite/card_games/ *mod folder* / *game folder* /
				})
				trav"exit" -- don't allow recursive games
			end
		end
		
		end
		
	-- clear original animated card backs	
	cards_animated = {}

	-- initializes the card back info
	all_card_back_info = {}
	for loc in all{"card_backs", suite_save_folder .. "/card_backs"} do 
		local trav = folder_traversal(loc)
		local e = cap_env()
		
		for p in trav do
			for cb in all(ls(p)) do
				e.get_info = nil
				local p2 = p .. "/" .. cb
				
				if fstat(p2) == "file" and cb:ext() == "lua" then
					local ok, err1, err2 = cap_load(p2, e)
					
					-- send message of the file's error
					if not ok then
						cards_api_display_error(err1, err2)
					
					elseif e.get_info then
						for i, info in pairs(e.get_info()) do
							if type(info.sprite) == "function" then
								card_back_animated(info)
							end
							info.id = loc .. ":" .. i
							
							add(all_card_back_info, info)
						end
					end
				end
			end
		end
	end
	
	-- make sure the card back in question is available
	set_card_back(has_key(all_card_back_info, "id", settings_data.card_back_id) or rnd(all_card_back_info))
	
	-- initializes the ui for the assets
	update_game_options()
	update_card_back_options()
end

-- creates list of card box options
function update_game_options()
	-- cleanup
	main_menu_selected = nil
	for b in all(game_mode_buttons) do
		b:destroy()
	end

	-- creates buttons for each game mode
	game_mode_buttons = {}
	local bx = 2
	
	local unsorted_info = {}
	
	for game in all(game_list) do
		local p, n, group = unpack(game)
		
		local info_path = p .. "/" .. n .. "/game_info.lua"
		local info, err1, err2 = get_game_info(info_path)
		
		if not info then
			cards_api_display_error(err1, err2)
	
		else
			info = info()
			if info.api_version == api_version_expected then
			
				unsorted_info[group] = unsorted_info[group] or {}	
				local op = add(unsorted_info[group], info)
				
				op.order = op.order or 999
				op.game = p .. "/" .. n .. "/" .. n .. ".lua"	
				op.info_path = info_path
			end
		end
	end
	
	-- sorts the individual games in the groups
	local sortable_group = {} 
	for k,v in pairs(unsorted_info) do
		quicksort(v, "order")
		add(sortable_group, {k, v})
	end
	-- sorts the groups themselves
	quicksort(sortable_group, 1)

	-- creates the whole list of groups
	local all_info = {}
	for group in all(sortable_group) do
		for game in all(group[2]) do
			add(all_info, game)
		end
	end
	
	for info in all(all_info) do
		
		-- grab sprite 0 from 1.gfx if there is one for the game
		if not info.sprite then
			local extra_sprite = fetch(info.info_path:dirname() .. "/1.gfx")
			if extra_sprite then
				info.sprite = extra_sprite[0].bmp
			else
				info.sprite = 32
			end
		end
		
		-- if a number is provided for the sprite, use get_spr to allow for :width()
		if type(info.sprite) == "number" then
			info.sprite = get_spr(info.sprite)
		end
		
		add(game_mode_buttons, 
			button_new({
				x = bx, y = 100 - info.sprite:height() + 78, 
				width = info.sprite:width(), 
				height = info.sprite:height(),
				draw = button_deckbox_draw, 
				on_click = button_deckbox_click,
				
				sprite = info.sprite,
				game = info.game,
				info_path = info.info_path,
				info = info,
				x_old = bx,
			})
		)
		
		bx += info.sprite:width() + 10
	end
	
	if #game_mode_buttons > 1 then
		local third = game_mode_buttons[3] or game_mode_buttons[1]
		x_offset("pos", 240 - third.sprite:width() - 5 - third.x_old)
	else
		local first = game_mode_buttons[1]
		x_offset("pos", 240 - first.sprite:width()\2 - 1 - first.x_old)
	end
		
	button_deckbox_click()
end

-- creates list of card back options
function update_card_back_options()
	-- cleanup step
	
	-- delete all original cards and stacks
	local cs = get_all_cards()
	for c in all(cs) do
		c.stack = nil
		del(cs, c)
	end
	local st = get_all_stacks()
	for s in all(st) do
		del(st, s)
	end
	

	-- init step
	
	card_back_edit_button = stack_new(
		{10}, 300, 190, 
		{
			reposition = stack_repose_normal(),
			can_stack = function() return true end, 
			on_click = function(c)
				stack_on_click_unstack()(c)
				main_menu_y_to = 1
			end,
			resolve_stack = swap_stacks,
			x_off = -12,
			y_off = -13,
		})
		

	local cb_sprite = suite_card_back()
	local cb = has_key(all_card_back_info, "id", settings_data.card_back_id)
	local cb_front = cb.gen and cb.gen() or card_gen_back({sprite = cb.sprite})
			
	local c = card_new({
			sprite = cb_front, 
			back_sprite = cb_sprite,
			x = 300,
			y = 190
		})
	c.info = card_back
	stack_add_card(card_back_edit_button, c)
	

	local card_width = 45
	local card_height = 60 
	
	local function create_card_back_stack(i)
		local s = stack_new(
			{9},
			(i\2)*(60) + 7, 365 + i%2 * (card_height + 10) + 17, 
			{
				reposition = stack_repose_normal(),
				can_stack = function(stack) 
					if #card_back_edit_button.cards == 0 then
						return #stack.cards == 1
					end
					return true
				end, 
				on_click = stack_on_click_unstack(),
				resolve_stack = swap_stacks,
				x_off = -7,
				y_off = -4,
			})
		s.base_x = s.x_to
			
		return add(card_back_options, s)
	end

-- adds card back options
	card_back_options = {}
	for cb in all(all_card_back_info) do
		if cb.id ~= card_back.id then
			local s = create_card_back_stack(#card_back_options)
			
			local front_sprite = nil
				
			if cb.gen then
				front_sprite = cb.gen()	
			else
				front_sprite = card_gen_back({sprite = cb.sprite})
			end
			
			
			local c = card_new({
				sprite = front_sprite,
				back_sprite = cb_sprite,
				stack = s
			})
			c.info = cb
		end
	end
	
-- adds extra card back slots for looks
	local extra = 0
	while #card_back_options < 16 
	or #card_back_options % 4 ~= 0
	or extra < 4 do
		extra += 1
		create_card_back_stack(#card_back_options)
	end
	card_back_scroll_max = min(480 - #card_back_options \ 2 * 60)
	for i = -4,-1 do
		create_card_back_stack(i)
	end
end

-- draw shadows, based on the the boxes size
-- 32 is the shadow applying color
function box_shadow(x1, y1, x2, y2)
	fillp(0xa5a5a5a5)
	rect(x1,y1,x2,y2, 32)
	rect(x1+1,y1+1,x2-1,y2-1)
	rectfill(x1+4,y1+4,x2-4,y2-4)
	fillp()
	rectfill(x1+2,y1+2,x2-2,y2-2)
end

-- draw function for the card boxes
function button_deckbox_draw(b)
	box_shadow(b.x-3, b.y+10, b.x+b.width+2, b.y+b.height+2)
	
	-- interpolates the draw position
	b.y2 = lerp(b.y2 or 0, (b.highlight and 3 or 0) + (b == main_menu_selected and 8 or 0), 0.15)
	-- didn't want to do lerp, but it's simpler here >:(
	spr(b.sprite, b.x, b.y - (b.y2 + 0.5)\1)
end

-- on_click function for the card boxes
function button_deckbox_click(b)
	main_menu_selected = b
	--rule_cards.info = b.info
	--rule_cards.page = 0
	
	local s = get_spr(21)
	local w, h = s:width(), s:height()
	game_description = userdata("u8", w, h)
	
	local old_x, old_y = camera()	
	set_draw_target(game_description)
	
	rectfill(3, 3, w-3, h-3, 7)
	
	-- give info
	if b and b.info then
		local info = b.info
		
		local x = print_size(info.name)
		double_print(info.name, 179/2-x/2+4, 7, 2)
		
		local by = "\nBy " .. info.author
		local x = print_size(by)
		double_print(by, 179/2-x/2+4, 7, 1)
		
		local s =  "\n\n" .. info.description
		local loreprint, lw, lh = print_wrap_prep(s, 175)
		double_print(loreprint, 6, 7, 1)
		
		if info.desc_score then
			local sc = info.desc_score
			
			local vals = {}
			local save = fetch(suite_save_folder .. "/saves/"
				.. suite_get_game_name(info.game) .. ".pod") or {}
	
			for p in all(sc.param) do
				add(vals, save[p] or 0)
			end
						
			local s = string.format(sc.format, unpack(vals))
			double_print(s, 6, 64, 1)
			
			fillp(0xa5a5a5a5a5a5a5a5)
			rect(1,61,w,61,32)
			fillp()
		end
		
	-- say click to get description
	else
		local s =  "Click a deck box to see information about it."
		local loreprint, lw, lh = print_wrap_prep(s, 175)
		double_print(loreprint, 6, 7, 1)
	end
	
	rect(4,5,w-5,h-2, 32)
	spr(21)
	
	set_draw_target()
	camera(old_x, old_y)	
end

-- sets the card back and saves the setting
function set_card_back(info)
	card_back = info
	assert(info)
	
	suite_card_back_set(info)
	
	if cards_all and cards_all[1] then
		local old_sp = cards_all[1].back_sprite
		if old_sp.destroy then
			old_sp:destroy()
		end
	end
	
	local sp = suite_card_back()
	for c in all(cards_all) do
		c.back_sprite = sp
	end
	
	settings_data.card_back_id = info.id
	suite_store_save(settings_data)
end

-- draw function for the current cardback slot
local function card_button_draw(button)
	local left = button.highlight and 6 or 0
	button.t = lerp(button.t, left, 0.2)
	nine_slice(8, button.x + button.t, button.y + button.off, button.width, 45)
	double_print(button.str, button.x2 + button.t, button.y+3, button.col)
end

-- draw function for the current cardback slot
local function card_button_new(str, col, y, on_click, offset)
	button_new({
		x = 205, y = y, 
		width = 65, height = 13, 
		draw = card_button_draw, 
		on_click = on_click,
		
		str = str,
		col = col,
		x2 = 205 + (65 - print_size(str)) \ 2,
		t = 0,
		off = offset or 0,
	})
end


function game_setup()
	-- loads the main settings
	settings_data = suite_load_save() or {
		card_back_id = 1
	}

	main_menu_y = smooth_val(0, 0.8, 0.023, 0.00001)
	main_menu_y_to = 0
	
	local cb = {
		{"Start Game", 8, 
			function() 
				if main_menu_selected then
					last_selected_game = main_menu_selected.info_path
					game_info = get_game_info(main_menu_selected.info_path)
					suite_load_game(main_menu_selected.game)
				end
			end
		},
		{"Manage Mods", 16, suite_open_mod_manager},
		{"Settings", 27, suite_open_settings},

-- TODO, what does this actually need to be?
		{"Exit Game", 25, exit},
	
		 
	}
	for i, d in pairs(cb) do
		local f = d[3]
		
		-- prevent buttons from being clicked when the camera is moving
		d[3] = function(...)
			if abs(main_menu_y"vel") < 0.01 then
				f(...)
			end
		end
		
		card_button_new(d[1], d[2], 185 + (i-1 + 4-#cb)*13, d[3])
	end
			
	card_button_new("Return", 16, 310, 
		function() 
			main_menu_y_to = 0
		end, -30)
	
	
	
-- adds card back scrolling buttons
	card_back_scroll_to = 0
	card_back_scroll = smooth_val(0, 0.7, 0.04, 0.05)

	local function scroll(x)
		return function (b)
			b.t = 1
			card_back_scroll_to = mid(120, card_back_scroll_to + x, card_back_scroll_max)
		end
	end
	-- scrolling button draw function
	local function draw_button(b)
		b.t = max(b.t - 0.07)
		local y = ((b.t*2-1)^2 * 2.5 - 1.5) \ 1
		local h = 20 + y
		spr(2, b.x-4, b.y-2)
		sspr(b.highlight and 4 or 3, 0, 0, 21, h, b.x, b.y-y, 21, h, b.fl)
	end

	-- card back scrolling buttons
	button_new({
		x = 215, y = 335, 
		width = 20, height = 21, 
		draw = draw_button, 
		on_click = scroll(120),
		
		t = 0,
		fl = true,
	})
	button_new({
		x = 245, y = 335, 
		width = 20, height = 21, 
		draw = draw_button, 
		on_click = scroll(-120),
		
		t = 0
	})	

	update_all_assets()
	

	-- if there's only one game, auto select it
	if #game_mode_buttons == 1 then
		game_mode_buttons[1]:on_click()
		menu_selected_inst = true
	end
	
	if last_selected_game then
		for b in all(game_mode_buttons) do
			if b.info_path == last_selected_game then
				b:on_click()
				menu_selected_inst = true
				last_selected_game = nil
			end
		end
	end
end

-- also updates the card back
function swap_stacks(stack, stack2)
	local old_cards = {}
	local old_stack = stack2.old_stack
	
	for c in all(stack2.cards) do
		add(old_cards, c)
	end
	
	for c in all(stack.cards) do
		add(old_stack.cards, del(stack.cards, c))
		card_to_top(c)
		c.stack = old_stack
	end
	
	for c in all(old_cards) do
		add(stack.cards, del(stack2.cards, c))
		card_to_top(c)
		c.stack = stack
	end
	
	stack2.old_stack = nil
	
	if not stack2.perm then
		del(stacks_all, stack2)
	end
	
	set_card_back(card_back_edit_button.cards[1].info)
end

function game_update()
	local x_to = main_menu_selected and 240 - main_menu_selected.sprite:width()/2 - main_menu_selected.x_old or x_offset()
	local x = x_offset(x_to) 
		
	-- instantly move to the position of the selected box
	if menu_selected_inst then
		x_offset("pos", x_to)
		x_offset("vel", 0)
		menu_selected_inst = false
	end
		
	for b in all(game_mode_buttons) do
		b.x = x + b.x_old
	end
	
	main_menu_y(main_menu_y_to)
	
	local new_to = lerp(196.5, 281.5, main_menu_y())\1
	local d_to = new_to - card_back_edit_button.y_to
	card_back_edit_button.y_to = new_to
	for c in all(card_back_edit_button.cards) do
		c.y("pos", c.y() + d_to)
	end
	
	
	local sc = card_back_scroll(card_back_scroll_to)\1

	for s in all(card_back_options) do
		local newx = s.base_x + sc
		local dx = newx - s.x_to
		s.x_to = newx
		
		for c in all(s.cards) do
			c.x("pos", c.x() + dx)
		end
	end
end

function game_draw(layer)
	if layer == 0 then		
		
-- example color palette
		cls(3)
		

	
		local cy = main_menu_y() * 260.5
		camera(0, cy)	
		-- EDIT THIS (make your own little logo for your mod package)
		spr(22, 121, 2)
	
		-- keep this, it's based on the suite version
		print("Version " .. game_version, 1, 262, 19)
		


		print("Mostly by Werxzy", 399, 261)



		
	-- card back info
		local full_w = 187 - 12
		local x, y = 10, 283
		
		local s = "Artist : " .. card_back.artist
		local w = print_size(s)
		local loreprint, lw, lh = print_wrap_prep(card_back.lore, full_w)
		
		rectfill(x + 2, y + 2, x + 185, y + 76, 7)
		
		double_print(s, full_w/2 + x + 6 - w/2, y + 12, 1)
		double_print(loreprint, full_w/2 + x + 6 - lw/2, y + 28, 1)
		
		rect(x + 4, y + 5, x + 182, y + 76, 32)	
		spr(21, 10, y)	
		

	-- game info
		spr(game_description, 8, 182)
		
	-- card back selection details
		rectfill(0, 518, 480, 519, 3)
		rectfill(0, 530, 480, 540, 21)
		for i = 0, 479,175  do
			spr(12, i, 364)
			spr(12, i, 520)
		end
			
		local sc = card_back_scroll()\1
		local i2 = sc - sc % 78
		for i = -78-i2, 479-i2,78  do
			spr(11, i+sc, 372)
		end
		
	elseif layer == 1 then
		box_shadow(203, 241-3, 203+73, 241+12)
		box_shadow(203-3, 260, 203+73+3, 309)
		spr(1, 203, 241)
	end
	
end


function cards_game_exiting()
	suite_load_game"suite_scripts/main_menu.lua"
end


function game_on_error()
	-- call's the subgame's original game_on_error function, if provided
	if (subgame_on_error) subgame_on_error()
	suite_load_game"suite_scripts/main_menu.lua"
end


:: suite_scripts/rolling_score.lua
--[[pod_format="raw",created="2024-03-18 21:28:46",modified="2024-07-21 13:23:51",revision=873]]

function rolling_score_update(s)
	local val = s.value or 0
	
	for i = #s.digits, 1, -1 do
		local v = val%10
		local dif = min((v - s.digits[i]) % 10, s.speed)
		
		s.digits[i] += dif

		val \= 10
	end
end

function rolling_score_draw(s)
	for i = 1,#s.digits do
		local sy = s.digits[i]
		local x, y = (i - 1)*s.spread + s.x, s.y
				
		sy += sin(sy) * 0.3 -- little shift
		sy = (9 - sy) * s.dh -- proper direction
		sy %= s.dh*10 -- looping
		
		sspr(s.sprite, 0, sy, s.dw, s.dh, x + s.x2, y + s.y2)
		if sy > s.dh*9 then -- looping digit
			sspr(s.sprite, 0, sy-s.dh*10, s.dh, min(sy - s.dh*9, s.dh), x + s.x2, y + s.y2)
		end
		
		if s.draw_extra then 
			s:draw_extra(x, y)
		end
	end
end
	
--[[
x,y = top left of score
x2,y2 = extra offsets for the digits
spread = horizontal spread between digits
dw,dh = digit sprite size (single digit)
sprite = sprite id or userdata
draw_extra = extra draws done for each digit
]]
function rolling_score_new(x, y, x2, y2, spread, dw, dh, digits, sprite, draw_extra)
	local d = {}
	for i = 1,digits do
		add(d, 0)
	end
	
	return {
		x = x, y = y,
		x2 = x2, y2 = y2,
		spread = spread, 
		dw = dw, dh = dh,
		digits = d,
		value = 0,
		sprite = sprite,
		update =rolling_score_update,
		draw = rolling_score_draw,
		draw_extra = draw_extra,
		speed = 0.05
	}
end
:: suite_scripts/suite_buttons.lua
--[[pod_format="raw",created="2024-06-12 07:48:24",modified="2024-07-21 13:23:51",revision=5285]]

local menuitems = {}
local pages_buttons = {}

local suite_page_number = 1
local suite_openned_pages = nil
local suite_next_pages = nil
local suite_pages_t = 0
local suite_pages_x = smooth_val(0, 0.5, 0.1, 0.0001)

local function suite_button_on_destroy(button)
	del(menuitems, button)
end

local function suite_pages_on_destory(button)
	del(pages_buttons, button)
end

local function suite_button_draw(button)
	local x, y = button.x, button.y
	local w = button.width
	local l = button.left
	
	local ox, oy = camera(-x, -y)
	color(button.colors[2])
	
	rectfill(4 + l, 13, button.width+3, 15)
	
	for i = 0, 3 do
		local y = 2 + i * 3
		rectfill(i, y, i, y+2) 
	end
	camera(ox, oy)
	

	y -= (button.t*2-1)^2 * 2.5 - 2.5
	camera(-x, -y)
	
	button.t = max(button.t - 0.07)
	
	color(button.colors[button.highlight and 3 or 1])
	
	w -= 2
	rectfill(l, 0, w, 1)
	rectfill(l+1, 2, w+1, 4)
	rectfill(l+2, 5, w+2, 7)
	rectfill(l+3, 8, w+3, 10)
	rectfill(l+4, 11, w+4, 12)
	
	color(button.colors[2])
	for i = 1, 12 do
		pset((i+1)\3 + w+1, i) 
	end
	
	print(button.text, 7, 3, 22)
	print(button.text, 7, 2, 7)		
	

	if button.value then
		pal(2, button.colors[2])
		sspr(61, 0, 0, button.valw, 11, button.valx, 1)
		sspr(61, 43, 0, 8, 11, button.valx+button.valw, 1)
		pal(2,2)
		print(button.value, button.valx+4, 3, 16)
	end
	camera(ox, oy)
	
	
end

function suite_button_set_value(button, value)
	button.value = value
	-- TODO update layout to fit the new string
end

--[[
creates a button for the menu bar

param is a table with the following possible values

text = text displayed on the button
on_click = function called when the button is clicked
value = extra info displayed next to the text that can be updated, like a win counter
	can be left nil
pages = table of information that be displayed on a seperate window when the button is clicked
	note that this will replace the on_click call
	needs to have the following
	width, height = size of display area
	content = table of strings or userdata to be displayed
colors = table of color values to draw the button with
]]
function suite_menuitem(param)
	local text = param.text or ""
	local on_click = param.on_click
	local value = param.value
	
	if param.pages then
		on_click = suite_menuitem_display_pages
	end
	
	local last = menuitems[#menuitems]
	local x = last and last.x+last.width or 0
	local w = print_size(text) + 10
	
	local b = button_new({
		x = x, y = 255, 
		width = w, height = 15, 
		draw = suite_button_draw, 
		on_click = on_click and function(b)
			b.t = 1
			on_click(b)
		end,
		bottom = true,
		group = 2,
		always_active = param.always_active
	})
	
	b.pages = param.pages
	b.t = 0
	b.text = text
	b.colors = param.colors or {4, 20, 21}
	b.on_destroy = suite_button_on_destroy
	b.set_value = suite_button_set_value
	b.left = #menuitems == 0 and -4 or 0
	
	if not text or #tostr(text) == 0 then
		b.width -= 4
	end

	if value then
		local valw = print_size(value)
			
		b.value = value
		b.valw = valw
		b.valx = b.width - 2
		b.width += valw + 7
	end
	
	return add(menuitems, b)
end

-- specifically for setting up pages
local function suite_pages_button(param)	
	local text = param.text or ""
	local on_click = param.on_click
		
	local w = print_size(text) + 10
	
	local b = button_new({
		x = -100, y = 0, 
		width = w, height = 15, 
		draw = suite_button_draw, 
		on_click = on_click and function(b)
			b.t = 1
			on_click(b)
		end,
		bottom = true,
		group = 2,
		always_active = true,
		
		t = 0,
		text = text,
		colors = {4, 20, 21},
		left = param.left or 0,
		on_destroy = suite_pages_on_destory
	})
	
	if not text or #tostr(text) == 0 then
		b.width -= 4
	end
		
	return add(pages_buttons, b, 1)
end

function suite_menuitem_update_sizes()
	-- TODO
end

-- creates most of the menu bar at the bottom of the screen. Very important to call or add something similar
function suite_menuitem_init()
	local clock = suite_menuitem({
		colors = {27,3,19}, 
		value = "\fc12\fg\-f:\-e\fc00"
	})
	local old_draw = clock.draw
	clock.draw = function(b)
		b.value = date("\fc%H\fg\-f:\-e\fc%M")
		old_draw(b)
	end
	
	suite_menuitem({
		text = "Exit", 
		colors = {8,24,2},
		on_click = function()
			suite_exit_game()
		end,
		always_active = true
	})
	
	suite_menuitem({
		--text = "\^:7f00007f00007f00",
		text = "\^:1f00003e00007c00\-a\^:1f00003e00007c00",
		colors = {27,3,19},
		on_click = suite_open_settings,
		always_active = true
	})
	
	suite_pages_button({
		text = "   ",
		left = -400
	})	
	suite_pages_button({
		text = "\^:63773e1c3e776300", 
		on_click = suite_menuitem_close_pages
	})
	suite_pages_button({
		text = ""
	})
	suite_pages_button({
		text = " \^:60787e7f7e786000 ", 
		on_click = function()
			if suite_openned_pages then
				suite_page_number = max(suite_page_number - 1, 1)
			end
		end
	})
	suite_pages_button({
		text = " \^:030f3f7f3f0f0300 ", 
		on_click = function()
			if suite_openned_pages then
				suite_page_number = min(suite_page_number + 1, #suite_openned_pages.pages.content)
			end
		end
	})
	
end

-- quick way of getting a rules page done
-- width and height are the size of the display area of the rules text
function suite_menuitem_rules(width, height)
	return suite_menuitem({
		text = "Rules", 
		pages = {
			width = width or 175,
			height = height or 80,
			content = game_info().rules,
		},
		always_active = true
	})
end

local function suite_button_simple_draw(b)
	pal(16, b.col[2])
	pal(1, b.col[3])
	pal(12, b.col[1])
	
	spr(b.spr1, b.x-3, b.y)
	
	pal(12, (b.highlight or b.selected) and b.col[3] or b.col[1])	
	
	b.ct += mid((b.selected and 0.5 or 0) - b.ct, -0.07, 0.07)
	local click_y =  ((b.ct*2-1)^2 * 2.5 - 2.5) \ 1
	
	sspr(b.spr2, 
		0,0, 
		b.width,b.height+click_y, 
		b.x,b.y-click_y) 
	
	pal(12, 12)	
	pal(16, 16)
	pal(1, 1)	
end

--[[
creates a simple button

param is a table with the following possible values

x, y = position of the button
text = text displayed on the button, also controlling the size
on_click = function called when the button is clicked
group = drawing group the button belongs to, defaults to 1
always_active = if true, then the button can be clicked even if an animation is playing
colors = table of colors that the button is drawn with

]]
function suite_button_simple(param)
	local text = param.text or " "
	local w, h = print_size(text)
	w += 9
	h += 4
	
	local on_click = param.on_click

	local b = button_new({
		x = param.x, y = param.y, 
		width = w, height = h, 
		draw = suite_button_simple_draw, 
		on_click = function (button)
			button.ct = 1
			if on_click then
				on_click(button)
			end
		end,
		group = param.group,
		always_active = param.always_active,
		col = param.colors or {27,3,19},
		ct = 0,
		text = text
	})
	
	local cx, cy = camera()

	b.spr1 = userdata("u8", b.width + 6, b.height + 4)
	set_draw_target(b.spr1)
	nine_slice(17, 0, 0, b.spr1:width(), b.spr1:height())
	
	b.spr2 = userdata("u8", b.width, b.height)
	set_draw_target(b.spr2)
	nine_slice(18, 0, 0, b.spr2:width(), b.spr2:height())
	print(text, 5, 3, 22)
	print(text, 5, 2, 7)
	
	set_draw_target()
	camera(cx, cy)
	
	return b
end

-- page display functions

function suite_menuitem_draw_pages()

	if suite_next_pages then
		local x = suite_pages_x(0)
		
		-- next page group
		if x <= 0 then
			suite_page_number = 1
			suite_pages_t = 1
			suite_openned_pages = suite_next_pages
			suite_next_pages = nil
		end
	
	elseif suite_openned_pages then
		local x = suite_pages_x(suite_pages_t)
		
		if x <= 0 and suite_pages_t == 0 then
			suite_openned_pages = nil
		end
	end

	if not suite_openned_pages then
		return 
	end
	
	local pos = suite_pages_x"pos"
	local p = suite_openned_pages.pages
	
	pos = (1 - pos) * (p.width + 10)
	local oldx, oldy = camera(pos, 0)
	for i, b in pairs(pages_buttons) do
		pos += b.width
		b.x = p.width  - pos - 1
		b.y = 270 - p.height - 37 -- test
	end
	
	local y = 270-15-p.height - 6
	local x = 0
	local w, h = p.width, p.height
	
	rectfill(x, y, x+w-1, y+h-1, 7)
	rect(x-1, y, x+w-1, y+h, 32)
	
	local c = p.content[suite_page_number]
	local ty = type(c)
	
	if ty == "string" then
		local c = print_wrap_prep(c, p.width-4)
		double_print(c, x+2, y+2, 1)
		
	elseif ty == "userdata" or ty == "number" then
		spr(c, 0, 100)
	end
	
	
--	rectfill(x, y-2, x+w+2, y-1, 20)
	
--	rectfill(x, y-12, x+w-46, y-3, 4)
--	rectfill(x, y-11, x+w-42, y-3, 4) -- VERY temp
--	pset(x+w-45, y-11, 20) -- VERY VERY temp
	
--	spr(19, x+w-22, y-12)
--	spr(20, x+w-44, y-12)
	
	rectfill(x+w, y-1, x+w+2, y+h-1, 4)
	rectfill(x, y+h, x+w+2, y+h+2, 4)
	rectfill(x, y+h+3, x+w+2, y+h+4, 20)
	
	camera(oldx, oldy)
end

-- displays the information on the pages window
function suite_menuitem_display_pages(button)
	if button == suite_openned_pages then
		suite_pages_t = 1 - suite_pages_t
	else
		suite_next_pages = button
	end
end

function suite_menuitem_close_pages()
	suite_pages_t = 0
end

function suite_menuitem_remove_pages()
	suite_openned_pages = nil
	suite_pages_t = 0
	suite_pages_x("pos", 0)
end

:: suite_scripts/suite_extra_window.lua
--[[pod_format="raw",created="2024-06-24 16:28:42",modified="2024-07-21 13:23:51",revision=3011]]

suite_window_to = -0.1
suite_window_t = smooth_val(0, 0.87, 0.02, 0.00003)
suite_window_buttons = {}
suite_window_elements = {}
suite_window_width, suite_window_height = 300, 200
suite_window_title = "\^w\^tSettings"
local suite_window_layout_y = 10

-- TODO: page control?
-- TODO: better control for custom elements?


-- extra functions for windows with custom elements in custom games
function get_suite_window_layout_y()
	return suite_window_layout_y
end
function set_suite_window_layout_y(y)
	suite_window_layout_y = y
end
function suite_window_add_element(el)
	add(suite_window_elements, el)
end
function suite_window_add_button(button)
	add(suite_window_buttons, button)
end

-- initializes a window with the given title and width
-- height is entirely dependant on the contents
function suite_window_init(name, width)
	-- clear old buttons and draw elements
	for b in all(suite_window_buttons) do
		b:destroy()
	end
	suite_window_buttons = {}
	suite_window_elements = {}
	suite_window_layout_y = 9
	suite_window_to = 1
	suite_window_width = width or 300
	suite_window_title = "\^w\^t" .. name
	
	-- interaction blocker
	suite_window_blocker = button_new({
		x = -1000, y = -1000, 
		width = 3000, height = 3000, 
		draw = function() end, 
		group = 3
	})

	suite_window_is_settings = name == "Settings"
end

-- creates an exit button for the window
-- exit_text is a string that is by default "Exit"
function suite_window_footer(exit_text)
	if #suite_window_buttons > 0 or #suite_window_elements > 0 then
		suite_window_add_divider(5, 6)
	end

	-- forced-ish exit button
	suite_window_add_buttons({{exit_text or "Exit", suite_close_window}}, true)

	-- change height of settings menu to fit the buttons
	suite_window_height = suite_window_layout_y + 7
end

-- draw function for the window
-- already handled by the suite
function suite_window_draw(layer)
	local sett_x, sett_y = (480 - suite_window_width) / 2, (270 - suite_window_height) / 2 + 20
		
	if layer == 2 then
		suite_menuitem_draw_pages()
		
		local cx, cy = camera() -- for fixing the button position based on camera
		
		local y = (1 - suite_window_t(suite_window_to)) * 270 + sett_y
		y \= 1
		for b in all(suite_window_buttons) do
			b.x = b.base_x + sett_x + cx
			b.y = b.base_y + y + cy
		end
		
		camera(cx, cy)
		
	elseif layer == 3 then
	
		local y = suite_window_t"pos"
		if y > 0 then
			y = (1-y)*270 + sett_y
			y \= 1
						
			local cx, cy = camera(-sett_x, -y)
			
			local w, h = print_size(suite_window_title)
			
			rectfill(w+10, -h, 
				w+30, h+20, 32)
			nine_slice(35, 0, -h-20, 
				w+20, h+20, 20)
			
			print(suite_window_title, 11, -h-7, 21)
			print(suite_window_title, 11, -h-1-7, 4)
				
			
		
			--[[
			rectfill(0,suite_window_height,
				suite_window_width-1,suite_window_height+10, 32)
			rectfill(0,0,
				suite_window_width-1,suite_window_height-1, 7)
			--]]
			rectfill(0, 10, 
				suite_window_width+19,suite_window_height+30, 32)
			nine_slice(33, -10, -10, 
				suite_window_width+20, suite_window_height+20, 7)
				
			for el in all(suite_window_elements) do
				el()
			end
			
			camera(cx, cy)
		end
	end
end


function suite_open_settings()
	suite_window_init("Settings")
	
	if(game_settings_opened) game_settings_opened()
	
	if #suite_window_buttons > 0 or #suite_window_elements > 0 then
		suite_window_add_divider(5, 6)
	end
	
	-- TODO fill with more things
	-- probably volume control or others
	
-- [[
	-- TEMP options for testing out ui functions
	local function pr()end
	suite_window_add_options("TODO: more settings", pr, {"Okay", "Ok", "K"}, 1)
	suite_window_add_range("Volume?", pr, "%i%%", 0, 100, 10, 50)
--]]

	suite_window_footer("Exit Settings")
end

-- closes the current window
function suite_close_window()
	suite_window_to = -0.1
	suite_window_blocker:destroy()
	suite_window_blocker = nil
	
	-- only call function for the settings
	if(suite_window_is_settings and game_settings_closed) game_settings_closed()
end

-- adds a button to the list of settings buttons
-- and manages it's position and clickability
function suite_window_button_add(button)
	add(suite_window_buttons, button)
	local old_destory = button.on_destroy
	
	button.on_destroy = function(b)
		del(suite_window_buttons, b)
		if old_destroy then
			old_destroy()
		end
	end
	
	button.on_click = suite_window_button_check(button.on_click)
	button.base_x = button.base_x or button.x
	button.base_y = button.base_y or button.y
end

-- prevents button from being pressed unless the menu is open
function suite_window_button_check(func)
	if func then
		return function(button)
			if suite_window_to >= 1 then
				func(button)
			end
		end
	end
end


-- available button types to add to the settings menu

-- adds multiple buttons in a row, each with their own function to call
-- ops = {{name, func}, {...}, ...}
function suite_window_add_buttons(ops, right_side)
	local b = suite_window_add_mulibutton(suite_window_layout_y, ops, right_side)	
	suite_window_layout_y += 20
	return b
end

-- adds multiple buttons, but only one should be selected at a time
function suite_window_add_options(name, func, ops, current)

	local y = suite_window_layout_y
	
	-- updates the selected status of a button
	local buttons, x = nil
	local function update_options()
		for i, b in ipairs(buttons) do
			b.selected = i == current
		end
	end

	-- wraps the functions to control the appearance of the button
	-- also to control what buttons are selected
	local ops2 = {}
	for i, o in ipairs(ops) do
		add(ops2, {o,
			function(b)
				current = i
				update_options()
				func(i)
			end
		})
	end
	
	-- adds the button options
	buttons, x = suite_window_add_mulibutton(y, ops2, true)
	update_options()
	
	-- adds text label
	suite_window_add_text_part(name, x-8, y)

	suite_window_layout_y += 20
end

function suite_window_add_range(name, func, format, t0, t1, inc, current, inc_width)

	local y = suite_window_layout_y
	inc_width = inc_width or 6
	if type(format) == "string" and #format == 0 then
		format = nil
	end
	
	-- increment buttons
	local b2 = suite_button_simple({
		text = "+", 
		x = suite_window_width - 23, y = y, 
		on_click = function()
			current = mid(current + inc, t0, t1)
			func(current)
		end,
		group = 3,
		always_active = true
	})

	local b1 = suite_button_simple({
		text = "-", 
		x = suite_window_width - 130, y = y, 
		on_click = function()
			current = mid(current - inc, t0, t1)
			func(current)
		end,
		group = 3,
		always_active = true
	})
	
	-- calculates number of marks
	local i1 = (t1-t0) \ inc
	
	-- calculates left edge of marks
	local left = b2.x - i1 * inc_width - 7
	
	-- repositions "-" button based on size
	b1.x = left - b1.width - 8
	local x2 = b1.x - 6
	
	-- add text
	suite_window_add_text_part(name, b1.x - 8, y)
	
	-- draw marks
	if inc_width <= 3 then
		add(suite_window_elements, function()
			
			for i = 0,i1-1 do
				local x = i*inc_width + left
				rectfill(x, y+4, x+inc_width-2, y+16, current-t0 >= (i+1)*inc and 1 or 32)
			end
		end)
		
	else
		add(suite_window_elements, function()
			-- draw marks
			for i = 0,i1-1 do
				local x = i*inc_width + left
				color(current-t0 >= (i+1)*inc and 1 or 32)
				rectfill(x+1, y+4, x+inc_width-3, y+16)
				rectfill(x, y+5, x+inc_width-2, y+15)
			end
		end)
	end
	
	
	-- draw value
	
	add(suite_window_elements, function()
		local s = current
		if(format) s = string.format(format, s)

		local w, h = print_size(s)
		rectfill(x2 - w - 2, y + 3, x2+1, y+h+3, 7)
		double_print(s, x2 - w, y + 5, 1)
	end)
	
	-- add buttons
	suite_window_button_add(b1)
	suite_window_button_add(b2)
	
	suite_window_layout_y += 20
end

-- adds a simple divider to separate elements
function suite_window_add_divider(edge, col)
	local y = suite_window_layout_y + 2
	
	add(suite_window_elements, function()
		rect(edge, y, suite_window_width - edge - 1, y, col) 
	end)
	
	suite_window_layout_y += 5
end

-- ui helper that adds a text label to a row
function suite_window_add_text_part(str, right_x, y)

	local tw = print_size(str) + 13
	
	-- adds text label and dotted line
	add(suite_window_elements, function()
		fillp(0x77777777)
		rectfill(tw, y+12, right_x, y+12, 32) 
		fillp()

		double_print(str, 10, y+5, 2)
	end)
end

-- ui helper that adds multiple buttons in a packed row
function suite_window_add_mulibutton(y, ops, right_side)
	-- creates a button for each option
	local op_buttons = {}
	for o in all(ops) do
		add(op_buttons, suite_button_simple({
			text = o[1], 
			x = 0, y = y, 
			on_click = o[2], 
			group = 3,
			always_active = true
		}))
	end
	
	local x = 10
	
	if right_side then
		-- repositions buttons to be packed correctly on the right side
		x = suite_window_width
		for i = #op_buttons, 1, -1 do
			local b = op_buttons[i]
			
			x -= b.width + 10
			b.x = x
			
			suite_window_button_add(b)
		end
		
	else
		-- repositions buttons to be packed correctly on the left
		for i = 1, #op_buttons do
			local b = op_buttons[i]
			b.x = x
			x += b.width + 10
						
			suite_window_button_add(b)
		end
	end	

	return op_buttons, x
end

-- other potential ui elements for the settings menu

:: suite_scripts/suite_mod_window.lua
--[[pod_format="raw",created="2024-07-01 20:21:05",modified="2024-07-21 13:23:51",revision=3286]]

local game_list_buttons = {}
local game_list_scroll_buttons = {}
local game_list_y_start = 0
local game_list_width = 150
local game_list_scroll = 0
local game_sel_buttons = {}
local game_sel_desc = ""
local game_sel_desc_shadow = ""
local game_sel_current = nil

local game_list_all = {}

local update_game_list = nil
local scroll_game_list = nil

local function save_game_list()
	store("/appdata/solitaire_suite/mod_list.pod", game_list_all)
end

local function cull_version(id)
	return split(id, "-")[1]
end

local function find_game_by_id(id)
	id = cull_version(id)
	
	for g in all(game_list_all) do
		if g.id and cull_version(g.id) == id then
			return g
		end
	end
end

local function rmcp(from, to)
	-- makes sure to remove full folder and contents
	-- not sure if this is already done
	rm(to)
	cp(from, to)
end

-- many lines of this function are from system/lib/load.lua
local function attempt_add_game(id)
	local c1 = id:sub(1,1)
	if c1 == "#" then
		id = id:sub(2)
	end
	
	local orig_id = id

	if c1 == "/" then
		id = id:sub(2)
	end
		
	local filename = id
	local true_name = split(id:basename(), ".")[1]
	
	-- download the cart if from the bbs
	if c1 ~= "/" then	
		-- TODO !!!!!!!!!!!! when zep adds "bbs://", use that instead
		local cart_png, err = fetch("https://www.lexaloffle.com/bbs/get_cart.php?cat=8&lid="..id) 
		if err then
			notify(tostr(err))
			return
		end
	
		if (type(cart_png) == "string" and #cart_png > 0) then
			mkdir"/ram/mod_cart/"
			
			filename = "/ram/mod_cart/".. true_name ..".p64.png"
			rm(filename) -- unmount. deleteme -- should be unnecessary
			store(filename, cart_png)
	
		else
			notify"download failed"
			return
		end	
	end	


	local attrib = fstat(filename)
	if (attrib ~= "folder") then
		-- doesn't exist or a file --> try with .p64 extension
		filename = filename..".p64"
		if (fstat(filename) ~= "folder") then
			notify"could not load"
			return
		end
	end
	
	local valid = fetch(filename .. "/pss_mod.pod")
	
	if not valid or not valid.value or valid.value ~= 13579 then
		notify"invalid cart"
		return
	end

	-- TODO only add folder if the game has those things
	-- reverse /card_games/true_name/ to /true_name/card_games/ ?
	--mkdir(suite_save_folder .. "/card_games/" .. true_name)
	--mkdir(suite_save_folder .. "/card_backs/" .. true_name)
	
	rmcp(filename .. "/card_games", suite_save_folder .. "/card_games/" .. true_name)
	rmcp(filename .. "/card_backs", suite_save_folder .. "/card_backs/" .. true_name)
	
	-- remove base cardback
	rm(suite_save_folder .. "/card_backs/" .. true_name .. "/card_backs_main.lua")
	
	
	local md = fetch_metadata(filename)

	-- remove old definition
	del(game_list_all, find_game_by_id(id))

	-- can't do individual games since there are card backs that can be added
	add(game_list_all, {
		id = orig_id, -- id cart is loaded
		name = md.title or true_name, -- name of game?
		author = md.author or "???", -- author(s) of game
		version = md.version or "???",
		notes = md.notes or "",
		from = c1 ~= "/" and "#" .. orig_id or "local file",
		icon = md.icon,
	})
	
	-- clean up bbs cart
	if c1 ~= "/" then
		rm(filename)
	end
	
	save_game_list()
	update_game_list()
	
	notify("'" .. true_name .. "' added successfully")
	return true -- successful
end

local function remove_game(id)
	local c1 = id:sub(1,1)
	if c1 == "#" then
		id = id:sub(2)
	end
	
	local orig_id = id

	if c1 == "/" then
		id = id:sub(2)
	end
		
	local filename = id
	local true_name = split(id:basename(), ".")[1]
		
	rm(suite_save_folder .. "/card_games/" .. true_name)
	rm(suite_save_folder .. "/card_backs/" .. true_name)	
end

local function destroy_button_list(list)
	for b in all(list) do
		b:destroy()
		del(list, b)
		del(suite_window_buttons)
	end
end

function suite_open_mod_manager()
	game_list_all = fetch("/appdata/solitaire_suite/mod_list.pod") or {}
	save_game_list()
	
	suite_window_init("Mod Manager")
	
	game_sel_desc = ""
	game_sel_desc_shadow = ""
	
	destroy_button_list(game_list_buttons)
	destroy_button_list(game_list_scroll_buttons)
	
	game_list_buttons = {}
	game_list_scroll_buttons = {}
	game_sel_buttons = {}
	game_sel_current = nil
	
	add_games_list()

	add_text_field()

	suite_window_footer("Exit Mod Manager")
end


local function game_list_button_draw(b)
	b.t = max(b.t - 0.1)
	local x2, y2 = b.x + b.width-1, b.y + b.height-1
	local yt = b.t > 0 and 1 or 0
	
	rectfill(b.x, y2, x2, y2, 20)
	rectfill(b.x, b.y+yt, x2, y2+yt-1, (b.highlight or b.text == game_sel_current) and 31 or 4)
		
	local xd = b.info and 17 or 0	

	print(b.text, b.x+5+xd, b.y+6+yt, 20)
	print(b.text, b.x+5+xd, b.y+5+yt, 7)
	
	if b.info then
		spr(b.info.icon, b.x+1, b.y+1+yt)
	end
end

local function game_list_button_on_click(b)
	b.t = 1
	local name = print_wrap_prep(b.info.name, 131)
	local author = print_wrap_prep("By:" .. b.info.author, 131)
	local notes = print_wrap_prep(b.info.notes, 131)
	
	local l = "\|c\fw"
	for i = 1,30 do
		l ..= "-\-f"
	end
	l ..= "\fl\|d"

	game_sel_desc = "\f2".. name .. "\fl\n" .. author .. "\n"..l.."\n" .. notes .. "\n" .. l
	if b.info.from == "local file" then
		game_sel_desc ..=  "\n" .. print_cutoff(b.info.from, 131)
	end
	if #b.info.version > 0 then
		game_sel_desc ..=  "\nVersion:" .. print_cutoff(b.info.version, 131)
	end


	
	game_sel_current = b.text
	game_sel_info = b.info
	
	destroy_button_list(game_sel_buttons)
	
	if b.info.from ~= "local file" then
		local _, h = print_size(game_sel_desc)
		local from = b.info.from
		
		local b2 = button_new({
			x = game_list_width + 20,
			y = h + game_list_y_start + 5,
			width = 120, height = 15,
			draw = game_list_button_draw,
			on_click = function(b)
				b.t = 1 
				set_clipboard(from) 
				notify("copied to clipboard: " .. from) 
			end,
			group = 3,
			always_active = true,
			
			text = "\-9\|e".. print_cutoff(from, 105),
			info = {icon = 26},
			t = 0,
		})
		
		suite_window_button_add(b2)
		add(game_sel_buttons, b2)
	end
	
	-- add a shadow layer to the text by extracting the color settings
	local sp = split(game_sel_desc, "\f")
	game_sel_desc_shadow = sp[1]
	for i = 2, #sp do
		local s = sp[i]
		local c1 = sub(s,1,1)
		if c1 == "w" then
			s = "0" .. sub(s, 2)
		else
			s = "w" .. sub(s, 2)
		end
		game_sel_desc_shadow ..= "\f" .. s
	end
	
	

	
	set_suite_window_layout_y(game_list_y_start + 141)
	
	local buttons = suite_window_add_buttons({
			{"Update", function(b)
				if attempt_add_game(game_sel_info.id) then
					local name = game_sel_info.name
					save_game_list()
					update_game_list()
					update_all_assets()
					notify("Successfully updated " .. name)
				end
			end},
			{"Remove", function(b)
				local name = game_sel_info.name
				remove_game(game_sel_info.id)
				
				del(game_list_all, find_game_by_id(game_sel_info.id))
				save_game_list()
				update_game_list()
				
				game_sel_desc = ""
				game_sel_desc_shadow = ""
				game_sel_info = nil
				destroy_button_list(game_sel_buttons)
				
				update_all_assets()
				
				notify("Removed " .. name)
				game_sel_current = nil
			end}
		}, true)
		
	for b in all(buttons) do
		add(game_sel_buttons, b)
	end
end

--local
local scroll_amount = 3
function scroll_game_list(n)
	game_list_scroll = min(max(game_list_scroll\scroll_amount + n), max((#game_list_all - 1)\scroll_amount)) * scroll_amount	
end

-- local
function update_game_list()
	destroy_button_list(game_list_buttons)
	scroll_game_list(0) -- clamp scrolling if an element is removed
	
	quicksort(game_list_all, "name")
	
	local y = game_list_y_start+1
	local h = 19	
	
	if #game_list_all > 0 then
		for i = game_list_scroll + 1, min(game_list_scroll + 6, #game_list_all) do
			local g = game_list_all[i]
			
			local b = button_new({
				x = 10,
				y = y,
				width = game_list_width, height = h,
				draw = game_list_button_draw,
				on_click = game_list_button_on_click,
				group = 3,
				always_active = true,
				
				text = print_cutoff(g.name, game_list_width - 22),
				info = g,
				t = 0,
			})
			
			y += h
			
			suite_window_button_add(b)
			add(game_list_buttons, b)
		end
	end
	
	update_game_list_scroll_buttons(y, h)
end

function update_game_list_scroll_buttons(y, h)
	if #game_list_scroll_buttons == 0 then
		local x = 10
		local y = game_list_y_start + 1 + h * 6

		for b2 in all({
			{"<-", 20, function(b) b.t = 1 scroll_game_list(-1) 	update_game_list() end},
			{"->", 20, function(b) b.t = 1 scroll_game_list(1) update_game_list() end},
			{(game_list_scroll + 1) .. " / " .. #game_list_all, game_list_width - 42},
		}) do
			local b = button_new({
				x = x,
				y = y,
				width = b2[2], height = 18,
				draw = game_list_button_draw,
				on_click = b2[3],
				group = 3,
				always_active = true,
				
				text = b2[1],
				t = 0,
			})
			
			x += b.width+1
		
			suite_window_button_add(b)
			add(game_list_scroll_buttons, b)
		end
		
	else
		local b = game_list_scroll_buttons[3]
		b.text = (game_list_scroll + 1) .. " / " .. #game_list_all
	end
end
	
function add_games_list()
	local y = get_suite_window_layout_y()

	game_list_width = 150
	game_list_y_start = y
	
	update_game_list()
	
	add(suite_window_elements, function()
		
	--	rect(10, 10, 9+game_list_width, 140, 6)
		-- inside
		rectfill(9, 9, 10+game_list_width, 141, 21)
		rect(9, 9, 10+game_list_width, 9, 20)	
	
		-- border
		rect(8, 8, 11+game_list_width, 142, 4)
		rect(7, 7, 12+game_list_width, 143, 4)
		rect(6, 6, 13+game_list_width, 144, 4)
		
		-- outline
		rect(5, 6, 5, 145, 20)
		rect(14+game_list_width, 6, 14+game_list_width, 145, 20)
		rect(6, 5, 13+game_list_width, 5, 20)
		
		-- bottom
		rect(6, 145, 13+game_list_width, 145, 20)
		rect(6, 146, 13+game_list_width, 146, 21)
		
		print(game_sel_desc_shadow, game_list_width + 21, game_list_y_start + 6)
		print(game_sel_desc, game_list_width + 20, game_list_y_start + 5)
	
	end)
	
	y += 140
	set_suite_window_layout_y(y)
end

function add_text_field()

	local y = get_suite_window_layout_y()
	
	local g = create_gui()
	local w, h = 117, 13
	local nav_text = g:attach_text_editor{
		x=10,y=4+y,
		width=w,
		height=h,
		max_lines = 1,	
		key_callback = { 
			enter = function()end,
			tab = function()end
		},
		bgcol = 21,
		fgcol = 6,
	}
			
	add(suite_window_elements, function()	

		rectfill(9, 3+y, 10+w, 3+y, 20)
		rect(9, 2+y, 10+w, 4+y+h, 4)
		rect(8, 1+y, 11+w, 5+y+h, 20)
		rectfill(8, 6+y+h, 11+w, 6+y+h, 21)

		-- due to the text field not being affected by camera()
		local cx, cy = camera()
		g.x, g.y = -cx, -cy
		camera(cx, cy)	

		g:update_all()
		g:draw_all()
		
		if #nav_text.get_text()[1] == 0 then
			print("Input cart ID...", 14, y+7, 4)
		end
	end)

	local b = suite_window_add_buttons({{"Add", function()
			if (attempt_add_game(tostr(nav_text.get_text()[1]))) then
				nav_text.get_text()[1] = ""
				update_all_assets()
			end
		end}}, true)
	
	b[1].base_x -= 131
	b[1].base_y += 1

	set_suite_window_layout_y(y+21)
end

:: suite_scripts/suite_transition.lua
--[[pod_format="raw",created="2024-06-26 16:05:22",modified="2024-07-21 13:23:51",revision=231]]

local suite_transition_t = 0

function suite_transition_draw()
	if game_transition_draw then
		game_transition_draw()

	elseif suite_transition_t > 0 then
		local t = suite_transition_t
		t *= t * (3 - 2 * t)
		t *= t * (3 - 2 * t)
		
		set_draw_target(suite_transition_screen)
		poke(0x550b, 0x00)
		circfill(480/2, 270/2, (1-t) * 300-1, 0)
		poke(0x550b, 0x3f)
		set_draw_target()
	
		spr(suite_transition_screen, 0, 0)
		
	end
end

function suite_transition_update()
	if game_transition_update then
		game_transition_update()
		
	elseif suite_transition_t > 0 then
		suite_transition_t -= 0.012
	end
end

-- applies the default transition BEFORE game_setup()
-- (if a custom one isn't provided)
function suite_transition_prepare_1()
	if not game_transition_init then
		local d = get_display()
		if d then
			suite_transition_screen = get_display():copy()
			suite_transition_t = 0.9
		end
		
		cards_api_coroutine_add(
			function() pause_frames(50) end
		)
		
	end
end

-- applies the custom transition AFTER game_setup()
function suite_transition_prepare_2()
	if game_transition_init then
		game_transition_init()	
		-- ? check if all init, update, and draw are defined.
	end
end


:: suite_scripts/suite_util.lua
--[[pod_format="raw",created="2024-03-29 03:13:35",modified="2024-12-15 00:56:37",revision=12854]]
include"cards_api/cards_base.lua"
include"suite_scripts/suite_buttons.lua"
include"suite_scripts/suite_extra_window.lua"
include"suite_scripts/suite_transition.lua"

suite_save_folder = "/appdata/solitaire_suite"
game_version = "0.2.0"
api_version_expected = 2

mkdir(suite_save_folder)
mkdir(suite_save_folder .. "/card_games")
mkdir(suite_save_folder .. "/card_backs")
mkdir(suite_save_folder .. "/saves")

--[[
probably fine leaving out

cd
ls
]]
-- list of functions that won't be copied over to games
banned_env = split([[
cp
rm
mk_dir
mv
create_process
env
window

store
include
fetch

suite_get_game_name
correct_path
suite_function_wrapper
suite_load_game
suite_card_back_set
get_game_info

suite_clear_copied_env
cap_env
cap_load
cap_include
cap_fetch

game_on_error

]], "\n", false)

copied_env = split([[
game_setup
game_draw
game_update
game_action_resolved
game_on_exit

game_transition_init
game_transition_draw
game_transition_update

game_settings_opened
game_settings_closed

game_count_win
game_win_condition

subgame_on_error

]], "\n", false)

first_load = true

-- gets the games specific name from a given path to it's lua file
function suite_get_game_name(game_path)
	local path = split(game_path:basename(), ".")
	
	assert(path[2] == "lua")
	
	return path[1]
end

-- wraps the draw and update functions with suite specific scripts
local function suite_function_wrapper()
	local old_draw = game_draw
	function game_draw(layer)
		if old_draw then
			old_draw(layer)
		end
		
		suite_window_draw(layer)
		
		if layer == 2 then
			suite_menuitem_draw_pages()
			
		elseif layer == 3 then -- reserved for menus like settings
		
		
		elseif layer == 4 then
			suite_transition_draw()
		end	
	end
	
	local old_update = game_update
	
	function game_update()
		if old_update then
			old_update()
		end
		
		suite_transition_update()
	end
end

-- loads and sets up a game with the given lua file.
function suite_load_game(game_path)
	cards_api_clear()
	suite_clear_copied_env()
	
	cards_api_coroutine_add(function()
	-- example "card_games/solitaire_basic.lua"
	suite_game_name = suite_get_game_name(game_path)
	
	yield()
	local file_n = 1 
	local start = stat(1)
	while true do
		local extra_sprites = fetch(game_path:dirname() .. "/" .. tostr(file_n) .. ".gfx")
		
		if extra_sprites then
			local j = file_n * 256
			for i = 0,#extra_sprites do
				set_spr(j+i, extra_sprites[i].bmp, extra_sprites[i].flags or 0)
			end
			file_n += 1
			
		else
			break
		end
	end
	yield()	

-- attempt at encapsulating the game environment

	if game_path ~= "suite_scripts/main_menu.lua" then
		game_env = cap_env()
		
		game_env.include = cap_include(game_path:dirname(), game_env)
		game_env.fetch = cap_fetch(game_path:dirname())
		
		
		local ok, err1, err2 = cap_load(game_path, game_env)
		if not ok then
			cards_api_display_error(err1, err2)
			game_on_error()
			yield() -- have to yield to prevent freezes
			return
		end
		
		for c in all(copied_env) do
			_ENV[c] = game_env[c]
		end
		subgame_on_error = game_env.game_on_error
		
		suite_transition_prepare_1()
		
		if game_setup then
			game_setup()
		end
		
	else	
		include(game_path)
		
		if not first_load then
			suite_transition_prepare_1()
		end
		
		game_setup()
	end
	
	suite_function_wrapper()
	
	if not first_load then
		suite_transition_prepare_2()
	end
	first_load = false
	end)
end

function suite_exit_game()
	-- for that specific game
	if(game_on_exit) game_on_exit()
	
	-- where to go next
	if cards_game_exiting then
		cards_game_exiting()
	else
		exit()
	end
	
	suite_menuitem_remove_pages()
end

-- grabs the requested save file
-- ensures that the proper folder exists
-- returns nil if save does not exist
function suite_load_save()
	assert(suite_save_folder, "Save location must be specified.")
	
	suite_saveloc = suite_save_folder .. "/saves/"
		.. suite_game_name .. ".pod"
		
	return fetch(suite_saveloc)
end

-- saves a table of data at established location
function suite_store_save(data)
	store(suite_saveloc, data)
end

local card_back_sprites = {}

-- gets the currently selected card back of a given size
-- uses a simple border style
-- ensures that card backs that are already generated will be returned
function suite_card_back(width, height)
	width = width or 45
	height = height or 60
	
	local key = tostr(width) .. "," .. tostr(height)
	
	local cb = card_back_sprites[key]

	if not cb then
		camera()
	
		if card_back_sprite.gen then
			-- initializes card back and adds it to the list
			cb = card_back_sprite.gen(width, height)	
			
		else
			cb = card_gen_back{
				sprite = card_back.sprite, 
				width = width,
				height = height
			}
		end
		
		card_back_sprites[key] = cb
	end
	
	return cb
end

-- sets the default card sprite and prepares the card back cache table
function suite_card_back_set(sprite)
	card_back_sprite = sprite
	for c in all(card_back_sprites) do
		if c.destroy then
			c:destroy()
		end
	end
	card_back_sprites = {}
end

-- loads the game info script/table
function get_game_info(path)
	local new_env = {}
	local ok, err1, err2 = cap_load(path, new_env)
	if not ok then
		return false, err1, err2
	end
	return new_env.game_info
end

-- clears the copied functions from the current ENV to prevent cross contamination
function suite_clear_copied_env()
	for c in all(copied_env) do
		_ENV[c] = nil
	end
end

-- creates a ENV table with all the functions in the current table, except without the banned functions
function cap_env()
	local new_env = {}
	for k,v in pairs(_ENV) do
		if type(v) == "function" then
			new_env[k] = v
		end
	end
	
	for c in all(copied_env) do
		new_env[c] = nil
	end
	for b in all(banned_env) do
		new_env[b] = nil
	end
	
	return new_env
end

-- loads a script with a given environment table and calls it
function cap_load(path, env)
	--local func,err = load(src, "@"..filename, "t", _ENV)
	local func, err = load(fetch(path), "@".. fullpath(path), "t", env)
	if not func then
		return false, "*syntax error", err
	end
	
	local ok, err = pcall(func)
	if not ok then
		return false, "*runtime error", err
	end
	
	return true
end

-- replaces the original include function for the loaded game
-- places the new data into the game ENV instead of the whole suite's
-- also changes the path to be relative to the main game file if /game/ is added to the start of the path
function cap_include(base, new_env)
	return function(filename)
		local filename = fullpath(correct_path(base, filename))
		local src = fetch(filename)
	
		if (type(src) ~= "string") then 
			cards_api_display_error("*could not include "..filename)
			cards_api_on_error()
			return
		end
	
		local pwd0 = pwd()
		
		-- https://www.lua.org/manual/5.4/manual.html#pdf-load
		-- chunk name (for error reporting), mode ("t" for text only -- no binary chunk loading), _ENV upvalue
		-- @ is a special character that tells debugger the string is a filename
		local func,err = load(src, "@"..filename, "t", new_env)
	
		-- syntax error while loading
		if not func then 
			cards_api_display_error("*syntax error", err)
			cards_api_on_error()
			return
		end
		
		local ok, err = pcall(func)
		if not ok then
			cards_api_display_error("*runtime error", err)
			cards_api_on_error()
			return
		end
		
	
		return true -- ok, no error including
	end
end

-- replaces the original fetch function for the loaded game
-- also changes the path to be relative to the main game file if /game/ is added to the start of the path
function cap_fetch(base)
	return function(str)
		return fetch(fullpath(correct_path(base, str)))
	end
end

-- includes the correct path if /game/ is added at the start
function correct_path(base, path)
	local cut = sub(path, 1, 6) == "/game/" and 6 
		or sub(path, 1, 5) == "game/" and 5 
		or 0
		
	if cut ~= 0 then
		path = base .. sub(path, cut)
	end

	return path
end

:: suite_scripts/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTI4IDIwOjA4OjM3Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNSAwMDo1Njo0NyIsc3RvcmVkPSIyMDI0LTAzLTI4IDIwOjA4OjM3Il1d
:: 0_SUITE_READMEFIRST.md
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNi0yOSAyMjoyNjo1NSIsbW9k
aWZpZWQ9IjIwMjQtMDYtMjkgMjI6NDU6NTIiLHJldmlzaW9uPTk4XV0NCg0KSSB3b3VsZCByZWNv
bW1lbmQgdXNpbmcgdGhlIGV4YW1wbGUgcHJvamVjdCBhcyBhIHN0YXJ0IGFuZCBhbnl0aGluZyBp
biBoZXJlIGFzIGEgZ3VpZGUgZm9yIGhlbHBpbmcgeW91IGJ1aWxkIHlvdXIgb3duIHNvbGl0YWly
ZSB2YWlyYW50cy4NCg==
:: changelog.txt
--[[pod_format="raw",created="2024-03-31 21:22:36",modified="2024-07-04 22:14:14",revision=345]]

Picotron Solitaire Suite
By Werxzy
   ______
 /        \
|    /\    |
|   /  \   |
|  /    \  |
| |      | |
|  \_/\_/  |
|    /\    |
|   /__\   |
 \        /
  """"""""

=== version 0.2.0 ===

- Added game, Falling Solitaire
- Added mod manager
- Added settings window and menu bar
- Updated main menu graphics
- Added ENV encapsulation for the solitaire variants
- Added transitions between the game and the main menu
- Changed card back sprites to be generated instead of premade
- Removed game_load() function requirement
- Added 2/4 suit color setting for normal solitaire
- Fixed a bunch of bugs

= api changes =
- Added hand stack
- Added card draw occlusion
- Added a card generation function
- Added hover events for stacks

=== version 0.1.1 ===

- Fixed grammar and wording of some rules text
- Fixed new game in trapdoor solitaire sometimes not dealing the cards
- Fixed double clicking aces in spider solitaire getting stuck
- Fixed huntsman card positioning when shuffling for a new game after emptying the deck
- Fixed buttons being pressable while shuffling or any animations were playing

= api changes = 
- Updated stack dropping to search a slightly wider area for which stack to place the cards on
- Added stack_collecting_anim and stack_shuffle_anim functions to simplify the reset process
- Updated shuffling a bit to better randomize the cards
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAYAAABRmsRnAAAr4UlEQVR4Ae2dL5jquvP-s30q
KpFHVlZWrkQikUciVyKvRF6JPBK5EolEIisrK49EVqz43d8mw-fTWUL_NE1beL_eZ7dMMpmZzEwS
_yZ26y8BAAAAgKgkSAEAAACABxgAAADAAwwAAAAAPMAAAADA05A6ryjp24SNpMrVd2J_h8rDWH6R
f8QzRjwAgB8kSAEAAAAQnzexW39ZaZb0bYaN6JDfH9_M5HfoPIzlF-lHPEPEQ-4rXK4AmEiQAgAA
ACA_qVGjpG8zbqRVPkwcZDd2Hsbyi-yHAfFo6olLFQBbEqQAAAAAiM_b2K2-7s6U9G3cLFa53zri
oNbr4vkx7hnfj3Gd-cB_YvlF-ofNA_Lp_tfV71nRnYdX4dXqPRAJUgAAAADE503s1l9CCCFKNVKp
76Zxs1Tl98dLRzsHjZ2bvZ72eZy0Xx2h8vBDL5Jf5D9sHhDP43j4PcJlk37o_VDwvh-a39RBPoKQ
IAUAAABAfN7Ebv11d2bT_FmscvktPdcf1HpbXOMc2j7tv_pZmb5_S-pOLD9D2_-bh6b6Ta0uc_mT
uUL56Xueub2x4HUfal_h7D45CVIAAAAAxCcNbrFsXjuj1UT8kly_aB1c_7DKX6MuQ8dDdnTnYC7z
oc5zrDrzOtrKQ-VV6Dw_KQlSAAAAAMTnTezWX0IIIUo1UqnvphknokPupu8a59TsD_137vkZug8r
Fg-1-1zqMrYdfm-MldD7IHtjQ-vx3Z-rPnT2uZ2590sgEqQAAAAAiM_b2K2-7s5smriRVLn6Oq5z
jfOg-EzF-tB_556fWH1o239Tq8vU7JSUz4nKPM5b-QP1Ebcb7f503H_s_HV_h8r-zEhec9sAAADA
uLyJ3frr7sym8bNY5f0iqhz1XeM8OMY3tP2h-c49P337sHRcT_t0fTi1usylT6ZCaXnP2Opx-akx
tfh18XD-ru-ATEleY5sAAADAtEhvv0r1rTwtVXm-SHz9gvv1I-nV4H1IctlY5lHp9e3nV62Lbr9j
ya73m6290fu8Zz74fmP3B9_Hrl5P-j4keLkAAACA_LyJ3frr7symcbNU5eobKfKSvgPHOVYeXP1y
-0PnxTfOg-IzlH2_D98_0cU5tbqEyr_vHcovj4_P6-R0_qZ5W-1bHh31TPZ168fmWeL3refMSJ5j
GwAAAMC8eBO79ZcQQohSjVTqu2ncLB3yYSOl_ErHuExUKm7aN8c1D1P3q4vjJjuuH7pPQtkfy87Q
dZlafvg9MrZsuk94fl3tcTuD9cPA_58qtnl3vbcmQjLPsAEAAIB58yZ266_7M5vGzdIhHzZS13hc
0cX-rH4r5reKVBfXPgllfyw7Q9dlavkhSt3_HOdNsm69bTy2-l33GQvXeKcSd_j98f343meRSWZS
BgAAAOCpeBO79ZcQQohSjVTqS3LZPLZQ5d11Q2Ebjyum_J-V702OVBffPgllP7adWHUZOz_6e2No
2TZPXJ_vc-Vvaz80c4s3Vj5s6z70__RJ8iTlAAAAAGbFm9itv_7OlI6WqoEjdY3HFV38r_Z36Lq4
_g1lfyw7Q9dlavkJnSfyQ-aG9hvbX6z8jB1n3-24yrr9D-1OOZLMpCwAAADAU5HefpXqW7Evjesg
vaGxjcfXLvwOWxdfv6Hsx7YTqy5Tyw_-R1zzxO1zeya-vnmzlWMx9fiGgtfRdf_6fEw0X8mTlA0A
AACYFW9it-5CGgAAXpTqWwW2R_jscr1QkD-bfQ0Vx1zj843fVZ5Kv-YkwQ0CAAAAjPkAl_rPF74e
MmTIzy9X6k837-pH9ujPdM-4wu3zfej2FQvb_OaGbR8Ntd_x66p9gAEAAAAQjTexW395rSzVt0IS
AQADQfdMLOg_s73fphpf7LhM8bnKsfpq5PcrwQkHAAAA4vMmdusvIYQQpRqpNJqmeZ3_TW76RVrl
TEbxokL11NWR6jP3urzKPudSh6Gg_vF7zSTHitM3nlj5G2p-ofvDNk8jnecEJx0AAACIT3r7VbGZ
ko3zeQ7pl80wkXK7t-hyu-iAZ94t63qbn2k9XmWfc6lDbD-8vuPyWHlwjSdW-vi7YYq3b35998XX
Tey8JjjxAAAAQHzexG795bWypG8zrR1VufqiuEHYeNb3oOqAfQKfe4XOr69svCc87evi7X1vefoP
HUewe9gx-tj74vH0jdOTBCceAAAAiE96_1Wqb2VYQXplM80d3eLK7fbzLNjWD4Ap9he3TzKft5Vt
-Zn8xzpPU4uH0Pl3lX3z8OQkuFkAAACA_KS3X5VBs6RvM4_d3eLM7fbn7YfJ5Ec3PrR-kofyByL3
sWY8Vn1j9Rc-N1OVx96vbX-Eqn-ffA0dv8kvxTl0vTUkuOEAAACA_KTGF5-my2aeO7zFnT-ep7Nd
z-Gh-Q-lD7wWsfuL2wsl6-ajk3X2hs5vbP9EqHxze337K3afU9yR85-gpgEAAADikxpf_LJ5jp3S
Pqp85vvw1DfVGcyrvlwvVH3H6i9az_1NTY4df6g62doJFd9Q8T4ZCVIAAAAAxCfVzpQDe67yx-Nl
M4xf2lfVN37HPPX1B0AMxu5rbs9X5uec70cn69bb3iuusq8-2-qFkl3rbVofOr6_7xW3F7ouGhLc
OAAAAEB8Uu1M2YT1VOX99EPFQ3Zc49HGSXYN88HyqPFnGgfzxtRnsf3F6ivyz_MZS7bNV2j7PB_2
87aybzyh-IeSZ0aCmw0AAACIT-pjpAzsocrD2imbMPZon1WofQ5k1_RvqP2AcdDVb6z6xu5rUz58
ZR6-q_yan9D_Qtv33a-tfToVue8_Bu7-BDceAAAAEJ83sVt-dUbopS_bfparfNjIQ8VXzbyCVK8f
_wtkf_OZ58PA9Q-NVPc5dH2fDcoX5Se0PLQ-334w3neB-Q_VX195KHheXPNlIMGJBQAAAOLzJnbr
r87Ipulnscot9QzzpaW-sme8B8t4XxXffvDNK9VdV1fqL1P-2NobGtd4wTB98Cz5oP32lfv6n_v_
nc-vsHlIcNIBAACA_KTRPFU99UsU66mh_paNQY-m88d9ZWtv8H1ZxguG7QOa7yvP3b7Jn_v9PXR8
vnKod4Pb75tHRoITDwAAAMTnTezWX52RTeNnqco144EjLnXjnnEfNHGDfv3gmtfQfnztDQ36bRr9
NnfoHqT7lcuvhikfOtn5nTP4dSTBiQcAAADikw5muRrYboniAQCeHLrn_L1nKyMf99dPhAQdDgAA
AMQnDWapbOT3kMeJvCK-JCu-FIdxfaQ4KT6eJ_99s7gpDwCM2W-kV_eP7IzVr33jGyuvfNxVfrb7
zHb-t3fBUbbdP63T2bMkwY0FAAAAxCd9uh1V_bj_S-o2A9lndskf7btCU78UY-ebTk9rJ3Kf2uaH
x2e7r7HP8W3di95nfP_2Ml-vm5eeeU9wgwEAAADxeRO79dfdl71s_lk_5HF3QnG7UgXy2zdfoalU
-vvub_O5L9f6u_bRtL_p1SVUPabab6H6I3Qf_Pbvs53jV7-PaF_03lZ2fT_4HQPJvLsTAAAAmCfp
YJY3jfxWufo_WeZK_qp9Ti4_imtm_ad_iW3Pt46h451rv029D2Z7z0Q6x89yn9E_aN5W5utd80b2
dH40JOhwAAAAID7p4B7KRn0911c5k3V65M-Wru9_2L6mzi1OlUfffYOR6jezfgPzOsfPdp-pZNqn
qzwwCTobAAAAiM_b2K2-OiP85S_bae_gytV3YD_Ul6nnw8RB5cuWjed_Xf3wvrOufyB7vnWl-usb
77P2m2t-hO4D3-6dOn3vvWfpL1MeaJ80r5ODxWPwz0ieszsBAACAafMmduuvuzP0ct-kZl47q3L1
DWRvM7P9mzio-Ay1b1v7ur7T9ZtrXXkfa-U890nxGPVevN9c_yNUH7x6HnGfPe4v6h_d7P3_aOwy
kufuTgAAAGCapPYveq5e9GYeO7vFqeKufO0MHCfl1biP0Pkh-1Opl_V_Xetquz-fOofO37P229h9
MDRzOcevdp-xcZ08VH50fhXJPF5TAAAA4Ll4E7v1190ZerF1lM28dlrl6uu4bhN4nxSHL6HzfjDE
47t-k92x-EzV-6v0mylvoesQOp9zPce4z_6-b-Qe2MrWeTH4UyTzekUBAACA5yA1vuC6l7-K2Qvf
THunFB_PW6sf2L_tX1s7ofJN_6R6g5H680X6be7M9Ry-6n3mK-fNm_W9muBEAQAAAPFJjRr0gtOL
rtXL74_XzbR2TPugfQ2NLi_h7E4tv2Bc0G-IK-Lw8-3SvWeucmAS3FgAAABAfFJrzUp9S0cPVR4m
0rIJa8cUV19-tvumvGrjsPTjG69tPsCwvEq-zY1nOceh78_pnyNtHjTvme59c33vHElw8wEAAADx
SZ1XVOpbRo60yrty2cwz45Q-X-3YeQfzBv2GvAJ9Hfh7Flo2kKAiAAAAQHxS75X00hOWL34wqlz5
bfzWU7x8H6HiMuWrb955vvvmA8wT9BvyCvzvfV9Z9_45visJKgIAAADEJ9XO0EteNvfnq7z70ute
fLIzNWhftI_h0OUllN2p5heMA-oNeQX2deT5DyXz90-TPwkqAgAAAMQn-TFCL3bZPF55m88fvvDa
cVcorh-2lX9TvLEJtW9bP7r8gNcA-Ya8Avt3hOc7lKzzoyFBRQAAAID4pD9GysbNwk0-t3rxveF2
SxQPAPCkVOo_tb2PSR95c3tHSKb3xFfm75LlO5igYgAAAEB80mCWyka9-HmcyCv13Si-UyF2Hrhf
8Fqg34a9X8byW5Icua6zrZdlnm559ZR1dfLsmwSVAwAAAOKTBrdYqm81cOTkZ6ogDwD9Bp6FKn_S
fWhkfn5M5ynQeUvQWQAAAEB80uAWy0Z_q3zYyMnPVEEeAPoNoL8mvi-1rdg4l0mPz_vWW5KgswAA
AID4pD9Gqly97E0-yxu1-qDshYLs9oX2aZp-9TyAOLxKvwHLflDf0lF-6P6i9VO9N0x5uO3DoM-z
rtOz9achQacDAAAA8UkH97Bp5LfK1ddxfUlfZWeuIA8A-QZcca1bLKgvqL-mliedPvX9UPOMBB0O
AAAAxCfVzlS5etGbMJ7ITsnsV1yP6YeG-Lrqv3oenPdJfnDI0G-g6fuL25-Luef3lCnuvvOMBB0J
AAAAxCcdzXPZqO_LV_BZ80D7Ern8VDhs6DeA-mJUke8Hiov8cb983lV2JEHHAAAAAPFJf4z8eNlz
JTfz3intg_9Tq488BIHyxf2C1_g3gP6yuR_Eimfo_0hn-5YXjaxb3zPeBJ0JAAAAxCe11qxy_S2b
ee2Q4g5t79XzAOLWbW79BtBfLpD-oe_pkvbNZNO8TjbZN5CgAwEAAID4pNoZ-uLfxnM13kx7ZxSn
bl-WdpAHELNeM_83gP6aw-51_dDJtvem472aoCMBAACA_CSi-J-X3oUql39TI3ZcyANAXQH6ax7w
904nV_rPVt-7AQYAAABAdFKjRvU-L-3d_bwrl03cHXD-pn14_0EeQMx6zqTfYvsFr9FfQ_9blwed
bFrvSYJOBAAAAOLzJnbrr4cvPof0bCmbsBFXuaP_QJl7lTzQPn3jpzht_8rWj63dofYZ2v-c_y1U
3kLXYep1nQpT6a_h72tuX7dv0uPrTO_k7TuqSF6szQAAAIBJ8CZ26y_fl-umP1Vs99GXZ89DqP2Z
4vD1E6rOY-t-ln7rm7fQdZhLXafC2P0V_94mfyZ5IJIXbTMAAABgVN7Ebv3VGXF9_Ul-KtjGHZpn
zUOofZni8fUz9j7Rb2HzFroOc6vrVBirv0Ln3fSe8fm_siPJi7cZAAAAMArpjxfc9WXn87QuFqb4
xorjVfMAXqvfYvsFr9FfQ9_L-H3TvXeusiMJOg0AAACIz5s4rr8evuhlz5ee1ofCN46xmXsefON3
jdPWz1D7H9v-XPstdN6mbu-Vmfp9pnu3_LirHJgEnQQAAADE500c1193Z-iLXxrmAQAAgDGg90n3
LpnmRyJB5QAAAIApPcCl_iMq9kfzXA8AAAAICX9ndO_Tbh1-t3R2JvMAAwAAAGAw3sRu-SWEEKK0
XFFpxnXrdfoAAADAC5MgBQAAAEB80tuvSn1Lwwo_T_voa9IH4F7-6PpkavOhZN058Z2fK7Svsgnc
V7ldPk1_p2ZnrDyE9jtUP-j6HYkELwAAAAAQnzexW3-dnSl7Wq6QXAAmA51n33PZd73OXtkMu_9D
fn984_h3anbGykMov0P3g63fkc9HgpsJAAAAiE_qneEvOb3wtrjqAxAC6ltd--nO8-GhZH5__Ljt
vO4c2q4LtV5nr2wG7oN8Zn2r4g2dF1MexvI7VD_41n3k85HgxgYAAADi8yZ26y_vlfzlB2AMKkM-
hp6PJevOm27e93ya-Pmu19krG8f65mH6g7NxjOOgiSOUHV2_Q_XLtc6x-A7VD6a_nMj5SHCDAwAA
APF5E7v1V1CLJZIKRqQy9KHvPB8fSubniI8Pdf5MebFdr2PTONrLw-RBqHgOmnhC2dHVr_yZN9v_
ie13qH4w_Z3Y_UhwYwMAAADxeRO79RfSAMCTUHquqzzt8HU6No1nXLmbH1tc4zmoOIayM3ScY_Un
lP1QfTCx85HgxgIAAADikyIFADwRlfqWjuO2dkzrQlM2j_P4EVceNz4wrT4w1X9i5yNBZQEAAID4
vInd_gtpAODJKdW3Gnl92cTZb5U-jnfjGMdB2RvKjo6h7Y-l19W_K67xjHQ_EtxMAAAAQHzexG79
hTQA8KSUmvFq5DjKJo7fQ35-fOPof2g7Ooa2P5ZfV-u2VCoO2-4e_XwkuKEAAACA_KRIAQBPTNVz
fRnILumTvSp3jKNBLYF730z8fCSoKAAAABCfFCkA4AkpmVwZxmOhi8O4LlfrmnHz6Rs-6Nk3qv62
-TWT85GgsgAAAEB8UqQAgCei9ByvDHome7TeFlf9TeNoPw_cV-Kv7N7kgeKxrYOpns9G331N7Hwk
uLEAAACA_KRIAQBgcEr6NsP6qfKB9_EYv208ofJD68ke_a-m3j9sX6Z8z2S-CW4GAAAAID5vYrf_
QhoAeDJKS73Kch3pmeZ1bJph91vliOcRBxaPCdd4hrYfer8TOR8JbioAAAAgPm9it-5CGgB4UkrN
eOVpx3UdX182YfdX5X77erV4fOttimdo_0Pvd_TzkeCGAgAAAOLzJnbrL6QBgCenVN-Kcx0nlJ1Q
IJ5x43mW-UY_HwluJgAAACA_KVIAwAtQRV6ns1NObF_Ip188z7bfyOcjwc0EAAAAxOdN7NZfSAMA
AAAQlwQpAAAAAPAAAwAAAHiAAQAAAIAHGAAAAMADDAAAAAA8wAAAAAAeYAAAAAA8JvVdePr1rxBC
iKz4iyyOQFv-_s7-6u8-Qe2irs9Z1xslcjwK1TBmt5flt-lFkXXG3ws57sulPt8dD2WX7Azlx7Qf
7t-kTxfntW6-879-vz9vIsHJAAAAAOLzJnbrL5_F5_VWCCHEe1kgiyNwqervH8vzPqhd1PU56ypK
_jZI8hhUufqGNbu7rr7Leq1b5HgEFkUm67A4ea1PkEIAAAAgPilSAEJQnhbf3_vxOIr-xXr9-a1W
VzmwO8vv-jBOQrYbFccSzfG-VDlrnMZOz9iAyo5pna1eKH3d-gLxXsj_OtUneQ6KrDN-rdvuOWHz
tF7HpVbniNkjO7Yy98-HTfOmdX3tE5nab6vywuXQJLgRAAAAgPikwS3uzvK7PyC7IdhuVF6Xkwqr
PC2_v9fjcRLx3OJYqTyN3X-kn74TrWP8xmkez1e5nz3bdaTH4_DrXe266g91Dur2O4xFkXW_NE5f
4lSfOjLpc94L1bcFmzDIF6HeAwaPy3VftutcaWmfGjk0CV44AAAAID5pcIv7A7I6RD53y0mEU54W
39-r8Yja9DkXE6nnLbxM1vUj__xl50-7uyNv26tjgzX3x6v8vh4ft4XWkR2dXz4eOo6BuNZtR14U
mRBCiPdC9t2lPnf0aJ6vIy6iq8-t6sYJ8vuDQrMBNk7xmvya9qObz5T9VsVpkkOR4GYEAAAA4pMO
7uF6QJZ9WGwmFU55WshyHo924a-X399qdR01jh9sVV53y7AJ2p3ld2-odz4fOg5PPrLPoHb_tL-l
djNZr23bsw-Kxm28yu30bNHZ4_NjXxtFJs9H3XavYSVfhOpTxWq9kuN1d9xkz3X8VJ8ezuvWk0y8
F_y8FIaEsHm_z5s-0bXbMj9c-hHPX7k-VxK8dAAAAEB80mieTrX8rgr53Z3Vdym-i438Xg-PIfP9
8f2TPrFVMulPjOvx_HB_sV5-f6vVlVYMEgfZzx_Ho2eo-JLd21fVf6-6gUPjE6337CmbQA2XPx7n
fnT6UznHdSvPa5F9X0eXWvWpYrVedcZJvy-kT2dPN8-li3gcF9nR7Zd4L9i5U9fyzQ-Liy6eviQ4
qQAAAEB80mieVkVX3i278vXwXDLfH9--diO-e7WOvnzdyJSnxcP5xXr9-a1WV5ymR-Wn_v7QO0_y
7kR2XT2cbxenu_PbVvbDPpP9o9P70-7uyB-Z58N5sntLq7LP15n8cDs-qHK3RLnqD8S1buW5LLK7
MtfjXITqR7q21rL_l7o7ztdzf6Zx13mTX9O__Pypvt_PJkzxupLgpgQAAADik0bztNjI71Z9d8v7
eqdafldFGHl37vpzlUPHQ-D97w_TbJDr8fhwvlpdcYoeQXXW1ZfGdedhZPbZoiNv2269s_vq4fqP
7NNqnux8ZG7xmex7Uzaahs_78yRPjPdC9tNFyPvsWrf3r_Wim3CuR_td7RqfA_XXFJftfFarOFV8
JLdK5vB5k6zLT18S3JAAAABAfNLoHveHrrxbduVVEVbm9l3l0PFwyB-3O3EW67X6dXVaV54WctXx
2LFTrdzszI7t5n7-vxjZdSWEEKJdnAa1b0ubsb47NdLOstQ0sJwXVT7Nc1lkchtHmd-VWubjVHfz
TXrXun1ohyC9izh3rzdl-1J3x-vGb4qLz7dF9-7k8o_6G-RN60ORvPRtAAAAAIxEalJYVJkQQohr
2XZksXT0tN3I7-7Q-e6UoVMtv6tCjZ_78wu1-qrWzV3m__P7t0RXH5Jd19tSra5O_uVpIf0cj51x
kkux9rIbHKoL9aeuf-k41VFrV83z9YHr07cfhmafyT6IZX-bGvrp1HT78aJ_mO63srvu-w5GPup5
vdbd8dPxJNcV6t7W6JnmdeMXoc6LYrVeyfFajpM_2SdZN67dt0YvU37awvVBur-eVe57XpNJnEoA
AADgxUhNCvSSu77sP9gtu1-Oqrivfwvk8Fwy3x-fvyW_9eH6JAtNeXwpTwvp53h8vA81X4r1dzzV
6jrOidizOtmO6-raE119TPUNdl4Z21bWY5-Jen5kn3f1-rS-R73QfsbVjYf2QWTLUgghRLs4fWv-
Wq56NnwT97xqwl0Ual7xXsj_vNTnu3rX_nEc3N5tP2zdRXTtr9YyQO43FK3aFydT-qrsr9r-pjNO
6-h6V7nveU3Gff8BAACA1yQ1KehedrG09LDYIMsDoqsPyTp_1HMgrsejn-7KtsFeq75D9YMtH9mn
1Xx2XSl5Xvlu818y-uavlR5h0o91XheFsld37Z3qkzxWa1mXizjf1eN2bv41ej-iVHq0-lJLP8TN
vxrndvl6nd9MrW8LeU9wucpkPYr8d2fdbdzRHpcJvj-X85bgigMAAADik5oU6CWnl93IdiO-_wOy
GwLKpwGqD9XLVd_6vq_Sb9v_tayPL7w_pvqGrue2vXbk7PzRkdvln0mVL7uugthp81-f9i5KXjZ-
O_M3f2r8rMZJT1S5-JZN1PN6rbv2FkVX73Q83R3nMrfzIx6mb4qDuIhzR16tZb0utRzXraNx8nsV
y269iq5ctrIeVfMpB1QZaJx74etNMvFO442K3-G8JrhxAQAAgPikJgX_kpOsZbfsfkEUeH1IttUf
isV6Lf0dj07jQlzHSSTv2-3hvt52E6XPbevpfV4NtItTd6DndretrOuHZVikf6PKH8azzxbd9Zeu
fKNsnOI_5786ctb87YbBZJP9UOf1Up-v90Gh7Nb37b4XMnEXIdfr9Li9WzwGfdt15J9YrVcP98XJ
lF6r9nNrk4zVg40XmvWuMo-T9bwmeLoAAACA_KQmBXrJ6WUH04TqQ-Vy1R_qvtXqKn_slt-_ytNC
_j0epd-1uqsn6DsyOxnvjf1Bfreb_-MDwetjqu-Uz2u7OPXTV2nPriu-AMrm4XTW-O3I5-zXw3l9
4_cP-YU6r__FTMiplnlaFEqv7tqlceJ0lPqrtcwjrdfpc3vGeDVx-OhXNn8R545M8V1qOU76N-vU
EIwi--3fIRWibj675W9lPclrq-J36zdHue95TfB0AQAAAPFJTQr8JSdZy_4sv-vD-fntRukt-SJe
qPWudnzXzQReH5Jt9YemPC2k3_OxG4eSS7H_jqdaXaeVWOqTkfrFtp7e51Xxp-0thBDiI-vsFS-Z
2Wey3ia7XN8WV31RNl77WTZ-3RZU_ajn9Vp37SwKZZ_NE6fjqaOns_N8H6n1Jv8mvxeh3hPFar2S
43V3XEeRy-4idLvKlL22kOfcVhaFjMf3vCZP9QoBAAAAMyE1KdBLTi_7kf2BGWByKMjPbhln3cSh
_lC9XPWt6_tJtbrKHytd3tU8eHj_TPX1ree2lfnftqtB9mFr19W-Ub_M1FdVPsp5vdTn_-qF0q-v
26f5H-2j0be1q7PH19na4fMX0d3vai3rT3mwjYvTFt17yVbmWXQ9rwmuOAAAACA_qUmBv_QkB2N3
lt-94f78dqP0loZAlR5xVfb4ONcnPZM9HofOn24-un0E2j_vD8m2_mCa2Naz73ndZwshhBAf2Wdn
PLuurNa3i1NHn8uhoXi37dVqvO_8aZ0oG6f4Q53X90LeC6da5ntRKHt11x6N3_yxea6nm6dxbs_4
X2bP1Q7pczt836Z9ZrW8b1uVt74y5V80ctz1vCa44gAAAID4pCYFesnpZTey3cjv-iC-CyXz_d2y
q8fnCZonfW2gzI4uHp0fQhcvj0Pnj-shPW5Xt3-S352d9k-1oXqZ4PrW9QVR4fUx1de3nh-Z539N
JsSf9rds_-babetsYaVHZNdVr32TP7JPsk7Pdlxn-3bcLf3p9m3LUOf1WnftLQq1jo1r_yew3tTs
tEX3Hu0r9z2vCa44AAAAID6pSYG-5CRr2S2735uhjfzuD-fn_XqC9I2BKvtb9eVxcDu6_Ahuh6-X
_dNxVetpnU6fx2EJrw-JtvqulKfF9-pqdY3asOTXm93Zrl6hIb_O2NbT_7wqsutKtnkm89suTp3x
j_yzI9P8tpUyh683QX5tx4NR5d9xXha1OhhS3pbNw3h4XNvW7RwMfV4XhbJbd_1m9eM_bAt5Lmz1
fvSRYd1c-ZG_Lg7f85qM_-4DAAAAr0lqUqCXnF72wdmd_63fH5SdZZx4Xf1dlb7vvAaqD9XLVd_1
vtfj8f-vWuTyMx_oXvSdOLw_pvr61rNdnDryn-b3XZn0dPMm_9l19VBv215lebJFnHZ4l-6Wl31H
FuKx-75xhjqvl7p7Xy4KpVd37WZMry9kry3i3LNj_7P163pek5ldnwAAAMBTkJoU_EtOspbdWX73
h-vz2819mfT5Oq7vO267jseh20ffOHR_F5r87JYPzfD6kGyrD6aJbT29z6siu64et2l7Vd-7ejSv
s2drXze_zxaD5nn-ft_-8fhq4jYx1Hm91l07Wa3uY0ZbPL5PdPrcHsk0z_1yfVu-tv767svVn8m-
63lNcMUBAAAA8UlNCvSS08tuZLfsfkPrXw9u47bzseLo61cD1Yfq5aqvq_9ivZZ6x_OkG5niFOIq
P9uN-O4d6xEbitPy-Jnq63xep5qWVtXRUm_fLYLomdbZxhXrvL4X8t441ScrO63S94XWZ-U5Sh9M
zZ8pf67nNZn1KQUAAABmSmpS4C85yWBa8PqQbKuvo1pd5Y-VcuoZ6Io7FS99Z4ptPZ-2vFb59362
ZfNQbduy_vfUC7Uu9nkF8zqvCVIGAAAAxCc1KdBLTi_7kd1ZfvcHZDcE243K6-KhGtWH6mWC61vX
F0SF18dU38nXs8rlt2z89FzHff3r9Pv6x3nFef0fEqQMAAAAiE9qUuAvOcla9gdkNSSUz93yoRqv
D8m2_ib_tL_-120vi854u-xjtT47f3T0uazTs8V3nS3Xf37JfP37N2r5bevpfV6Hosrlt2y6sq2_
bt6kz-V0-nXxmfRt4zX100DnNavP8hwU9__Luvl8uL7I5TmvMtbnbF0p5Hkw2ufhsvm_-kzrbutb
uZ7y4uvPlF-X85rghQMAAADik5oU6CWnl92Z6wFZ9mGxcVNX9aF6ueqb6ru9LL719u9XIYQQH9ln
Z-5P_9tKj2iXfzpydv64K5v0aN6kp4tH5_fWvv-8uisv-v0rB45Svl5UXt_V4tpy3vH8merb_7wO
TdnIb5Xfn9eN69ab9Gle51cnm_KkeZ080nlti_VduW7un0Nfqkz2b9l2zwfJNK8to9Kz273en2u8
RU9-PL99z2uClw4AAACIT2pS4C85yc7szvK7PzzWu6p50t8tVSCb7vzUZV38OrZqnvQd4fUh2Vbf
RLv8819wQvxpfwshhMjOH53x7WXRkWn_Q7Mdvp6vI1mnT7JunsfN4yF5-359uH7x71_Zr39_deRb
Hi8avbXdvOv5i3ZedVS5-JbNY5nr69Cts13vai-UPnsy9Hkl6ubzfppa2Yc-zrkurUq-yrr9T3JB
6wt5wEjm-otc3h_mbrb1Z7uvUPvjXGp1z3ue12Tc9x8AAAB4TVKTAr3k9LJ7sz-cH99u5He37I5z
_crWT13Wxb87388HyXydJVQfqpervqm_2fmDVspw36-d8JVMeny_L9y_K_3yz-32u8j96OaNeXxX
5f3nV0e2nXc9f6b6BjuvVS6-ZdOVTfqEbp3JTqj1rvGZ9knzuvxM7Lxq09rKPmwLec9ktbqPTOdH
6ZdKv8r_Dvow_fqjdbH89T2vybjvPwAAAPCapCYF-pKTHIz9QX53S-k91fK7KtT4uTvP5cVGfq-K
TmzZFB-fD_03MLw_JNvqm2iXfx7Of2Sf8qu2bVqvs6cbD2Xfdv7HOfj37-2JtRxfrDULTfOO5y-a
eS0b_a3y_-O6cdt5k57teh5nX79kz9bvxM5rVsv7py00B4XpuXKz28jzaLTLwuXzujh94zOtM_XF
dn86O67nNRn3-QcAAABek9SkQC85vey92W7kd3-oju-O6rtk4wb5yuzElk3xrYru-mzz4QjVh_rl
qh_sviAovD6m_vauZ5XLb9l0vzQ_NVzj4vshOTJDnde2YPePJb7rno2sVve05vjwPL2T3Mh1ruc1
QcoBAACA_KQmBf6Sk_zNbsm_Z-ndH7rjp1p_V4WdTHa43aFk1-hof9tN1w5B857w_pBsq6-l_Evq
X6bdyIt39WP997-kCvGn-S3TfVlMOu79_1UIIcRH9ml1-oKd1yqX37Lxm58LFD-th4_PxGDn1UCV
yfNRtvJctwW7hwxktboHNWH8sNd0_9rWn8mO9TrHfVF_bLlQPjzPazLv0wUAAADMk9SkQC85veze
XA9d_VTL727Z-RKrwk3m64eWXePT7Z-0_LwjVB_ql6u_rr7XyzwameJcrOV3e1nMIm6K84O1l_78
meprfV7Lxi7AKn_Om852v5EIdV4v9fnxtttfsozZ325ZSW4_O3ptcb8Ra6Unej4DQ3OLU0OR-77f
5iw-Jn3infLVyDq4ntfkOU4XAAAAMC9SkwJ-yUl2ZndW36X8roru-Km_P_7rZ3_4P7-dyO-7L-m9
-LXTp7h94fvj__T5cYTXh2RbfTBNbOvpfV6rXH7L5rkTObF9hjqv74W8L0716ftayWp5j7RqnL6l
Gq8ydd-x9Khx19u3bOU9ated7tB_RM9ryjdOnk8u9z2vCa44AAAAID6pSYFecnrZvdktmXzujq_K
__tOdXeey1xvf_iObzfdcfrycZP__6-Hfk3xcZnvn_fHEaoP1ctV37W_i3f1Y-03bsceZR2uF7-l
_-erEEKIj_wzath-2t_yvS4Lp3W8Pqb6ep-XKp-3TVY23X2QPFGGOq9tcf8eoXG6hbJa3j9VZnd_
i1z27w_7A_XHNb5bG7TyfuB5MMVJ67g-kilvuvz6ntdk3qcOAAAAmCepSYG-5CQ7s9jI7-Ugv7tl
d-5Uy__q6I5f-t6XTXqf-9zX2yv-9CW2Kj6K6-2X-P7_182vTo-vj__f58cRXh_SbfWdWbN9x4L8
XlR9HPnIPkcJm-xuxYfbsbGsZ7DzWjbyW_XzuslM8dK_XO25rot8Xi-1_eG6utH0u_exvy1Xftui
e4-ReJXdvx8onrKV55evv6Vfs-62Tlc2Wsf2bfJH46Uh-tDnNZnXKQMAAACeg9SkQC85vezeXA9d
ebHpjq_K__vef8nv5W9XNkH6ZHe37M7vld_tioPP03oTtvHx-fH98-w4QvWhernq964vGAReH1N9
X62e58VWHrtSc3-Qca7q7x-LXOobKZv741X_eH6m57Vs5b3Fo9GNtwW7Lyk9md29SXqPq3YnDo3f
UP5u9pvPKOc1wRUHAAAAxCc1KfCXnGRnFhv5vR66X2J3Vt9ld3xVPJaJ919dec-tK7vc-g9ZxcHX
c-uu8fH98f3z-DjC60OyrT6YJrb1DHZeq3zS_TgvtvI4lppzpoH0W3H6PqaXqv6eWObS3o-9l82g
eRnqvGa1vGfaQt4zRf7bKh7undbxcW7f1x-HtE6XnaH86eb5fvue1wRXHAAAABCf1KRALzm97N5c
D115semO75aP168Ku-mtsrtXdulLkB-ub3e_r0-2bP3r4P74-nl_HKH6UL1c9XvX15bjL_n3ouJ4
V_Prv5M8IH-a33fHP7LPKP55fUz1ta5nlc-qojovtv-9F_K9NJwzS8jOudp-f5dX_Y2Vn1Dn9b2Q
98qpPn1-WyV7x1V07RKn4337XF6tVx19Luv0bPFdZ9rvtbargym-ruf1-wF5UWGo5gyOgAAAABB0
RVh0TG9kZVBORwAyMDExMDIyMeNZtsEAAAAASUVORK5CYII=
:: LICENSE.txt
b64$QXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbC1TaGFyZUFsaWtlIDQuMCBJbnRlcm5hdGlvbmFs
DQoNCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09DQoNCkNyZWF0aXZlIENvbW1vbnMgQ29ycG9yYXRpb24gKCJDcmVh
dGl2ZSBDb21tb25zIikgaXMgbm90IGEgbGF3IGZpcm0gYW5kDQpkb2VzIG5vdCBwcm92aWRlIGxl
Z2FsIHNlcnZpY2VzIG9yIGxlZ2FsIGFkdmljZS4gRGlzdHJpYnV0aW9uIG9mDQpDcmVhdGl2ZSBD
b21tb25zIHB1YmxpYyBsaWNlbnNlcyBkb2VzIG5vdCBjcmVhdGUgYSBsYXd5ZXItY2xpZW50IG9y
DQpvdGhlciByZWxhdGlvbnNoaXAuIENyZWF0aXZlIENvbW1vbnMgbWFrZXMgaXRzIGxpY2Vuc2Vz
IGFuZCByZWxhdGVkDQppbmZvcm1hdGlvbiBhdmFpbGFibGUgb24gYW4gImFzLWlzIiBiYXNpcy4g
Q3JlYXRpdmUgQ29tbW9ucyBnaXZlcyBubw0Kd2FycmFudGllcyByZWdhcmRpbmcgaXRzIGxpY2Vu
c2VzLCBhbnkgbWF0ZXJpYWwgbGljZW5zZWQgdW5kZXIgdGhlaXINCnRlcm1zIGFuZCBjb25kaXRp
b25zLCBvciBhbnkgcmVsYXRlZCBpbmZvcm1hdGlvbi4gQ3JlYXRpdmUgQ29tbW9ucw0KZGlzY2xh
aW1zIGFsbCBsaWFiaWxpdHkgZm9yIGRhbWFnZXMgcmVzdWx0aW5nIGZyb20gdGhlaXIgdXNlIHRv
IHRoZQ0KZnVsbGVzdCBleHRlbnQgcG9zc2libGUuDQoNClVzaW5nIENyZWF0aXZlIENvbW1vbnMg
UHVibGljIExpY2Vuc2VzDQoNCkNyZWF0aXZlIENvbW1vbnMgcHVibGljIGxpY2Vuc2VzIHByb3Zp
ZGUgYSBzdGFuZGFyZCBzZXQgb2YgdGVybXMgYW5kDQpjb25kaXRpb25zIHRoYXQgY3JlYXRvcnMg
YW5kIG90aGVyIHJpZ2h0cyBob2xkZXJzIG1heSB1c2UgdG8gc2hhcmUNCm9yaWdpbmFsIHdvcmtz
IG9mIGF1dGhvcnNoaXAgYW5kIG90aGVyIG1hdGVyaWFsIHN1YmplY3QgdG8gY29weXJpZ2h0DQph
bmQgY2VydGFpbiBvdGhlciByaWdodHMgc3BlY2lmaWVkIGluIHRoZSBwdWJsaWMgbGljZW5zZSBi
ZWxvdy4gVGhlDQpmb2xsb3dpbmcgY29uc2lkZXJhdGlvbnMgYXJlIGZvciBpbmZvcm1hdGlvbmFs
IHB1cnBvc2VzIG9ubHksIGFyZSBub3QNCmV4aGF1c3RpdmUsIGFuZCBkbyBub3QgZm9ybSBwYXJ0
IG9mIG91ciBsaWNlbnNlcy4NCg0KICAgICBDb25zaWRlcmF0aW9ucyBmb3IgbGljZW5zb3JzOiBP
dXIgcHVibGljIGxpY2Vuc2VzIGFyZQ0KICAgICBpbnRlbmRlZCBmb3IgdXNlIGJ5IHRob3NlIGF1
dGhvcml6ZWQgdG8gZ2l2ZSB0aGUgcHVibGljDQogICAgIHBlcm1pc3Npb24gdG8gdXNlIG1hdGVy
aWFsIGluIHdheXMgb3RoZXJ3aXNlIHJlc3RyaWN0ZWQgYnkNCiAgICAgY29weXJpZ2h0IGFuZCBj
ZXJ0YWluIG90aGVyIHJpZ2h0cy4gT3VyIGxpY2Vuc2VzIGFyZQ0KICAgICBpcnJldm9jYWJsZS4g
TGljZW5zb3JzIHNob3VsZCByZWFkIGFuZCB1bmRlcnN0YW5kIHRoZSB0ZXJtcw0KICAgICBhbmQg
Y29uZGl0aW9ucyBvZiB0aGUgbGljZW5zZSB0aGV5IGNob29zZSBiZWZvcmUgYXBwbHlpbmcgaXQu
DQogICAgIExpY2Vuc29ycyBzaG91bGQgYWxzbyBzZWN1cmUgYWxsIHJpZ2h0cyBuZWNlc3Nhcnkg
YmVmb3JlDQogICAgIGFwcGx5aW5nIG91ciBsaWNlbnNlcyBzbyB0aGF0IHRoZSBwdWJsaWMgY2Fu
IHJldXNlIHRoZQ0KICAgICBtYXRlcmlhbCBhcyBleHBlY3RlZC4gTGljZW5zb3JzIHNob3VsZCBj
bGVhcmx5IG1hcmsgYW55DQogICAgIG1hdGVyaWFsIG5vdCBzdWJqZWN0IHRvIHRoZSBsaWNlbnNl
LiBUaGlzIGluY2x1ZGVzIG90aGVyIENDLQ0KICAgICBsaWNlbnNlZCBtYXRlcmlhbCwgb3IgbWF0
ZXJpYWwgdXNlZCB1bmRlciBhbiBleGNlcHRpb24gb3INCiAgICAgbGltaXRhdGlvbiB0byBjb3B5
cmlnaHQuIE1vcmUgY29uc2lkZXJhdGlvbnMgZm9yIGxpY2Vuc29yczoNCiAgICB3aWtpLmNyZWF0
aXZlY29tbW9ucy5vcmcvQ29uc2lkZXJhdGlvbnNfZm9yX2xpY2Vuc29ycw0KDQogICAgIENvbnNp
ZGVyYXRpb25zIGZvciB0aGUgcHVibGljOiBCeSB1c2luZyBvbmUgb2Ygb3VyIHB1YmxpYw0KICAg
ICBsaWNlbnNlcywgYSBsaWNlbnNvciBncmFudHMgdGhlIHB1YmxpYyBwZXJtaXNzaW9uIHRvIHVz
ZSB0aGUNCiAgICAgbGljZW5zZWQgbWF0ZXJpYWwgdW5kZXIgc3BlY2lmaWVkIHRlcm1zIGFuZCBj
b25kaXRpb25zLiBJZg0KICAgICB0aGUgbGljZW5zb3IncyBwZXJtaXNzaW9uIGlzIG5vdCBuZWNl
c3NhcnkgZm9yIGFueSByZWFzb24tLWZvcg0KICAgICBleGFtcGxlLCBiZWNhdXNlIG9mIGFueSBh
cHBsaWNhYmxlIGV4Y2VwdGlvbiBvciBsaW1pdGF0aW9uIHRvDQogICAgIGNvcHlyaWdodC0tdGhl
biB0aGF0IHVzZSBpcyBub3QgcmVndWxhdGVkIGJ5IHRoZSBsaWNlbnNlLiBPdXINCiAgICAgbGlj
ZW5zZXMgZ3JhbnQgb25seSBwZXJtaXNzaW9ucyB1bmRlciBjb3B5cmlnaHQgYW5kIGNlcnRhaW4N
CiAgICAgb3RoZXIgcmlnaHRzIHRoYXQgYSBsaWNlbnNvciBoYXMgYXV0aG9yaXR5IHRvIGdyYW50
LiBVc2Ugb2YNCiAgICAgdGhlIGxpY2Vuc2VkIG1hdGVyaWFsIG1heSBzdGlsbCBiZSByZXN0cmlj
dGVkIGZvciBvdGhlcg0KICAgICByZWFzb25zLCBpbmNsdWRpbmcgYmVjYXVzZSBvdGhlcnMgaGF2
ZSBjb3B5cmlnaHQgb3Igb3RoZXINCiAgICAgcmlnaHRzIGluIHRoZSBtYXRlcmlhbC4gQSBsaWNl
bnNvciBtYXkgbWFrZSBzcGVjaWFsIHJlcXVlc3RzLA0KICAgICBzdWNoIGFzIGFza2luZyB0aGF0
IGFsbCBjaGFuZ2VzIGJlIG1hcmtlZCBvciBkZXNjcmliZWQuDQogICAgIEFsdGhvdWdoIG5vdCBy
ZXF1aXJlZCBieSBvdXIgbGljZW5zZXMsIHlvdSBhcmUgZW5jb3VyYWdlZCB0bw0KICAgICByZXNw
ZWN0IHRob3NlIHJlcXVlc3RzIHdoZXJlIHJlYXNvbmFibGUuIE1vcmUgY29uc2lkZXJhdGlvbnMN
CiAgICAgZm9yIHRoZSBwdWJsaWM6DQogICAgd2lraS5jcmVhdGl2ZWNvbW1vbnMub3JnL0NvbnNp
ZGVyYXRpb25zX2Zvcl9saWNlbnNlZXMNCg0KPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0NCg0KQ3JlYXRpdmUgQ29t
bW9ucyBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsLVNoYXJlQWxpa2UgNC4wIEludGVybmF0aW9u
YWwNClB1YmxpYyBMaWNlbnNlDQoNCkJ5IGV4ZXJjaXNpbmcgdGhlIExpY2Vuc2VkIFJpZ2h0cyAo
ZGVmaW5lZCBiZWxvdyksIFlvdSBhY2NlcHQgYW5kIGFncmVlDQp0byBiZSBib3VuZCBieSB0aGUg
dGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhpcyBDcmVhdGl2ZSBDb21tb25zDQpBdHRyaWJ1dGlv
bi1Ob25Db21tZXJjaWFsLVNoYXJlQWxpa2UgNC4wIEludGVybmF0aW9uYWwgUHVibGljIExpY2Vu
c2UNCigiUHVibGljIExpY2Vuc2UiKS4gVG8gdGhlIGV4dGVudCB0aGlzIFB1YmxpYyBMaWNlbnNl
IG1heSBiZQ0KaW50ZXJwcmV0ZWQgYXMgYSBjb250cmFjdCwgWW91IGFyZSBncmFudGVkIHRoZSBM
aWNlbnNlZCBSaWdodHMgaW4NCmNvbnNpZGVyYXRpb24gb2YgWW91ciBhY2NlcHRhbmNlIG9mIHRo
ZXNlIHRlcm1zIGFuZCBjb25kaXRpb25zLCBhbmQgdGhlDQpMaWNlbnNvciBncmFudHMgWW91IHN1
Y2ggcmlnaHRzIGluIGNvbnNpZGVyYXRpb24gb2YgYmVuZWZpdHMgdGhlDQpMaWNlbnNvciByZWNl
aXZlcyBmcm9tIG1ha2luZyB0aGUgTGljZW5zZWQgTWF0ZXJpYWwgYXZhaWxhYmxlIHVuZGVyDQp0
aGVzZSB0ZXJtcyBhbmQgY29uZGl0aW9ucy4NCg0KDQpTZWN0aW9uIDEgLS0gRGVmaW5pdGlvbnMu
DQoNCiAgYS4gQWRhcHRlZCBNYXRlcmlhbCBtZWFucyBtYXRlcmlhbCBzdWJqZWN0IHRvIENvcHly
aWdodCBhbmQgU2ltaWxhcg0KICAgICBSaWdodHMgdGhhdCBpcyBkZXJpdmVkIGZyb20gb3IgYmFz
ZWQgdXBvbiB0aGUgTGljZW5zZWQgTWF0ZXJpYWwNCiAgICAgYW5kIGluIHdoaWNoIHRoZSBMaWNl
bnNlZCBNYXRlcmlhbCBpcyB0cmFuc2xhdGVkLCBhbHRlcmVkLA0KICAgICBhcnJhbmdlZCwgdHJh
bnNmb3JtZWQsIG9yIG90aGVyd2lzZSBtb2RpZmllZCBpbiBhIG1hbm5lciByZXF1aXJpbmcNCiAg
ICAgcGVybWlzc2lvbiB1bmRlciB0aGUgQ29weXJpZ2h0IGFuZCBTaW1pbGFyIFJpZ2h0cyBoZWxk
IGJ5IHRoZQ0KICAgICBMaWNlbnNvci4gRm9yIHB1cnBvc2VzIG9mIHRoaXMgUHVibGljIExpY2Vu
c2UsIHdoZXJlIHRoZSBMaWNlbnNlZA0KICAgICBNYXRlcmlhbCBpcyBhIG11c2ljYWwgd29yaywg
cGVyZm9ybWFuY2UsIG9yIHNvdW5kIHJlY29yZGluZywNCiAgICAgQWRhcHRlZCBNYXRlcmlhbCBp
cyBhbHdheXMgcHJvZHVjZWQgd2hlcmUgdGhlIExpY2Vuc2VkIE1hdGVyaWFsIGlzDQogICAgIHN5
bmNoZWQgaW4gdGltZWQgcmVsYXRpb24gd2l0aCBhIG1vdmluZyBpbWFnZS4NCg0KICBiLiBBZGFw
dGVyJ3MgTGljZW5zZSBtZWFucyB0aGUgbGljZW5zZSBZb3UgYXBwbHkgdG8gWW91ciBDb3B5cmln
aHQNCiAgICAgYW5kIFNpbWlsYXIgUmlnaHRzIGluIFlvdXIgY29udHJpYnV0aW9ucyB0byBBZGFw
dGVkIE1hdGVyaWFsIGluDQogICAgIGFjY29yZGFuY2Ugd2l0aCB0aGUgdGVybXMgYW5kIGNvbmRp
dGlvbnMgb2YgdGhpcyBQdWJsaWMgTGljZW5zZS4NCg0KICBjLiBCWS1OQy1TQSBDb21wYXRpYmxl
IExpY2Vuc2UgbWVhbnMgYSBsaWNlbnNlIGxpc3RlZCBhdA0KICAgICBjcmVhdGl2ZWNvbW1vbnMu
b3JnL2NvbXBhdGlibGVsaWNlbnNlcywgYXBwcm92ZWQgYnkgQ3JlYXRpdmUNCiAgICAgQ29tbW9u
cyBhcyBlc3NlbnRpYWxseSB0aGUgZXF1aXZhbGVudCBvZiB0aGlzIFB1YmxpYyBMaWNlbnNlLg0K
DQogIGQuIENvcHlyaWdodCBhbmQgU2ltaWxhciBSaWdodHMgbWVhbnMgY29weXJpZ2h0IGFuZC9v
ciBzaW1pbGFyIHJpZ2h0cw0KICAgICBjbG9zZWx5IHJlbGF0ZWQgdG8gY29weXJpZ2h0IGluY2x1
ZGluZywgd2l0aG91dCBsaW1pdGF0aW9uLA0KICAgICBwZXJmb3JtYW5jZSwgYnJvYWRjYXN0LCBz
b3VuZCByZWNvcmRpbmcsIGFuZCBTdWkgR2VuZXJpcyBEYXRhYmFzZQ0KICAgICBSaWdodHMsIHdp
dGhvdXQgcmVnYXJkIHRvIGhvdyB0aGUgcmlnaHRzIGFyZSBsYWJlbGVkIG9yDQogICAgIGNhdGVn
b3JpemVkLiBGb3IgcHVycG9zZXMgb2YgdGhpcyBQdWJsaWMgTGljZW5zZSwgdGhlIHJpZ2h0cw0K
ICAgICBzcGVjaWZpZWQgaW4gU2VjdGlvbiAyKGIpKDEpLSgyKSBhcmUgbm90IENvcHlyaWdodCBh
bmQgU2ltaWxhcg0KICAgICBSaWdodHMuDQoNCiAgZS4gRWZmZWN0aXZlIFRlY2hub2xvZ2ljYWwg
TWVhc3VyZXMgbWVhbnMgdGhvc2UgbWVhc3VyZXMgdGhhdCwgaW4gdGhlDQogICAgIGFic2VuY2Ug
b2YgcHJvcGVyIGF1dGhvcml0eSwgbWF5IG5vdCBiZSBjaXJjdW12ZW50ZWQgdW5kZXIgbGF3cw0K
ICAgICBmdWxmaWxsaW5nIG9ibGlnYXRpb25zIHVuZGVyIEFydGljbGUgMTEgb2YgdGhlIFdJUE8g
Q29weXJpZ2h0DQogICAgIFRyZWF0eSBhZG9wdGVkIG9uIERlY2VtYmVyIDIwLCAxOTk2LCBhbmQv
b3Igc2ltaWxhciBpbnRlcm5hdGlvbmFsDQogICAgIGFncmVlbWVudHMuDQoNCiAgZi4gRXhjZXB0
aW9ucyBhbmQgTGltaXRhdGlvbnMgbWVhbnMgZmFpciB1c2UsIGZhaXIgZGVhbGluZywgYW5kL29y
DQogICAgIGFueSBvdGhlciBleGNlcHRpb24gb3IgbGltaXRhdGlvbiB0byBDb3B5cmlnaHQgYW5k
IFNpbWlsYXIgUmlnaHRzDQogICAgIHRoYXQgYXBwbGllcyB0byBZb3VyIHVzZSBvZiB0aGUgTGlj
ZW5zZWQgTWF0ZXJpYWwuDQoNCiAgZy4gTGljZW5zZSBFbGVtZW50cyBtZWFucyB0aGUgbGljZW5z
ZSBhdHRyaWJ1dGVzIGxpc3RlZCBpbiB0aGUgbmFtZQ0KICAgICBvZiBhIENyZWF0aXZlIENvbW1v
bnMgUHVibGljIExpY2Vuc2UuIFRoZSBMaWNlbnNlIEVsZW1lbnRzIG9mIHRoaXMNCiAgICAgUHVi
bGljIExpY2Vuc2UgYXJlIEF0dHJpYnV0aW9uLCBOb25Db21tZXJjaWFsLCBhbmQgU2hhcmVBbGlr
ZS4NCg0KICBoLiBMaWNlbnNlZCBNYXRlcmlhbCBtZWFucyB0aGUgYXJ0aXN0aWMgb3IgbGl0ZXJh
cnkgd29yaywgZGF0YWJhc2UsDQogICAgIG9yIG90aGVyIG1hdGVyaWFsIHRvIHdoaWNoIHRoZSBM
aWNlbnNvciBhcHBsaWVkIHRoaXMgUHVibGljDQogICAgIExpY2Vuc2UuDQoNCiAgaS4gTGljZW5z
ZWQgUmlnaHRzIG1lYW5zIHRoZSByaWdodHMgZ3JhbnRlZCB0byBZb3Ugc3ViamVjdCB0byB0aGUN
CiAgICAgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhpcyBQdWJsaWMgTGljZW5zZSwgd2hpY2gg
YXJlIGxpbWl0ZWQgdG8NCiAgICAgYWxsIENvcHlyaWdodCBhbmQgU2ltaWxhciBSaWdodHMgdGhh
dCBhcHBseSB0byBZb3VyIHVzZSBvZiB0aGUNCiAgICAgTGljZW5zZWQgTWF0ZXJpYWwgYW5kIHRo
YXQgdGhlIExpY2Vuc29yIGhhcyBhdXRob3JpdHkgdG8gbGljZW5zZS4NCg0KICBqLiBMaWNlbnNv
ciBtZWFucyB0aGUgaW5kaXZpZHVhbChzKSBvciBlbnRpdHkoaWVzKSBncmFudGluZyByaWdodHMN
CiAgICAgdW5kZXIgdGhpcyBQdWJsaWMgTGljZW5zZS4NCg0KICBrLiBOb25Db21tZXJjaWFsIG1l
YW5zIG5vdCBwcmltYXJpbHkgaW50ZW5kZWQgZm9yIG9yIGRpcmVjdGVkIHRvd2FyZHMNCiAgICAg
Y29tbWVyY2lhbCBhZHZhbnRhZ2Ugb3IgbW9uZXRhcnkgY29tcGVuc2F0aW9uLiBGb3IgcHVycG9z
ZXMgb2YNCiAgICAgdGhpcyBQdWJsaWMgTGljZW5zZSwgdGhlIGV4Y2hhbmdlIG9mIHRoZSBMaWNl
bnNlZCBNYXRlcmlhbCBmb3INCiAgICAgb3RoZXIgbWF0ZXJpYWwgc3ViamVjdCB0byBDb3B5cmln
aHQgYW5kIFNpbWlsYXIgUmlnaHRzIGJ5IGRpZ2l0YWwNCiAgICAgZmlsZS1zaGFyaW5nIG9yIHNp
bWlsYXIgbWVhbnMgaXMgTm9uQ29tbWVyY2lhbCBwcm92aWRlZCB0aGVyZSBpcw0KICAgICBubyBw
YXltZW50IG9mIG1vbmV0YXJ5IGNvbXBlbnNhdGlvbiBpbiBjb25uZWN0aW9uIHdpdGggdGhlDQog
ICAgIGV4Y2hhbmdlLg0KDQogIGwuIFNoYXJlIG1lYW5zIHRvIHByb3ZpZGUgbWF0ZXJpYWwgdG8g
dGhlIHB1YmxpYyBieSBhbnkgbWVhbnMgb3INCiAgICAgcHJvY2VzcyB0aGF0IHJlcXVpcmVzIHBl
cm1pc3Npb24gdW5kZXIgdGhlIExpY2Vuc2VkIFJpZ2h0cywgc3VjaA0KICAgICBhcyByZXByb2R1
Y3Rpb24sIHB1YmxpYyBkaXNwbGF5LCBwdWJsaWMgcGVyZm9ybWFuY2UsIGRpc3RyaWJ1dGlvbiwN
CiAgICAgZGlzc2VtaW5hdGlvbiwgY29tbXVuaWNhdGlvbiwgb3IgaW1wb3J0YXRpb24sIGFuZCB0
byBtYWtlIG1hdGVyaWFsDQogICAgIGF2YWlsYWJsZSB0byB0aGUgcHVibGljIGluY2x1ZGluZyBp
biB3YXlzIHRoYXQgbWVtYmVycyBvZiB0aGUNCiAgICAgcHVibGljIG1heSBhY2Nlc3MgdGhlIG1h
dGVyaWFsIGZyb20gYSBwbGFjZSBhbmQgYXQgYSB0aW1lDQogICAgIGluZGl2aWR1YWxseSBjaG9z
ZW4gYnkgdGhlbS4NCg0KICBtLiBTdWkgR2VuZXJpcyBEYXRhYmFzZSBSaWdodHMgbWVhbnMgcmln
aHRzIG90aGVyIHRoYW4gY29weXJpZ2h0DQogICAgIHJlc3VsdGluZyBmcm9tIERpcmVjdGl2ZSA5
Ni85L0VDIG9mIHRoZSBFdXJvcGVhbiBQYXJsaWFtZW50IGFuZCBvZg0KICAgICB0aGUgQ291bmNp
bCBvZiAxMSBNYXJjaCAxOTk2IG9uIHRoZSBsZWdhbCBwcm90ZWN0aW9uIG9mIGRhdGFiYXNlcywN
CiAgICAgYXMgYW1lbmRlZCBhbmQvb3Igc3VjY2VlZGVkLCBhcyB3ZWxsIGFzIG90aGVyIGVzc2Vu
dGlhbGx5DQogICAgIGVxdWl2YWxlbnQgcmlnaHRzIGFueXdoZXJlIGluIHRoZSB3b3JsZC4NCg0K
ICBuLiBZb3UgbWVhbnMgdGhlIGluZGl2aWR1YWwgb3IgZW50aXR5IGV4ZXJjaXNpbmcgdGhlIExp
Y2Vuc2VkIFJpZ2h0cw0KICAgICB1bmRlciB0aGlzIFB1YmxpYyBMaWNlbnNlLiBZb3VyIGhhcyBh
IGNvcnJlc3BvbmRpbmcgbWVhbmluZy4NCg0KDQpTZWN0aW9uIDIgLS0gU2NvcGUuDQoNCiAgYS4g
TGljZW5zZSBncmFudC4NCg0KICAgICAgIDEuIFN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZCBjb25k
aXRpb25zIG9mIHRoaXMgUHVibGljIExpY2Vuc2UsDQogICAgICAgICAgdGhlIExpY2Vuc29yIGhl
cmVieSBncmFudHMgWW91IGEgd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsDQogICAgICAgICAgbm9u
LXN1YmxpY2Vuc2FibGUsIG5vbi1leGNsdXNpdmUsIGlycmV2b2NhYmxlIGxpY2Vuc2UgdG8NCiAg
ICAgICAgICBleGVyY2lzZSB0aGUgTGljZW5zZWQgUmlnaHRzIGluIHRoZSBMaWNlbnNlZCBNYXRl
cmlhbCB0bzoNCg0KICAgICAgICAgICAgYS4gcmVwcm9kdWNlIGFuZCBTaGFyZSB0aGUgTGljZW5z
ZWQgTWF0ZXJpYWwsIGluIHdob2xlIG9yDQogICAgICAgICAgICAgICBpbiBwYXJ0LCBmb3IgTm9u
Q29tbWVyY2lhbCBwdXJwb3NlcyBvbmx5OyBhbmQNCg0KICAgICAgICAgICAgYi4gcHJvZHVjZSwg
cmVwcm9kdWNlLCBhbmQgU2hhcmUgQWRhcHRlZCBNYXRlcmlhbCBmb3INCiAgICAgICAgICAgICAg
IE5vbkNvbW1lcmNpYWwgcHVycG9zZXMgb25seS4NCg0KICAgICAgIDIuIEV4Y2VwdGlvbnMgYW5k
IExpbWl0YXRpb25zLiBGb3IgdGhlIGF2b2lkYW5jZSBvZiBkb3VidCwgd2hlcmUNCiAgICAgICAg
ICBFeGNlcHRpb25zIGFuZCBMaW1pdGF0aW9ucyBhcHBseSB0byBZb3VyIHVzZSwgdGhpcyBQdWJs
aWMNCiAgICAgICAgICBMaWNlbnNlIGRvZXMgbm90IGFwcGx5LCBhbmQgWW91IGRvIG5vdCBuZWVk
IHRvIGNvbXBseSB3aXRoDQogICAgICAgICAgaXRzIHRlcm1zIGFuZCBjb25kaXRpb25zLg0KDQog
ICAgICAgMy4gVGVybS4gVGhlIHRlcm0gb2YgdGhpcyBQdWJsaWMgTGljZW5zZSBpcyBzcGVjaWZp
ZWQgaW4gU2VjdGlvbg0KICAgICAgICAgIDYoYSkuDQoNCiAgICAgICA0LiBNZWRpYSBhbmQgZm9y
bWF0czsgdGVjaG5pY2FsIG1vZGlmaWNhdGlvbnMgYWxsb3dlZC4gVGhlDQogICAgICAgICAgTGlj
ZW5zb3IgYXV0aG9yaXplcyBZb3UgdG8gZXhlcmNpc2UgdGhlIExpY2Vuc2VkIFJpZ2h0cyBpbg0K
ICAgICAgICAgIGFsbCBtZWRpYSBhbmQgZm9ybWF0cyB3aGV0aGVyIG5vdyBrbm93biBvciBoZXJl
YWZ0ZXIgY3JlYXRlZCwNCiAgICAgICAgICBhbmQgdG8gbWFrZSB0ZWNobmljYWwgbW9kaWZpY2F0
aW9ucyBuZWNlc3NhcnkgdG8gZG8gc28uIFRoZQ0KICAgICAgICAgIExpY2Vuc29yIHdhaXZlcyBh
bmQvb3IgYWdyZWVzIG5vdCB0byBhc3NlcnQgYW55IHJpZ2h0IG9yDQogICAgICAgICAgYXV0aG9y
aXR5IHRvIGZvcmJpZCBZb3UgZnJvbSBtYWtpbmcgdGVjaG5pY2FsIG1vZGlmaWNhdGlvbnMNCiAg
ICAgICAgICBuZWNlc3NhcnkgdG8gZXhlcmNpc2UgdGhlIExpY2Vuc2VkIFJpZ2h0cywgaW5jbHVk
aW5nDQogICAgICAgICAgdGVjaG5pY2FsIG1vZGlmaWNhdGlvbnMgbmVjZXNzYXJ5IHRvIGNpcmN1
bXZlbnQgRWZmZWN0aXZlDQogICAgICAgICAgVGVjaG5vbG9naWNhbCBNZWFzdXJlcy4gRm9yIHB1
cnBvc2VzIG9mIHRoaXMgUHVibGljIExpY2Vuc2UsDQogICAgICAgICAgc2ltcGx5IG1ha2luZyBt
b2RpZmljYXRpb25zIGF1dGhvcml6ZWQgYnkgdGhpcyBTZWN0aW9uIDIoYSkNCiAgICAgICAgICAo
NCkgbmV2ZXIgcHJvZHVjZXMgQWRhcHRlZCBNYXRlcmlhbC4NCg0KICAgICAgIDUuIERvd25zdHJl
YW0gcmVjaXBpZW50cy4NCg0KICAgICAgICAgICAgYS4gT2ZmZXIgZnJvbSB0aGUgTGljZW5zb3Ig
LS0gTGljZW5zZWQgTWF0ZXJpYWwuIEV2ZXJ5DQogICAgICAgICAgICAgICByZWNpcGllbnQgb2Yg
dGhlIExpY2Vuc2VkIE1hdGVyaWFsIGF1dG9tYXRpY2FsbHkNCiAgICAgICAgICAgICAgIHJlY2Vp
dmVzIGFuIG9mZmVyIGZyb20gdGhlIExpY2Vuc29yIHRvIGV4ZXJjaXNlIHRoZQ0KICAgICAgICAg
ICAgICAgTGljZW5zZWQgUmlnaHRzIHVuZGVyIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0
aGlzDQogICAgICAgICAgICAgICBQdWJsaWMgTGljZW5zZS4NCg0KICAgICAgICAgICAgYi4gQWRk
aXRpb25hbCBvZmZlciBmcm9tIHRoZSBMaWNlbnNvciAtLSBBZGFwdGVkIE1hdGVyaWFsLg0KICAg
ICAgICAgICAgICAgRXZlcnkgcmVjaXBpZW50IG9mIEFkYXB0ZWQgTWF0ZXJpYWwgZnJvbSBZb3UN
CiAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgcmVjZWl2ZXMgYW4gb2ZmZXIgZnJvbSB0aGUg
TGljZW5zb3IgdG8NCiAgICAgICAgICAgICAgIGV4ZXJjaXNlIHRoZSBMaWNlbnNlZCBSaWdodHMg
aW4gdGhlIEFkYXB0ZWQgTWF0ZXJpYWwNCiAgICAgICAgICAgICAgIHVuZGVyIHRoZSBjb25kaXRp
b25zIG9mIHRoZSBBZGFwdGVyJ3MgTGljZW5zZSBZb3UgYXBwbHkuDQoNCiAgICAgICAgICAgIGMu
IE5vIGRvd25zdHJlYW0gcmVzdHJpY3Rpb25zLiBZb3UgbWF5IG5vdCBvZmZlciBvciBpbXBvc2UN
CiAgICAgICAgICAgICAgIGFueSBhZGRpdGlvbmFsIG9yIGRpZmZlcmVudCB0ZXJtcyBvciBjb25k
aXRpb25zIG9uLCBvcg0KICAgICAgICAgICAgICAgYXBwbHkgYW55IEVmZmVjdGl2ZSBUZWNobm9s
b2dpY2FsIE1lYXN1cmVzIHRvLCB0aGUNCiAgICAgICAgICAgICAgIExpY2Vuc2VkIE1hdGVyaWFs
IGlmIGRvaW5nIHNvIHJlc3RyaWN0cyBleGVyY2lzZSBvZiB0aGUNCiAgICAgICAgICAgICAgIExp
Y2Vuc2VkIFJpZ2h0cyBieSBhbnkgcmVjaXBpZW50IG9mIHRoZSBMaWNlbnNlZA0KICAgICAgICAg
ICAgICAgTWF0ZXJpYWwuDQoNCiAgICAgICA2LiBObyBlbmRvcnNlbWVudC4gTm90aGluZyBpbiB0
aGlzIFB1YmxpYyBMaWNlbnNlIGNvbnN0aXR1dGVzIG9yDQogICAgICAgICAgbWF5IGJlIGNvbnN0
cnVlZCBhcyBwZXJtaXNzaW9uIHRvIGFzc2VydCBvciBpbXBseSB0aGF0IFlvdQ0KICAgICAgICAg
IGFyZSwgb3IgdGhhdCBZb3VyIHVzZSBvZiB0aGUgTGljZW5zZWQgTWF0ZXJpYWwgaXMsIGNvbm5l
Y3RlZA0KICAgICAgICAgIHdpdGgsIG9yIHNwb25zb3JlZCwgZW5kb3JzZWQsIG9yIGdyYW50ZWQg
b2ZmaWNpYWwgc3RhdHVzIGJ5LA0KICAgICAgICAgIHRoZSBMaWNlbnNvciBvciBvdGhlcnMgZGVz
aWduYXRlZCB0byByZWNlaXZlIGF0dHJpYnV0aW9uIGFzDQogICAgICAgICAgcHJvdmlkZWQgaW4g
U2VjdGlvbiAzKGEpKDEpKEEpKGkpLg0KDQogIGIuIE90aGVyIHJpZ2h0cy4NCg0KICAgICAgIDEu
IE1vcmFsIHJpZ2h0cywgc3VjaCBhcyB0aGUgcmlnaHQgb2YgaW50ZWdyaXR5LCBhcmUgbm90DQog
ICAgICAgICAgbGljZW5zZWQgdW5kZXIgdGhpcyBQdWJsaWMgTGljZW5zZSwgbm9yIGFyZSBwdWJs
aWNpdHksDQogICAgICAgICAgcHJpdmFjeSwgYW5kL29yIG90aGVyIHNpbWlsYXIgcGVyc29uYWxp
dHkgcmlnaHRzOyBob3dldmVyLCB0bw0KICAgICAgICAgIHRoZSBleHRlbnQgcG9zc2libGUsIHRo
ZSBMaWNlbnNvciB3YWl2ZXMgYW5kL29yIGFncmVlcyBub3QgdG8NCiAgICAgICAgICBhc3NlcnQg
YW55IHN1Y2ggcmlnaHRzIGhlbGQgYnkgdGhlIExpY2Vuc29yIHRvIHRoZSBsaW1pdGVkDQogICAg
ICAgICAgZXh0ZW50IG5lY2Vzc2FyeSB0byBhbGxvdyBZb3UgdG8gZXhlcmNpc2UgdGhlIExpY2Vu
c2VkDQogICAgICAgICAgUmlnaHRzLCBidXQgbm90IG90aGVyd2lzZS4NCg0KICAgICAgIDIuIFBh
dGVudCBhbmQgdHJhZGVtYXJrIHJpZ2h0cyBhcmUgbm90IGxpY2Vuc2VkIHVuZGVyIHRoaXMNCiAg
ICAgICAgICBQdWJsaWMgTGljZW5zZS4NCg0KICAgICAgIDMuIFRvIHRoZSBleHRlbnQgcG9zc2li
bGUsIHRoZSBMaWNlbnNvciB3YWl2ZXMgYW55IHJpZ2h0IHRvDQogICAgICAgICAgY29sbGVjdCBy
b3lhbHRpZXMgZnJvbSBZb3UgZm9yIHRoZSBleGVyY2lzZSBvZiB0aGUgTGljZW5zZWQNCiAgICAg
ICAgICBSaWdodHMsIHdoZXRoZXIgZGlyZWN0bHkgb3IgdGhyb3VnaCBhIGNvbGxlY3Rpbmcgc29j
aWV0eQ0KICAgICAgICAgIHVuZGVyIGFueSB2b2x1bnRhcnkgb3Igd2FpdmFibGUgc3RhdHV0b3J5
IG9yIGNvbXB1bHNvcnkNCiAgICAgICAgICBsaWNlbnNpbmcgc2NoZW1lLiBJbiBhbGwgb3RoZXIg
Y2FzZXMgdGhlIExpY2Vuc29yIGV4cHJlc3NseQ0KICAgICAgICAgIHJlc2VydmVzIGFueSByaWdo
dCB0byBjb2xsZWN0IHN1Y2ggcm95YWx0aWVzLCBpbmNsdWRpbmcgd2hlbg0KICAgICAgICAgIHRo
ZSBMaWNlbnNlZCBNYXRlcmlhbCBpcyB1c2VkIG90aGVyIHRoYW4gZm9yIE5vbkNvbW1lcmNpYWwN
CiAgICAgICAgICBwdXJwb3Nlcy4NCg0KDQpTZWN0aW9uIDMgLS0gTGljZW5zZSBDb25kaXRpb25z
Lg0KDQpZb3VyIGV4ZXJjaXNlIG9mIHRoZSBMaWNlbnNlZCBSaWdodHMgaXMgZXhwcmVzc2x5IG1h
ZGUgc3ViamVjdCB0byB0aGUNCmZvbGxvd2luZyBjb25kaXRpb25zLg0KDQogIGEuIEF0dHJpYnV0
aW9uLg0KDQogICAgICAgMS4gSWYgWW91IFNoYXJlIHRoZSBMaWNlbnNlZCBNYXRlcmlhbCAoaW5j
bHVkaW5nIGluIG1vZGlmaWVkDQogICAgICAgICAgZm9ybSksIFlvdSBtdXN0Og0KDQogICAgICAg
ICAgICBhLiByZXRhaW4gdGhlIGZvbGxvd2luZyBpZiBpdCBpcyBzdXBwbGllZCBieSB0aGUgTGlj
ZW5zb3INCiAgICAgICAgICAgICAgIHdpdGggdGhlIExpY2Vuc2VkIE1hdGVyaWFsOg0KDQogICAg
ICAgICAgICAgICAgIGkuIGlkZW50aWZpY2F0aW9uIG9mIHRoZSBjcmVhdG9yKHMpIG9mIHRoZSBM
aWNlbnNlZA0KICAgICAgICAgICAgICAgICAgICBNYXRlcmlhbCBhbmQgYW55IG90aGVycyBkZXNp
Z25hdGVkIHRvIHJlY2VpdmUNCiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb24sIGluIGFu
eSByZWFzb25hYmxlIG1hbm5lciByZXF1ZXN0ZWQgYnkNCiAgICAgICAgICAgICAgICAgICAgdGhl
IExpY2Vuc29yIChpbmNsdWRpbmcgYnkgcHNldWRvbnltIGlmDQogICAgICAgICAgICAgICAgICAg
IGRlc2lnbmF0ZWQpOw0KDQogICAgICAgICAgICAgICAgaWkuIGEgY29weXJpZ2h0IG5vdGljZTsN
Cg0KICAgICAgICAgICAgICAgaWlpLiBhIG5vdGljZSB0aGF0IHJlZmVycyB0byB0aGlzIFB1Ymxp
YyBMaWNlbnNlOw0KDQogICAgICAgICAgICAgICAgaXYuIGEgbm90aWNlIHRoYXQgcmVmZXJzIHRv
IHRoZSBkaXNjbGFpbWVyIG9mDQogICAgICAgICAgICAgICAgICAgIHdhcnJhbnRpZXM7DQoNCiAg
ICAgICAgICAgICAgICAgdi4gYSBVUkkgb3IgaHlwZXJsaW5rIHRvIHRoZSBMaWNlbnNlZCBNYXRl
cmlhbCB0byB0aGUNCiAgICAgICAgICAgICAgICAgICAgZXh0ZW50IHJlYXNvbmFibHkgcHJhY3Rp
Y2FibGU7DQoNCiAgICAgICAgICAgIGIuIGluZGljYXRlIGlmIFlvdSBtb2RpZmllZCB0aGUgTGlj
ZW5zZWQgTWF0ZXJpYWwgYW5kDQogICAgICAgICAgICAgICByZXRhaW4gYW4gaW5kaWNhdGlvbiBv
ZiBhbnkgcHJldmlvdXMgbW9kaWZpY2F0aW9uczsgYW5kDQoNCiAgICAgICAgICAgIGMuIGluZGlj
YXRlIHRoZSBMaWNlbnNlZCBNYXRlcmlhbCBpcyBsaWNlbnNlZCB1bmRlciB0aGlzDQogICAgICAg
ICAgICAgICBQdWJsaWMgTGljZW5zZSwgYW5kIGluY2x1ZGUgdGhlIHRleHQgb2YsIG9yIHRoZSBV
Ukkgb3INCiAgICAgICAgICAgICAgIGh5cGVybGluayB0bywgdGhpcyBQdWJsaWMgTGljZW5zZS4N
Cg0KICAgICAgIDIuIFlvdSBtYXkgc2F0aXNmeSB0aGUgY29uZGl0aW9ucyBpbiBTZWN0aW9uIDMo
YSkoMSkgaW4gYW55DQogICAgICAgICAgcmVhc29uYWJsZSBtYW5uZXIgYmFzZWQgb24gdGhlIG1l
ZGl1bSwgbWVhbnMsIGFuZCBjb250ZXh0IGluDQogICAgICAgICAgd2hpY2ggWW91IFNoYXJlIHRo
ZSBMaWNlbnNlZCBNYXRlcmlhbC4gRm9yIGV4YW1wbGUsIGl0IG1heSBiZQ0KICAgICAgICAgIHJl
YXNvbmFibGUgdG8gc2F0aXNmeSB0aGUgY29uZGl0aW9ucyBieSBwcm92aWRpbmcgYSBVUkkgb3IN
CiAgICAgICAgICBoeXBlcmxpbmsgdG8gYSByZXNvdXJjZSB0aGF0IGluY2x1ZGVzIHRoZSByZXF1
aXJlZA0KICAgICAgICAgIGluZm9ybWF0aW9uLg0KICAgICAgIDMuIElmIHJlcXVlc3RlZCBieSB0
aGUgTGljZW5zb3IsIFlvdSBtdXN0IHJlbW92ZSBhbnkgb2YgdGhlDQogICAgICAgICAgaW5mb3Jt
YXRpb24gcmVxdWlyZWQgYnkgU2VjdGlvbiAzKGEpKDEpKEEpIHRvIHRoZSBleHRlbnQNCiAgICAg
ICAgICByZWFzb25hYmx5IHByYWN0aWNhYmxlLg0KDQogIGIuIFNoYXJlQWxpa2UuDQoNCiAgICAg
SW4gYWRkaXRpb24gdG8gdGhlIGNvbmRpdGlvbnMgaW4gU2VjdGlvbiAzKGEpLCBpZiBZb3UgU2hh
cmUNCiAgICAgQWRhcHRlZCBNYXRlcmlhbCBZb3UgcHJvZHVjZSwgdGhlIGZvbGxvd2luZyBjb25k
aXRpb25zIGFsc28gYXBwbHkuDQoNCiAgICAgICAxLiBUaGUgQWRhcHRlcidzIExpY2Vuc2UgWW91
IGFwcGx5IG11c3QgYmUgYSBDcmVhdGl2ZSBDb21tb25zDQogICAgICAgICAgbGljZW5zZSB3aXRo
IHRoZSBzYW1lIExpY2Vuc2UgRWxlbWVudHMsIHRoaXMgdmVyc2lvbiBvcg0KICAgICAgICAgIGxh
dGVyLCBvciBhIEJZLU5DLVNBIENvbXBhdGlibGUgTGljZW5zZS4NCg0KICAgICAgIDIuIFlvdSBt
dXN0IGluY2x1ZGUgdGhlIHRleHQgb2YsIG9yIHRoZSBVUkkgb3IgaHlwZXJsaW5rIHRvLCB0aGUN
CiAgICAgICAgICBBZGFwdGVyJ3MgTGljZW5zZSBZb3UgYXBwbHkuIFlvdSBtYXkgc2F0aXNmeSB0
aGlzIGNvbmRpdGlvbg0KICAgICAgICAgIGluIGFueSByZWFzb25hYmxlIG1hbm5lciBiYXNlZCBv
biB0aGUgbWVkaXVtLCBtZWFucywgYW5kDQogICAgICAgICAgY29udGV4dCBpbiB3aGljaCBZb3Ug
U2hhcmUgQWRhcHRlZCBNYXRlcmlhbC4NCg0KICAgICAgIDMuIFlvdSBtYXkgbm90IG9mZmVyIG9y
IGltcG9zZSBhbnkgYWRkaXRpb25hbCBvciBkaWZmZXJlbnQgdGVybXMNCiAgICAgICAgICBvciBj
b25kaXRpb25zIG9uLCBvciBhcHBseSBhbnkgRWZmZWN0aXZlIFRlY2hub2xvZ2ljYWwNCiAgICAg
ICAgICBNZWFzdXJlcyB0bywgQWRhcHRlZCBNYXRlcmlhbCB0aGF0IHJlc3RyaWN0IGV4ZXJjaXNl
IG9mIHRoZQ0KICAgICAgICAgIHJpZ2h0cyBncmFudGVkIHVuZGVyIHRoZSBBZGFwdGVyJ3MgTGlj
ZW5zZSBZb3UgYXBwbHkuDQoNCg0KU2VjdGlvbiA0IC0tIFN1aSBHZW5lcmlzIERhdGFiYXNlIFJp
Z2h0cy4NCg0KV2hlcmUgdGhlIExpY2Vuc2VkIFJpZ2h0cyBpbmNsdWRlIFN1aSBHZW5lcmlzIERh
dGFiYXNlIFJpZ2h0cyB0aGF0DQphcHBseSB0byBZb3VyIHVzZSBvZiB0aGUgTGljZW5zZWQgTWF0
ZXJpYWw6DQoNCiAgYS4gZm9yIHRoZSBhdm9pZGFuY2Ugb2YgZG91YnQsIFNlY3Rpb24gMihhKSgx
KSBncmFudHMgWW91IHRoZSByaWdodA0KICAgICB0byBleHRyYWN0LCByZXVzZSwgcmVwcm9kdWNl
LCBhbmQgU2hhcmUgYWxsIG9yIGEgc3Vic3RhbnRpYWwNCiAgICAgcG9ydGlvbiBvZiB0aGUgY29u
dGVudHMgb2YgdGhlIGRhdGFiYXNlIGZvciBOb25Db21tZXJjaWFsIHB1cnBvc2VzDQogICAgIG9u
bHk7DQoNCiAgYi4gaWYgWW91IGluY2x1ZGUgYWxsIG9yIGEgc3Vic3RhbnRpYWwgcG9ydGlvbiBv
ZiB0aGUgZGF0YWJhc2UNCiAgICAgY29udGVudHMgaW4gYSBkYXRhYmFzZSBpbiB3aGljaCBZb3Ug
aGF2ZSBTdWkgR2VuZXJpcyBEYXRhYmFzZQ0KICAgICBSaWdodHMsIHRoZW4gdGhlIGRhdGFiYXNl
IGluIHdoaWNoIFlvdSBoYXZlIFN1aSBHZW5lcmlzIERhdGFiYXNlDQogICAgIFJpZ2h0cyAoYnV0
IG5vdCBpdHMgaW5kaXZpZHVhbCBjb250ZW50cykgaXMgQWRhcHRlZCBNYXRlcmlhbCwNCiAgICAg
aW5jbHVkaW5nIGZvciBwdXJwb3NlcyBvZiBTZWN0aW9uIDMoYik7IGFuZA0KDQogIGMuIFlvdSBt
dXN0IGNvbXBseSB3aXRoIHRoZSBjb25kaXRpb25zIGluIFNlY3Rpb24gMyhhKSBpZiBZb3UgU2hh
cmUNCiAgICAgYWxsIG9yIGEgc3Vic3RhbnRpYWwgcG9ydGlvbiBvZiB0aGUgY29udGVudHMgb2Yg
dGhlIGRhdGFiYXNlLg0KDQpGb3IgdGhlIGF2b2lkYW5jZSBvZiBkb3VidCwgdGhpcyBTZWN0aW9u
IDQgc3VwcGxlbWVudHMgYW5kIGRvZXMgbm90DQpyZXBsYWNlIFlvdXIgb2JsaWdhdGlvbnMgdW5k
ZXIgdGhpcyBQdWJsaWMgTGljZW5zZSB3aGVyZSB0aGUgTGljZW5zZWQNClJpZ2h0cyBpbmNsdWRl
IG90aGVyIENvcHlyaWdodCBhbmQgU2ltaWxhciBSaWdodHMuDQoNCg0KU2VjdGlvbiA1IC0tIERp
c2NsYWltZXIgb2YgV2FycmFudGllcyBhbmQgTGltaXRhdGlvbiBvZiBMaWFiaWxpdHkuDQoNCiAg
YS4gVU5MRVNTIE9USEVSV0lTRSBTRVBBUkFURUxZIFVOREVSVEFLRU4gQlkgVEhFIExJQ0VOU09S
LCBUTyBUSEUNCiAgICAgRVhURU5UIFBPU1NJQkxFLCBUSEUgTElDRU5TT1IgT0ZGRVJTIFRIRSBM
SUNFTlNFRCBNQVRFUklBTCBBUy1JUw0KICAgICBBTkQgQVMtQVZBSUxBQkxFLCBBTkQgTUFLRVMg
Tk8gUkVQUkVTRU5UQVRJT05TIE9SIFdBUlJBTlRJRVMgT0YNCiAgICAgQU5ZIEtJTkQgQ09OQ0VS
TklORyBUSEUgTElDRU5TRUQgTUFURVJJQUwsIFdIRVRIRVIgRVhQUkVTUywNCiAgICAgSU1QTElF
RCwgU1RBVFVUT1JZLCBPUiBPVEhFUi4gVEhJUyBJTkNMVURFUywgV0lUSE9VVCBMSU1JVEFUSU9O
LA0KICAgICBXQVJSQU5USUVTIE9GIFRJVExFLCBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9S
IEEgUEFSVElDVUxBUg0KICAgICBQVVJQT1NFLCBOT04tSU5GUklOR0VNRU5ULCBBQlNFTkNFIE9G
IExBVEVOVCBPUiBPVEhFUiBERUZFQ1RTLA0KICAgICBBQ0NVUkFDWSwgT1IgVEhFIFBSRVNFTkNF
IE9SIEFCU0VOQ0UgT0YgRVJST1JTLCBXSEVUSEVSIE9SIE5PVA0KICAgICBLTk9XTiBPUiBESVND
T1ZFUkFCTEUuIFdIRVJFIERJU0NMQUlNRVJTIE9GIFdBUlJBTlRJRVMgQVJFIE5PVA0KICAgICBB
TExPV0VEIElOIEZVTEwgT1IgSU4gUEFSVCwgVEhJUyBESVNDTEFJTUVSIE1BWSBOT1QgQVBQTFkg
VE8gWU9VLg0KDQogIGIuIFRPIFRIRSBFWFRFTlQgUE9TU0lCTEUsIElOIE5PIEVWRU5UIFdJTEwg
VEhFIExJQ0VOU09SIEJFIExJQUJMRQ0KICAgICBUTyBZT1UgT04gQU5ZIExFR0FMIFRIRU9SWSAo
SU5DTFVESU5HLCBXSVRIT1VUIExJTUlUQVRJT04sDQogICAgIE5FR0xJR0VOQ0UpIE9SIE9USEVS
V0lTRSBGT1IgQU5ZIERJUkVDVCwgU1BFQ0lBTCwgSU5ESVJFQ1QsDQogICAgIElOQ0lERU5UQUws
IENPTlNFUVVFTlRJQUwsIFBVTklUSVZFLCBFWEVNUExBUlksIE9SIE9USEVSIExPU1NFUywNCiAg
ICAgQ09TVFMsIEVYUEVOU0VTLCBPUiBEQU1BR0VTIEFSSVNJTkcgT1VUIE9GIFRISVMgUFVCTElD
IExJQ0VOU0UgT1INCiAgICAgVVNFIE9GIFRIRSBMSUNFTlNFRCBNQVRFUklBTCwgRVZFTiBJRiBU
SEUgTElDRU5TT1IgSEFTIEJFRU4NCiAgICAgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0Yg
U1VDSCBMT1NTRVMsIENPU1RTLCBFWFBFTlNFUywgT1INCiAgICAgREFNQUdFUy4gV0hFUkUgQSBM
SU1JVEFUSU9OIE9GIExJQUJJTElUWSBJUyBOT1QgQUxMT1dFRCBJTiBGVUxMIE9SDQogICAgIElO
IFBBUlQsIFRISVMgTElNSVRBVElPTiBNQVkgTk9UIEFQUExZIFRPIFlPVS4NCg0KICBjLiBUaGUg
ZGlzY2xhaW1lciBvZiB3YXJyYW50aWVzIGFuZCBsaW1pdGF0aW9uIG9mIGxpYWJpbGl0eSBwcm92
aWRlZA0KICAgICBhYm92ZSBzaGFsbCBiZSBpbnRlcnByZXRlZCBpbiBhIG1hbm5lciB0aGF0LCB0
byB0aGUgZXh0ZW50DQogICAgIHBvc3NpYmxlLCBtb3N0IGNsb3NlbHkgYXBwcm94aW1hdGVzIGFu
IGFic29sdXRlIGRpc2NsYWltZXIgYW5kDQogICAgIHdhaXZlciBvZiBhbGwgbGlhYmlsaXR5Lg0K
DQoNClNlY3Rpb24gNiAtLSBUZXJtIGFuZCBUZXJtaW5hdGlvbi4NCg0KICBhLiBUaGlzIFB1Ymxp
YyBMaWNlbnNlIGFwcGxpZXMgZm9yIHRoZSB0ZXJtIG9mIHRoZSBDb3B5cmlnaHQgYW5kDQogICAg
IFNpbWlsYXIgUmlnaHRzIGxpY2Vuc2VkIGhlcmUuIEhvd2V2ZXIsIGlmIFlvdSBmYWlsIHRvIGNv
bXBseSB3aXRoDQogICAgIHRoaXMgUHVibGljIExpY2Vuc2UsIHRoZW4gWW91ciByaWdodHMgdW5k
ZXIgdGhpcyBQdWJsaWMgTGljZW5zZQ0KICAgICB0ZXJtaW5hdGUgYXV0b21hdGljYWxseS4NCg0K
ICBiLiBXaGVyZSBZb3VyIHJpZ2h0IHRvIHVzZSB0aGUgTGljZW5zZWQgTWF0ZXJpYWwgaGFzIHRl
cm1pbmF0ZWQgdW5kZXINCiAgICAgU2VjdGlvbiA2KGEpLCBpdCByZWluc3RhdGVzOg0KDQogICAg
ICAgMS4gYXV0b21hdGljYWxseSBhcyBvZiB0aGUgZGF0ZSB0aGUgdmlvbGF0aW9uIGlzIGN1cmVk
LCBwcm92aWRlZA0KICAgICAgICAgIGl0IGlzIGN1cmVkIHdpdGhpbiAzMCBkYXlzIG9mIFlvdXIg
ZGlzY292ZXJ5IG9mIHRoZQ0KICAgICAgICAgIHZpb2xhdGlvbjsgb3INCg0KICAgICAgIDIuIHVw
b24gZXhwcmVzcyByZWluc3RhdGVtZW50IGJ5IHRoZSBMaWNlbnNvci4NCg0KICAgICBGb3IgdGhl
IGF2b2lkYW5jZSBvZiBkb3VidCwgdGhpcyBTZWN0aW9uIDYoYikgZG9lcyBub3QgYWZmZWN0IGFu
eQ0KICAgICByaWdodCB0aGUgTGljZW5zb3IgbWF5IGhhdmUgdG8gc2VlayByZW1lZGllcyBmb3Ig
WW91ciB2aW9sYXRpb25zDQogICAgIG9mIHRoaXMgUHVibGljIExpY2Vuc2UuDQoNCiAgYy4gRm9y
IHRoZSBhdm9pZGFuY2Ugb2YgZG91YnQsIHRoZSBMaWNlbnNvciBtYXkgYWxzbyBvZmZlciB0aGUN
CiAgICAgTGljZW5zZWQgTWF0ZXJpYWwgdW5kZXIgc2VwYXJhdGUgdGVybXMgb3IgY29uZGl0aW9u
cyBvciBzdG9wDQogICAgIGRpc3RyaWJ1dGluZyB0aGUgTGljZW5zZWQgTWF0ZXJpYWwgYXQgYW55
IHRpbWU7IGhvd2V2ZXIsIGRvaW5nIHNvDQogICAgIHdpbGwgbm90IHRlcm1pbmF0ZSB0aGlzIFB1
YmxpYyBMaWNlbnNlLg0KDQogIGQuIFNlY3Rpb25zIDEsIDUsIDYsIDcsIGFuZCA4IHN1cnZpdmUg
dGVybWluYXRpb24gb2YgdGhpcyBQdWJsaWMNCiAgICAgTGljZW5zZS4NCg0KDQpTZWN0aW9uIDcg
LS0gT3RoZXIgVGVybXMgYW5kIENvbmRpdGlvbnMuDQoNCiAgYS4gVGhlIExpY2Vuc29yIHNoYWxs
IG5vdCBiZSBib3VuZCBieSBhbnkgYWRkaXRpb25hbCBvciBkaWZmZXJlbnQNCiAgICAgdGVybXMg
b3IgY29uZGl0aW9ucyBjb21tdW5pY2F0ZWQgYnkgWW91IHVubGVzcyBleHByZXNzbHkgYWdyZWVk
Lg0KDQogIGIuIEFueSBhcnJhbmdlbWVudHMsIHVuZGVyc3RhbmRpbmdzLCBvciBhZ3JlZW1lbnRz
IHJlZ2FyZGluZyB0aGUNCiAgICAgTGljZW5zZWQgTWF0ZXJpYWwgbm90IHN0YXRlZCBoZXJlaW4g
YXJlIHNlcGFyYXRlIGZyb20gYW5kDQogICAgIGluZGVwZW5kZW50IG9mIHRoZSB0ZXJtcyBhbmQg
Y29uZGl0aW9ucyBvZiB0aGlzIFB1YmxpYyBMaWNlbnNlLg0KDQoNClNlY3Rpb24gOCAtLSBJbnRl
cnByZXRhdGlvbi4NCg0KICBhLiBGb3IgdGhlIGF2b2lkYW5jZSBvZiBkb3VidCwgdGhpcyBQdWJs
aWMgTGljZW5zZSBkb2VzIG5vdCwgYW5kDQogICAgIHNoYWxsIG5vdCBiZSBpbnRlcnByZXRlZCB0
bywgcmVkdWNlLCBsaW1pdCwgcmVzdHJpY3QsIG9yIGltcG9zZQ0KICAgICBjb25kaXRpb25zIG9u
IGFueSB1c2Ugb2YgdGhlIExpY2Vuc2VkIE1hdGVyaWFsIHRoYXQgY291bGQgbGF3ZnVsbHkNCiAg
ICAgYmUgbWFkZSB3aXRob3V0IHBlcm1pc3Npb24gdW5kZXIgdGhpcyBQdWJsaWMgTGljZW5zZS4N
Cg0KICBiLiBUbyB0aGUgZXh0ZW50IHBvc3NpYmxlLCBpZiBhbnkgcHJvdmlzaW9uIG9mIHRoaXMg
UHVibGljIExpY2Vuc2UgaXMNCiAgICAgZGVlbWVkIHVuZW5mb3JjZWFibGUsIGl0IHNoYWxsIGJl
IGF1dG9tYXRpY2FsbHkgcmVmb3JtZWQgdG8gdGhlDQogICAgIG1pbmltdW0gZXh0ZW50IG5lY2Vz
c2FyeSB0byBtYWtlIGl0IGVuZm9yY2VhYmxlLiBJZiB0aGUgcHJvdmlzaW9uDQogICAgIGNhbm5v
dCBiZSByZWZvcm1lZCwgaXQgc2hhbGwgYmUgc2V2ZXJlZCBmcm9tIHRoaXMgUHVibGljIExpY2Vu
c2UNCiAgICAgd2l0aG91dCBhZmZlY3RpbmcgdGhlIGVuZm9yY2VhYmlsaXR5IG9mIHRoZSByZW1h
aW5pbmcgdGVybXMgYW5kDQogICAgIGNvbmRpdGlvbnMuDQoNCiAgYy4gTm8gdGVybSBvciBjb25k
aXRpb24gb2YgdGhpcyBQdWJsaWMgTGljZW5zZSB3aWxsIGJlIHdhaXZlZCBhbmQgbm8NCiAgICAg
ZmFpbHVyZSB0byBjb21wbHkgY29uc2VudGVkIHRvIHVubGVzcyBleHByZXNzbHkgYWdyZWVkIHRv
IGJ5IHRoZQ0KICAgICBMaWNlbnNvci4NCg0KICBkLiBOb3RoaW5nIGluIHRoaXMgUHVibGljIExp
Y2Vuc2UgY29uc3RpdHV0ZXMgb3IgbWF5IGJlIGludGVycHJldGVkDQogICAgIGFzIGEgbGltaXRh
dGlvbiB1cG9uLCBvciB3YWl2ZXIgb2YsIGFueSBwcml2aWxlZ2VzIGFuZCBpbW11bml0aWVzDQog
ICAgIHRoYXQgYXBwbHkgdG8gdGhlIExpY2Vuc29yIG9yIFlvdSwgaW5jbHVkaW5nIGZyb20gdGhl
IGxlZ2FsDQogICAgIHByb2Nlc3NlcyBvZiBhbnkganVyaXNkaWN0aW9uIG9yIGF1dGhvcml0eS4N
Cg0KPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT0NCg0KQ3JlYXRpdmUgQ29tbW9ucyBpcyBub3QgYSBwYXJ0eSB0byBp
dHMgcHVibGljDQpsaWNlbnNlcy4gTm90d2l0aHN0YW5kaW5nLCBDcmVhdGl2ZSBDb21tb25zIG1h
eSBlbGVjdCB0byBhcHBseSBvbmUgb2YNCml0cyBwdWJsaWMgbGljZW5zZXMgdG8gbWF0ZXJpYWwg
aXQgcHVibGlzaGVzIGFuZCBpbiB0aG9zZSBpbnN0YW5jZXMNCndpbGwgYmUgY29uc2lkZXJlZCB0
aGUg4oCcTGljZW5zb3Iu4oCdIFRoZSB0ZXh0IG9mIHRoZSBDcmVhdGl2ZSBDb21tb25zDQpwdWJs
aWMgbGljZW5zZXMgaXMgZGVkaWNhdGVkIHRvIHRoZSBwdWJsaWMgZG9tYWluIHVuZGVyIHRoZSBD
QzAgUHVibGljDQpEb21haW4gRGVkaWNhdGlvbi4gRXhjZXB0IGZvciB0aGUgbGltaXRlZCBwdXJw
b3NlIG9mIGluZGljYXRpbmcgdGhhdA0KbWF0ZXJpYWwgaXMgc2hhcmVkIHVuZGVyIGEgQ3JlYXRp
dmUgQ29tbW9ucyBwdWJsaWMgbGljZW5zZSBvciBhcw0Kb3RoZXJ3aXNlIHBlcm1pdHRlZCBieSB0
aGUgQ3JlYXRpdmUgQ29tbW9ucyBwb2xpY2llcyBwdWJsaXNoZWQgYXQNCmNyZWF0aXZlY29tbW9u
cy5vcmcvcG9saWNpZXMsIENyZWF0aXZlIENvbW1vbnMgZG9lcyBub3QgYXV0aG9yaXplIHRoZQ0K
dXNlIG9mIHRoZSB0cmFkZW1hcmsgIkNyZWF0aXZlIENvbW1vbnMiIG9yIGFueSBvdGhlciB0cmFk
ZW1hcmsgb3IgbG9nbw0Kb2YgQ3JlYXRpdmUgQ29tbW9ucyB3aXRob3V0IGl0cyBwcmlvciB3cml0
dGVuIGNvbnNlbnQgaW5jbHVkaW5nLA0Kd2l0aG91dCBsaW1pdGF0aW9uLCBpbiBjb25uZWN0aW9u
IHdpdGggYW55IHVuYXV0aG9yaXplZCBtb2RpZmljYXRpb25zDQp0byBhbnkgb2YgaXRzIHB1Ymxp
YyBsaWNlbnNlcyBvciBhbnkgb3RoZXIgYXJyYW5nZW1lbnRzLA0KdW5kZXJzdGFuZGluZ3MsIG9y
IGFncmVlbWVudHMgY29uY2VybmluZyB1c2Ugb2YgbGljZW5zZWQgbWF0ZXJpYWwuIEZvcg0KdGhl
IGF2b2lkYW5jZSBvZiBkb3VidCwgdGhpcyBwYXJhZ3JhcGggZG9lcyBub3QgZm9ybSBwYXJ0IG9m
IHRoZQ0KcHVibGljIGxpY2Vuc2VzLg0KDQpDcmVhdGl2ZSBDb21tb25zIG1heSBiZSBjb250YWN0
ZWQgYXQgY3JlYXRpdmVjb21tb25zLm9yZy4NCg==
:: main.lua
--[[pod_format="raw",created="2024-03-14 21:14:09",modified="2024-12-15 00:56:37",revision=23973]]
include"suite_scripts/suite_util.lua"

function _init()
-- I think this is okay? (still doesn't close workspace on exit though)
--[=[
	window{
		fullscreen = 1,
		width = 480, 
		height = 270,
		autoclose = true,
		pauseable = false,
		icon = 
--[[pod,pod_type="image"]]unpod("b64:bHo0ABwAAAAaAAAA8AtweHUAQyAICAQgF0A3IFcAdwAXEBcwF0A3kA==")
}
	
-- ]=]

	suite_load_game"suite_scripts/main_menu.lua"
end

function _update()
--	stat_up = stat(1)
	cards_api_update()	
--	stat_up = stat(1) - stat_up
end


function _draw()
--	stat_up2 = stat(1)
	cards_api_draw()
--	stat_up2 = stat(1) - stat_up2
	
--	?stat_up, 111, 220, 8
--	?stat_up2
--	set_clipboard(tostr(stat_up2) .. " / " .. tostr(stat_up + stat_up2))
--	?stat(7)
end

:: README.md
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNi0yOSAyMjoxNzoyOSIsbW9k
aWZpZWQ9IjIwMjQtMDYtMjkgMjI6NDU6NTIiLHJldmlzaW9uPTExN11dDQojIFBpY290cm9uIFNv
bGl0YWlyZSBTdWl0ZQ0KDQpIZXJlIEknbSBvbmx5IHNob3dpbmcgUGljb3Ryb24gU29saXRhaXJl
IFN1aXRlIHNwZWNpZmljIGZ1bmN0aW9ucy4gVG8gc2VlIHRoZSBtYWluIGxpc3QsIGNoZWNrIG91
dCB0aGUgYXBpIHJlYWRtZSAoaHR0cHM6Ly9naXRodWIuY29tL1dlcnh6eS9jYXJkc19hcGkvYmxv
Yi9tYWluL1JFQURNRS5tZCkuDQpBIGxvdCBvZiB0aGlzIGlzIHN1YmplY3QgdG8gY2hhbmdlLCBz
byBJJ2xsIHRyeSB0byBrZWVwIGluY3JlbWVudGFsIGNoYW5nZXMgZnJvbSBicmVha2luZyBhbnkg
bWFpbiB2ZXJzaW9ucy4gV2hpbGUgaGF2aW5nIG1ham9yIGNoYW5nZXMgcmVxdWlyZSBhIHZlcnNp
b24gY2hlY2sgZm9yIGVhY2ggZ2FtZS4NCg0KSXQgd291bGQgYmUgYSBnb29kIGlkZWEgdG8gbG9v
ayBhdCBzb21lIG9mIHRoZSBnYW1lcyBpbnNpZGUgdGhlIGZvbGRlciBgc29saXRhaXJlX3N1aXRl
LnA2NC9jYXJkX2dhbWVzL2Agb3IgaHR0cHM6Ly9naXRodWIuY29tL1dlcnh6eS9zb2xpdGFpcmVf
c3VpdGUucDY0L3RyZWUvbWFpbi9jYXJkX2dhbWVzIHRvIGdldCBhbiBpZGVhIG9mIGhvdyB0aGV5
IGFyZSBmb3JtYXR0ZWQuIA0KTG91aWVDaGFwbSBhbHNvIGhhcyBoaXMgZ2FtZXMgdXAgYXQgaHR0
cHM6Ly9naXRodWIuY29tL0xvdWllQ2hhcG0vcGljb3Ryb25Tb2xpdGFpcmVTdWl0ZV9WYXJpYW50
cy4NCg0KKipBTFNPLCBJIHdvdWxkIGhpZ2hseSByZWNvbW1lbmQgc3RhcnRpbmcgZnJvbSB0aGUg
ZXhhbXBsZSBwcm9qZWN0IGluc3RlYWQgb2Ygd29ya2luZyBmcm9tIHRoZSBtYWluIGNhcnQgb3Ig
dGhlIGdpdCByZXBvc2l0b3J5LiBBcyBpdCBpcyBtb3JlIGRlc2lnbmVkIGZvciBtb2RkaW5nLioq
DQoNCiMjIFNldHVwDQoNCkdhbWUgZmlsZXMgY2FuIGVpdGhlciBiZSBwbGFjZWQgaW5zaWRlIGBh
cHBkYXRhL3NvbGl0YWlyZV9zdWl0ZS9jYXJkX2dhbWVzL2AuDQpUbyBlbnN1cmUgdGhhdCB0aGUg
cmlnaHQgaW5mb3JtYXRpb24gaXMgYmVpbmcgbG9hZGVkLCBoYXZlIHlvdXIgZmlsZSBzdHJ1Y3R1
cmUgbG9vayBsaWtlIHRoaXMNCg0KYGBgDQovYXBwZGF0YS9zb2xpdGFpcmVfc3VpdGUvY2FyZF9n
YW1lcy9HQU1FTkFNRS9nYW1lX2luZm8ubHVhDQovYXBwZGF0YS9zb2xpdGFpcmVfc3VpdGUvY2Fy
ZF9nYW1lcy9HQU1FTkFNRS9HQU1FTkFNRS5sdWENCi9hcHBkYXRhL3NvbGl0YWlyZV9zdWl0ZS9j
YXJkX2dhbWVzL0dBTUVOQU1FLy4uLg0KYGBgDQoNClRoZSBzdWl0ZSB3aWxsIGxvb2sgZm9yIGZp
bGVzIG5hbWVkIGBnYW1lX2luZm8ubHVhYCBhbmQgdGhlaXIgcGFyZW50IGZvbGRlciB0byBkZXRl
cm1pbmUgd2hhdCBgR0FNRU5BTUVgIGlzLg0KQW55IG90aGVyIGZpbGVzIGNhbiBiZSBpbmNsdWRl
ZCBpbnNpZGUgYC9HQU1FTkFNRS9gDQoNCldoZW4gdXNpbmcgYGluY2x1ZGVgIG9yIGBmZXRjaGAs
IHN0YXJ0IHlvdXIgcGF0aCB3aXRoIGAvZ2FtZS9gIGluIG9yZGVyIHRvIGdldCB0aGUgZmlsZXMg
cmVsYXRpdmUgdG8gYGdhbWVfaW5mby5sdWFgIGFuZCBgR0FNRU5BTUUubHVhYC4NClRoaXMgd2ls
bCBoZWxwIHRoZSBTdWl0ZSBpbiBmZXRjaGluZyB0aGUgcmlnaHQgZmlsZXMsIGV2ZW4gaWYgdGhl
eSBhcmUgbG9hZGVkIGludG8gYC9hcHBkYXRhL2ANCg0KYGBgbHVhDQppbmNsdWRlIi9nYW1lL3N0
YWNrX3J1bGVzLmx1YSINCg0KZmlsZSA9IGZldGNoIi9nYW1lL2V4dHJhLnBvZCINCmBgYA0KDQpC
eSBuYW1pbmcgYSBncmFwaGljcyBmaWxlICJgMS5nZnhgIiwgaXQgd2lsbCBiZSBhdXRvbWF0aWNh
bGx5IHNldCB0aGUgc3ByaXRlcyBpbnRvIGlkcyAyNTYgdG8gNTEyIHdoZW4gdGhlIGdhbWVzIGlz
IGxvYWRlZC4NClRoaXMgd2lsbCBhbHNvIHdvcmsgd2l0aCBmaWxlIG5hbWVzIDIgYW5kIGFib3Zl
Lg0KTW9yZSBpbXBvcnRhbnRseSwgc3ByaXRlIDAsIG9yIDI1NiBoZXJlLCB3aWxsIGJlIHVzZWQg
Zm9yIHRoZSBjYXJkIGJveCBzcHJpdGUgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBvbiB0aGUgbWFp
biBtZW51Lg0KDQojIyMgZ2FtZV9pbmZvLmx1YQ0KDQpUaGlzIGZpbGUganVzdCBjb250YWlucyBh
IHNpbmdsZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0YWJsZSBjb250YWluaW5nIGluZm9ybWF0
aW9uIGZvciB0aGUgZ2FtZQ0KDQpgYGBsdWENCmZ1bmN0aW9uIGdhbWVfaW5mbygpDQoJcmV0dXJu
IHsNCgkJLS1zcHJpdGUgPSAzMiwgLS0gc3ByaXRlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBnYW1l
IG9uIHRoZSBtYWluIG1lbnUuDQoJCQktLSBjYW4gYmUgdXNlcmRhdGENCgkJCS0tIHdpbGwgZGVm
YXVsdCB0byBzcHJpdGUgMCBpbiAxLmdmeCBpZiBvbmUgaXNuJ3QgcHJvdmlkZWQNCgkJbmFtZSA9
ICJuYW1lIG9mIHRoZSBnYW1lIiwgLS0gZG9lcyBub3QgaGF2ZSB0byBtYXRjaCB0aGUgZmlsZSBu
YW1lDQoJCWF1dGhvciA9ICJZT1UhIiwNCgkJZGVzY3JpcHRpb24gPSAiUXVpY2sgZGVzY3JpcHRp
b24gb2YgdGhlIGdhbWUiLA0KCQlydWxlcyA9IHsNCgkJCSJ0YWJsZSBvZiBydWxlcyB0byBoZWxw
IHRoZSBwbGF5ZXIiDQoJCX0sDQoJCWRlc2Nfc2NvcmUgPSB7IC0tIGV4dHJhIGluZm9ybWF0aW9u
IGFib3V0IHRoZSBwbGF5ZXIncyBzYXZlDQoJCQlmb3JtYXQgPSAiV2lucyA6ICVpIiwgLS0gcmFu
IHRocm91Z2ggc3RyaW5nLmZvcm1hdA0KCQkJcGFyYW0gPSB7IndpbnMifSAtLSBrZXlzIGluZGV4
aW5nIHRoZSBnYW1lIHNhdmUNCgkJfSwNCgkJYXBpX3ZlcnNpb24gPSAyLCAtLSBtdXN0IG1hdGNo
IHRoZSBjdXJyZW50IGFwaSB2ZXJzaW9uIHRvIGVuc3VyZSBjb21wYXRhYmlsaXR5LCB0aGVyZSBj
b3VsZCBiZSBicmVha2luZyBjaGFuZ2VzIGluIHRoZSBmdXR1cmUNCgkJLS0gb3JkZXIgPSAzLCAt
LSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBsaXN0IG9mIGdhbWVzLCBncm91cGVkIHVwIGJ5IG1vZA0K
CX0NCmVuZA0KYGBgDQoNCiMjIyBHQU1FTkFNRS5sdWENCg0KSW5zaWRlIHRoZSBwcmltYXJ5IGx1
YSBmaWxlLCB5b3Ugc2hvdWxkIGhhdmUgc29tZXRoaW5nIHNpbWlsYXIgdG8gdGhpcy4NCg0KYGBg
bHVhDQotLSBtb3N0bHkgZm9yIGVhc2Ugb2YgdXNlIGxpa2UgX2luaXQoKSANCmZ1bmN0aW9uIGdh
bWVfc2V0dXAoKQ0KCS0tIGNyZWF0ZSBhbnkgc3RhY2tzLCBjYXJkcywgb3Igb3RoZXIgb2JqZWN0
cyBoZXJlDQplbmQNCg0KLS0gY2FsbGVkIHdoZW4gdGhlIGdhbWUgaXMgYWJvdXQgdG8gZXhpdCBh
IGdhbWUgdmFyaWFudA0KZnVuY3Rpb24gZ2FtZV9vbl9leGl0KCkgZW5kDQoNCi0tIGZ1bmN0aW9u
cyBjYWxsZWQgZm9yIHdoZW4gdGhlIGdhbWUgc2V0dGluZ3MgYXJlIG9wZW5lZCBvciBjbG9zZWQN
CmZ1bmN0aW9uIGdhbWVfc2V0dGluZ3Nfb3BlbmVkKCkgZW5kDQpmdW5jdGlvbiBnYW1lX3NldHRp
bmdzX2Nsb3NlZCgpIGVuZA0KDQotLSBmdW5jdGlvbnMgZm9yIGEgY3VzdG9tIHRyYW5zaXRpb24N
Ci0tIGNhbiBiZSBsZWZ0IHVuZGVmaW5lZCwgYW5kIGEgZGVmYXVsdCB0cmFuc2l0aW9uIHdpbGwg
dGFrZSBwbGFjZQ0KZnVuY3Rpb24gZ2FtZV90cmFuc2l0aW9uX2luaXQoKSBlbmQNCmZ1bmN0aW9u
IGdhbWVfdHJhbnNpdGlvbl9kcmF3KCkgZW5kDQpmdW5jdGlvbiBnYW1lX3RyYW5zaXRpb25fdXBk
YXRlKCkgZW5kDQoNCi0tIGZ1bmN0aW9ucyBkZXRhaWxlZCBpbiB0aGUgQ2FyZCBBUEkNCmZ1bmN0
aW9uIGdhbWVfdXBkYXRlKCkgZW5kDQpmdW5jdGlvbiBnYW1lX2RyYXcoKSBlbmQNCmZ1bmN0aW9u
IGdhbWVfd2luX2NvbmRpdGlvbigpIGVuZA0KZnVuY3Rpb24gZ2FtZV9jb3VudF93aW4oKSBlbmQN
CmZ1bmN0aW9uIGdhbWVfYWN0aW9uX3Jlc29sdmVkKCkgZW5kDQoNCi0tIGZ1bmN0aW9uIHRoYXQg
d2lsbCBiZSBjYWxsZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgaW4gZ2FtZQ0KLS0gaWYgYW4gZXJy
b3Igb2NjdXJzLCB0aGUgZ2FtZSB3aWxsIGJlIGJvb3RlZCBiYWNrIHRvIHRoZSBtYWluIG1lbnUN
Ci0tIHRoaXMgY2FuIGJlIHVzZWQgdG8gc2F2ZSB0aGUgc3RhdGUgb2YgdGhlIGdhbWUsIHRvIGJl
IHJldHVybmVkIHRvIGxhdGVyDQpmdW5jdGlvbiBzdWJnYW1lX29uX2Vycm9yKCkgZW5kDQpgYGAN
Cg0KIyMjIEN1c3RvbSBDYXJkIEJhY2tzDQoNCkJ5IHB1dHRpbmcgYSBsdWEgZmlsZSBpbnNpZGUg
YC9hcHBkYXRhL3NvbGl0YWlyZV9zdWl0ZS9jYXJkX2JhY2tzL2AgeW91IGNhbiBjcmVhdGUgeW91
ciBvd24gY2FyZCBiYWNrcy4NClRoZXNlIGNhbiBhbHNvIGJlIGluY2x1ZGVkIGluIHlvdXIgbW9k
cyB1bmRlciBgc29saXRhaXJlX3N1aXRlLnA2NC9jYXJkX2JhY2tzL2AgdG8gYmUgc2hhcmFibGUg
d2l0aCBvdGhlcnMuDQoNCmBgYGx1YQ0KZnVuY3Rpb24gZ2V0X2luZm8oKQ0KCXJldHVybiB7DQoJ
CS0tZWFjaCBlbnRyeSBpcyBhIGNhcmQgYmFjaw0KCQl7DQoJCQlzcHJpdGUgPSBjYXJkX2JhY2tf
YXJ0LCAtLSB1c2VyZGF0YSBvciBmdW5jdGlvbi4gc3ByaXRlIGlkcyB3aWxsIG9ubHkgcHVsbCBm
cm9tIDAuZ2Z4DQoJCQkNCgkJCWFydGlzdCA9ICJBcnRpc3QiLCAtLSB3aG8gbWFkZSB0aGUgYXJ0
DQoJCQkNCgkJCWxvcmUgPSAiaW5mbyBhYm91dCB0aGUgYXJ0IG9yIHdoYXRldmVyIHlvdSB3YW50
Ig0KCQl9DQoJfQ0KZW5kDQoNCi0tIGlmIHlvdSdyZSB1c2luZyBhIGZ1bmN0aW9uIHRyeSB0byBm
b2xsb3cgdGhpcyBmb3JtYXQNCmZ1bmN0aW9uIGNhcmRfYmFja19hcnQoZGF0YSwgd2lkdGgsIGhl
aWdodCkNCgktLSBkYXRhIGhhcyB0aGUgdGFibGUgcmV0dXJuZWQgYnkgZ2V0X2luZm8oKSwganVz
dCBpbiBjYXNlIHlvdSBuZWVkIHRvIGdldCB0aGUgc3ByaXRlIGl0c2VsZiBvciBpZiB5b3Ugd2Fu
dCB0byBzdG9yZSBleHRyYSBkYXRhDQoJLS0gd2lkdGggYW5kIGhlaWdodCBhcmUgdGhlIHNpemUg
b2YgdGhlIGRyYXdhYmxlIGFyZWENCgktLSB0aGVzZSBhcmUgZGlmZmVyZW50IGZyb20gdGhlIGFj
dHVhbCBjYXJkIHNwcml0ZSdzIHNpemUNCgkNCgktLSBjYW1lcmEsIGNsaXAsIGFuZCBzZXRfcmVu
ZGVyX3RhcmdldCgpIGFyZSB1c2VkIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbiB0byBoZWxwIHNp
bXBsaWZ5IHRoZSBwcm9jZXNzDQoJLS0gISEhIGRvIE5PVCB1c2UgdGhlIGZ1bmN0aW9ucyBjbGlw
IG9yIGNscyAhISENCgkNCglyZWN0ZmlsbCgwLCAwLCB3aWR0aCwgaGVpZ2h0LCAyKQ0KCWNpcmNm
aWxsKHdpZHRoLzIsIGhlaWdodC8yLCB3aWR0aC8yICsgc2luKHRpbWUoKS81KSAqIDUgLCAxMCkN
CgkNCgktLSBjb2xvciAzMiBpcyBzcGVjaWFsLCBhbmQgY2FuIGJlIHVzZWQgZm9yIGRhcmtlbmlu
ZyBjb2xvcnMgKGZvciBzdHVmZiBsaWtlIHNoYWRvd3MpDQplbmQNCmBgYA0KDQojIyMgRW5jbG9z
ZWQgRU5WDQoNCkxvYWRlZCBnYW1lcyBoYXZlIHRoZWlyIG93biBFTlYgdGFibGUgdG8gcHJldmVu
dCBjcm9zcyBjb250YW1pbmF0aW9uIGFuZCBpbmFwcHJvcHJpYXRlIGFjY2VzcyB0byBmdW5jdGlv
bnMgYW5kIHZhcmlhYmxlcyBmcm9tIG90aGVyIGdhbWVzIGFuZCB0aGUgc3VpdGUgaXRzZWxmLg0K
T25seSBmdW5jdGlvbnMgYXJlIGNvcGllZCBvdmVyIHRvIHRoZSBuZXcgRU5WLg0KVGhpcyBpcyBh
bHNvIHRvIHByZXZlbnQgbWFsaWNpb3VzIG1vZHMsIHRob3VnaCBpZiB0aGVyZSBpcyBzb21ldGhp
bmcgbWlzc2luZywgcGxlYXNlIGxldCBtZSBrbm93DQoNCmBgYGx1YQ0KLS0gYXQgdGhlIG1vbWVu
dCwgdGhlIGZvbGxvd2luZyBpcyBwcmV2ZW50ZWQgYWNjZXNzDQotLSB0aGlzIGNhbiBiZSBmb3Vu
ZCBuZWFyIHRoZSBzdGFydCBvZiBzdWl0ZV91dGlsLmx1YSwgYXNzaWduZWQgdG8gYmFubmVkX2Vu
dg0KDQpiYW5uZWRfZW52ID0gc3BsaXQoW1sNCg0KY3ANCnJtDQpta19kaXINCm12DQpjcmVhdGVf
cHJvY2Vzcw0KZW52DQp3aW5kb3cNCg0Kc3RvcmUNCmluY2x1ZGUNCmZldGNoDQoNCi4uLg0KDQpd
XSwgIlxuIiwgZmFsc2UpDQoNCg0KYGBgDQoNCiMjIFN1aXRlIEZ1bmN0aW9ucw0KDQpgYGBsdWEN
Ci0tIGNhbGxlZCB0byBleGl0IGEgZ2FtZQ0KLS0gY3VycmVudGx5IGRvZXNuJ3QgZG8gbXVjaCwg
YnV0IHdpbGwgYmUgaW1wb3J0YW50IGxhdGVyDQpzdWl0ZV9leGl0X2dhbWUoKQ0KDQotLSBnZXRz
IHNhdmUgZGF0YSBhcyBhIHRhYmxlICh3aXRoICJvciBkZWZhdWx0cyIgaWYgb25lIGRvZXNuJ3Qg
ZXhpdHMpDQotLSBhdXRvbWF0aWNhbGx5IG1hbmFnZSBzYXZlIGxvY2F0aW9uDQpsb2NhbCBzYXZl
X2luZm8gPSBzdWl0ZV9sb2FkX3NhdmUoKSBvciB7IHdpbnMgPSAwIH0NCg0KLS0gc3RvcmVzIHNh
dmUgZGF0YQ0Kc3VpdGVfc3RvcmVfc2F2ZShzYXZlX2luZm8pDQoNCi0tIGNyZWF0ZXMgbW9zdCBv
ZiB0aGUgbWVudSBiYXIgYXQgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuLiBWZXJ5IGltcG9ydGFu
dCB0byBjYWxsIG9yIGFkZCBzb21ldGhpbmcgc2ltaWxhcg0Kc3VpdGVfbWVudWl0ZW1faW5pdCgp
DQoNCi0tY3JlYXRlcyBhIGJ1dHRvbiBmb3IgdGhlIG1lbnUgYmFyDQpzdWl0ZV9tZW51aXRlbShw
YXJhbSkNCi0tW1sNCnBhcmFtIGlzIGEgdGFibGUgd2l0aCB0aGUgZm9sbG93aW5nIHBvc3NpYmxl
IHZhbHVlcw0KDQp0ZXh0ID0gdGV4dCBkaXNwbGF5ZWQgb24gdGhlIGJ1dHRvbg0Kb25fY2xpY2sg
PSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQNCnZhbHVlID0gZXh0
cmEgaW5mbyBkaXNwbGF5ZWQgbmV4dCB0byB0aGUgdGV4dCB0aGF0IGNhbiBiZSB1cGRhdGVkLCBs
aWtlIGEgd2luIGNvdW50ZXINCgljYW4gYmUgbGVmdCBuaWwNCnBhZ2VzID0gdGFibGUgb2Ygc3Ry
aW5ncyBvciB1c2VyZGF0YSB0aGF0IGJlIGRpc3BsYXllZCBvbiBhIHNlcGVyYXRlIHdpbmRvdyB3
aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZA0KCW5vdGUgdGhhdCB0aGlzIHdpbGwgcmVwbGFjZSB0
aGUgb25fY2xpY2sgY2FsbA0KY29sb3JzID0gdGFibGUgb2YgY29sb3IgdmFsdWVzIHRvIGRyYXcg
dGhlIGJ1dHRvbiB3aXRoDQpdXQ0KDQotLSBjcmVhdGVzIGEgYnV0dG9uIGZvciB0aGUgbWVudSBi
YXIgZm9yIGRpc3BsYXlpbmcgdGhlIGdhbWUncyBydWxlcw0KLS0gdGhlIHdpZHRoIGFuZCBoZWln
aHQgb2YgdGhlIHdpbmRvdyBjYW4gYmUgYWRqdXN0ZWQNCnN1aXRlX21lbnVpdGVtX3J1bGVzKHdp
ZHRoLCBoZWlnaHQpDQoNCi0tY3JlYXRlcyBhIHNpbXBsZSBidXR0b24NCnN1aXRlX2J1dHRvbl9z
aW1wbGUocGFyYW0pDQotLVtbDQpwYXJhbSBpcyBhIHRhYmxlIHdpdGggdGhlIGZvbGxvd2luZyBw
b3NzaWJsZSB2YWx1ZXMNCg0KeCwgeSA9IHBvc2l0aW9uIG9mIHRoZSBidXR0b24NCnRleHQgPSB0
ZXh0IGRpc3BsYXllZCBvbiB0aGUgYnV0dG9uLCBhbHNvIGNvbnRyb2xsaW5nIHRoZSBzaXplDQpv
bl9jbGljayA9IGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZA0KZ3Jv
dXAgPSBkcmF3aW5nIGdyb3VwIHRoZSBidXR0b24gYmVsb25ncyB0bywgZGVmYXVsdHMgdG8gMQ0K
YWx3YXlzX2FjdGl2ZSA9IGlmIHRydWUsIHRoZW4gdGhlIGJ1dHRvbiBjYW4gYmUgY2xpY2tlZCBl
dmVuIGlmIGFuIGFuaW1hdGlvbiBpcyBwbGF5aW5nDQpjb2xvcnMgPSB0YWJsZSBvZiBjb2xvcnMg
dGhhdCB0aGUgYnV0dG9uIGlzIGRyYXduIHdpdGgNCg0KXV0NCmBgYA0KDQpUaGVyZSdzIGFsc28g
b3RoZXIgbHVhIGZpbGVzIGluc2lkZSBgL3NvbGl0YWlyZV9zdWl0ZS5wNjQvc3VpdGVfc2NyaXB0
cy9gIHRoYXQgY2FuIGhlbHAuDQoNCiMjIENhcnQgTWV0YWRhdGENCg0KWW91IGNhbiBlZGl0IHRo
ZSBjYXJ0J3MgbWV0YWRhdGEgdG8gZGlzcGxheSBpbmZvcm1hdGlvbiBpbnNpZGUgdGhlIG1vZCBt
YW5hZ2VyLg0KVGl0bGUsIHZlcnNpb24sIGF1dGhvciwgbm90ZXMgYW5kIHRoZSBpY29uIHdpbGwg
c2hvdyB3aGVuIHRoZSBtb2QgaXMgaW5zdGFsbGVkIGFuZCBzZWxlY3RlZC4NCg==
:: todo.lua
--[[pod_format="raw",created="2024-12-15 00:56:30",modified="2024-12-15 00:56:37",revision=1]]

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9Ildlcnh6eSIsY3JlYXRlZD0iMjAyNC0wNC0xNiAyMjozNDo1NCIs
aWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAwMDAw
MDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAwMDAwMDEwNzA3MDcwNzBkMDcwNzA3
MDcwMTAwMDAwMDAwMDAwMTA3MDcwNzBkMGQwZDA3MDcwNzAxMDAwMDAwMDAwMDAxMDcwNzBkMGQw
ZDBkMGQwNzA3MDEwMDAwMDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMDcwMTAwMDAwMDAwMDAwMTA3
MGQwZDBkMGQwZDBkMGQwNzAxMDAwMDAwMDAwMDAxMDcwNzBkMGQwNzBkMGQwNzA3MDEwMDAwMDAw
MDAwMDEwNzA3MDcwNzBkMDcwNzA3MDcwMTAwMDAwMDAwMDAwMTA3MDcwNzBkMGQwZDA3MDcwNzAx
MDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAwMDAwMDEwZDBkMGQwZDBkMGQw
ZDBkMGQwMTAwMDAwMDAwMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAwMDAwMDAxMGQwZDBk
MGQwZDBkMGQwZDBkMDEwMDAwMDAwMDAwMDEwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAwMDAw
MDAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVkPSIyMDI0LTEyLTE1IDAwOjU2OjQ3
Iixub3Rlcz0iIixydW50aW1lPTEyLHN0b3JlZD0iMjAyNC0wNC0xMyAxNjowNDo0NSIsdGl0bGU9
IlNvbGl0YWlyZSBTdWl0ZSIsdmVyc2lvbj0iMC4yLjAiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0i
bWFpbi5sdWEjMTQiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InRvZG8ubHVhIzciLHdv
cmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InN1aXRlX3NjcmlwdHMvbWFpbl9tZW51Lmx1YSM2
NDIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InN1aXRlX3NjcmlwdHMvc3VpdGVfdXRp
bC5sdWEjMTEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3Nw
YWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0iY2FyZF9nYW1lcy9mYWxsaW5nX2NhcmRzLzEuZ2Z4Iix3
b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0z
fSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9fV1d
:: [eoc]
